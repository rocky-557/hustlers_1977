import "./chunk-BEI2G2LW.js";
import {
  writable
} from "./chunk-BMARWV5F.js";
import {
  fade
} from "./chunk-B3B3C2FW.js";
import "./chunk-VFRMSNTO.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_flush_callback,
  add_location,
  add_render_callback,
  afterUpdate,
  append_dev,
  append_styles,
  assign,
  attr_dev,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  component_subscribe,
  compute_rest_props,
  compute_slots,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_bidirectional_transition,
  create_component,
  create_in_transition,
  create_out_transition,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  init_binding_group,
  insert_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  prevent_default,
  run_all,
  safe_not_equal,
  select_option,
  select_options,
  select_value,
  setContext,
  set_attributes,
  set_data_dev,
  set_input_value,
  set_style,
  space,
  src_url_equal,
  svg_element,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-Y77QZTQZ.js";
import "./chunk-GRYSN4OO.js";

// node_modules/@sveltestrap/sveltestrap/dist/utils.js
function getOriginalBodyPadding() {
  const style = window ? window.getComputedStyle(document.body, null) : {};
  return parseInt(style && style.getPropertyValue("padding-right") || 0, 10);
}
function getScrollbarWidth() {
  let scrollDiv = document.createElement("div");
  scrollDiv.style.position = "absolute";
  scrollDiv.style.top = "-9999px";
  scrollDiv.style.width = "50px";
  scrollDiv.style.height = "50px";
  scrollDiv.style.overflow = "scroll";
  document.body.appendChild(scrollDiv);
  const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
  document.body.removeChild(scrollDiv);
  return scrollbarWidth;
}
function setScrollbarWidth(padding) {
  document.body.style.paddingRight = padding > 0 ? `${padding}px` : null;
}
function isBodyOverflowing() {
  return window ? document.body.clientWidth < window.innerWidth : false;
}
function isObject(value) {
  const type = typeof value;
  return value !== null && (type === "object" || type === "function");
}
function conditionallyUpdateScrollbar() {
  const scrollbarWidth = getScrollbarWidth();
  const fixedContent = document.querySelectorAll(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top")[0];
  const bodyPadding = fixedContent ? parseInt(fixedContent.style.paddingRight || 0, 10) : 0;
  if (isBodyOverflowing()) {
    setScrollbarWidth(bodyPadding + scrollbarWidth);
  }
}
function getColumnSizeClass(isXs, colWidth, colSize) {
  if (colSize === true || colSize === "") {
    return isXs ? "col" : `col-${colWidth}`;
  } else if (colSize === "auto") {
    return isXs ? "col-auto" : `col-${colWidth}-auto`;
  }
  return isXs ? `col-${colSize}` : `col-${colWidth}-${colSize}`;
}
function browserEvent(target, ...args) {
  target.addEventListener(...args);
  return () => target.removeEventListener(...args);
}
function getNewCarouselActiveIndex(direction, items, activeIndex) {
  if (direction === "prev") {
    return activeIndex === 0 ? items.length - 1 : activeIndex - 1;
  }
  if (direction === "next") {
    return activeIndex === items.length - 1 ? 0 : activeIndex + 1;
  }
}
function toClassName(value) {
  let result = "";
  if (typeof value === "string" || typeof value === "number") {
    result += value;
  } else if (typeof value === "object") {
    if (Array.isArray(value)) {
      result = value.map(toClassName).filter(Boolean).join(" ");
    } else {
      for (let key in value) {
        if (value[key]) {
          result && (result += " ");
          result += key;
        }
      }
    }
  }
  return result;
}
var classnames = (...args) => args.map(toClassName).filter(Boolean).join(" ");
function getTransitionDuration(element2) {
  if (!element2)
    return 0;
  let { transitionDuration, transitionDelay } = window.getComputedStyle(element2);
  const floatTransitionDuration = Number.parseFloat(transitionDuration);
  const floatTransitionDelay = Number.parseFloat(transitionDelay);
  if (!floatTransitionDuration && !floatTransitionDelay) {
    return 0;
  }
  transitionDuration = transitionDuration.split(",")[0];
  transitionDelay = transitionDelay.split(",")[0];
  return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * 1e3;
}
function uuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}

// node_modules/@sveltestrap/sveltestrap/dist/Accordion/Accordion.svelte
var file = "node_modules/@sveltestrap/sveltestrap/dist/Accordion/Accordion.svelte";
function create_fragment(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let div_levels = [
    { class: (
      /*classes*/
      ctx[1]
    ) },
    { "data-bs-theme": (
      /*theme*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file, 62, 0, 1401);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) },
        (!current || dirty & /*theme*/
        1) && { "data-bs-theme": (
          /*theme*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "flush", "stayOpen", "theme"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $open;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Accordion", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { class: className = "" } = $$props;
  let { flush = false } = $$props;
  let { stayOpen = false } = $$props;
  let { theme = void 0 } = $$props;
  const open = writable(null);
  validate_store(open, "open");
  component_subscribe($$self, open, (value) => $$invalidate(9, $open = value));
  setContext("accordion", {
    open,
    stayOpen,
    /**
    * Toggles the open state of the accordion based on the provided ID.
    * @param {HTMLDivElement} element - The accordion item element
    */
    toggle: (element2) => {
      if ($open === element2) {
        open.set(null);
      } else {
        open.set(element2);
      }
      dispatch("toggle", { [element2]: $open === element2 });
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("flush" in $$new_props)
      $$invalidate(5, flush = $$new_props.flush);
    if ("stayOpen" in $$new_props)
      $$invalidate(6, stayOpen = $$new_props.stayOpen);
    if ("theme" in $$new_props)
      $$invalidate(0, theme = $$new_props.theme);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    setContext,
    writable,
    classnames,
    dispatch,
    className,
    flush,
    stayOpen,
    theme,
    open,
    classes,
    $open
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("flush" in $$props)
      $$invalidate(5, flush = $$new_props.flush);
    if ("stayOpen" in $$props)
      $$invalidate(6, stayOpen = $$new_props.stayOpen);
    if ("theme" in $$props)
      $$invalidate(0, theme = $$new_props.theme);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, flush*/
    48) {
      $:
        $$invalidate(1, classes = classnames(className, "accordion", { "accordion-flush": flush }));
    }
  };
  return [theme, classes, open, $$restProps, className, flush, stayOpen, $$scope, slots];
}
var Accordion = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      class: 4,
      flush: 5,
      stayOpen: 6,
      theme: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Accordion",
      options,
      id: create_fragment.name
    });
  }
  get class() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flush() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flush(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stayOpen() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stayOpen(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Accordion_default = Accordion;

// node_modules/@sveltestrap/sveltestrap/dist/AccordionHeader/AccordionHeader.svelte
var file2 = "node_modules/@sveltestrap/sveltestrap/dist/AccordionHeader/AccordionHeader.svelte";
function create_fragment2(ctx) {
  let h2;
  let button;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let h2_levels = [
    { class: "accordion-header" },
    /*$$restProps*/
    ctx[1]
  ];
  let h2_data = {};
  for (let i = 0; i < h2_levels.length; i += 1) {
    h2_data = assign(h2_data, h2_levels[i]);
  }
  const block = {
    c: function create() {
      h2 = element("h2");
      button = element("button");
      if (default_slot)
        default_slot.c();
      attr_dev(button, "type", "button");
      attr_dev(
        button,
        "class",
        /*classes*/
        ctx[0]
      );
      add_location(button, file2, 15, 2, 328);
      set_attributes(h2, h2_data);
      add_location(h2, file2, 14, 0, 279);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      append_dev(h2, button);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[5],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classes*/
      1) {
        attr_dev(
          button,
          "class",
          /*classes*/
          ctx2[0]
        );
      }
      set_attributes(h2, h2_data = get_spread_update(h2_levels, [
        { class: "accordion-header" },
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AccordionHeader", slots, ["default"]);
  let { class: className = "" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "accordion-button"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots, click_handler];
}
var AccordionHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AccordionHeader",
      options,
      id: create_fragment2.name
    });
  }
  get class() {
    throw new Error("<AccordionHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<AccordionHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AccordionHeader_default = AccordionHeader;

// node_modules/@sveltestrap/sveltestrap/dist/transitions.js
function backdropIn(node) {
  node.style.display = "block";
  const duration = getTransitionDuration(node);
  return {
    duration,
    tick: (t) => {
      if (t === 0) {
        node.classList.add("show");
      }
    }
  };
}
function backdropOut(node) {
  node.classList.remove("show");
  const duration = getTransitionDuration(node);
  return {
    duration,
    tick: (t) => {
      if (t === 0) {
        node.style.display = "none";
      }
    }
  };
}
function collapseOut(node, params) {
  const dimension = params.horizontal ? "width" : "height";
  node.style[dimension] = `${node.getBoundingClientRect()[dimension]}px`;
  node.classList.add("collapsing");
  node.classList.remove("collapse", "show");
  const duration = getTransitionDuration(node);
  return {
    duration,
    tick: (t) => {
      if (t > 0) {
        node.style[dimension] = "";
      } else if (t === 0) {
        node.classList.remove("collapsing");
        node.classList.add("collapse");
      }
    }
  };
}
function collapseIn(node, params) {
  const horizontal = params.horizontal;
  const dimension = horizontal ? "width" : "height";
  node.classList.add("collapsing");
  node.classList.remove("collapse", "show");
  node.style[dimension] = 0;
  const duration = getTransitionDuration(node);
  return {
    duration,
    tick: (t) => {
      if (t < 1) {
        if (horizontal) {
          node.style.width = `${node.scrollWidth}px`;
        } else {
          node.style.height = `${node.scrollHeight}px`;
        }
      } else {
        node.classList.remove("collapsing");
        node.classList.add("collapse", "show");
        node.style[dimension] = "";
      }
    }
  };
}
function modalIn(node) {
  node.style.display = "block";
  const duration = getTransitionDuration(node);
  return {
    duration,
    tick: (t) => {
      if (t > 0) {
        node.classList.add("show");
      }
    }
  };
}
function modalOut(node) {
  node.classList.remove("show");
  const duration = getTransitionDuration(node);
  return {
    duration,
    tick: (t) => {
      if (t === 1) {
        node.style.display = "none";
      }
    }
  };
}

// node_modules/@sveltestrap/sveltestrap/dist/toggle.js
var defaultToggleEvents = ["touchstart", "click"];
var toggle_default = (toggler, togglerFn) => {
  let unbindEvents;
  if (typeof toggler === "string" && typeof window !== "undefined" && document && document.createElement) {
    let selection = document.querySelectorAll(toggler);
    if (!selection.length) {
      selection = document.querySelectorAll(`#${toggler}`);
    }
    if (!selection.length) {
      throw new Error(`The target '${toggler}' could not be identified in the dom, tip: check spelling`);
    }
    defaultToggleEvents.forEach((event) => {
      selection.forEach((element2) => {
        element2.addEventListener(event, togglerFn);
      });
    });
    unbindEvents = () => {
      defaultToggleEvents.forEach((event) => {
        selection.forEach((element2) => {
          element2.removeEventListener(event, togglerFn);
        });
      });
    };
  }
  return () => {
    if (typeof unbindEvents === "function") {
      unbindEvents();
      unbindEvents = void 0;
    }
  };
};

// node_modules/@sveltestrap/sveltestrap/dist/Collapse/Collapse.svelte
var file3 = "node_modules/@sveltestrap/sveltestrap/dist/Collapse/Collapse.svelte";
function create_if_block(ctx) {
  let div;
  let div_style_value;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  let div_levels = [
    {
      style: div_style_value = /*navbar*/
      ctx[2] ? void 0 : "overflow: hidden;"
    },
    /*$$restProps*/
    ctx[9],
    { class: (
      /*classes*/
      ctx[8]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file3, 63, 2, 1571);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "introstart",
            /*introstart_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "introend",
            /*introend_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outrostart",
            /*outrostart_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outroend",
            /*outroend_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "introstart",
            function() {
              if (is_function(
                /*onEntering*/
                ctx[3]
              ))
                ctx[3].apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "introend",
            function() {
              if (is_function(
                /*onEntered*/
                ctx[4]
              ))
                ctx[4].apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outrostart",
            function() {
              if (is_function(
                /*onExiting*/
                ctx[5]
              ))
                ctx[5].apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outroend",
            function() {
              if (is_function(
                /*onExited*/
                ctx[6]
              ))
                ctx[6].apply(this, arguments);
            },
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[15],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*navbar*/
        4 && div_style_value !== (div_style_value = /*navbar*/
        ctx[2] ? void 0 : "overflow: hidden;")) && { style: div_style_value },
        dirty & /*$$restProps*/
        512 && /*$$restProps*/
        ctx[9],
        (!current || dirty & /*classes*/
        256) && { class: (
          /*classes*/
          ctx[8]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div_outro)
            div_outro.end(1);
          div_intro = create_in_transition(div, collapseIn, { horizontal: (
            /*horizontal*/
            ctx[1]
          ) });
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div_intro)
        div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(div, collapseOut, { horizontal: (
          /*horizontal*/
          ctx[1]
        ) });
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div_outro)
        div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(63:0) {#if isOpen}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  add_render_callback(
    /*onwindowresize*/
    ctx[21]
  );
  let if_block = (
    /*isOpen*/
    ctx[0] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window,
          "resize",
          /*onwindowresize*/
          ctx[21]
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isOpen*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isOpen*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "isOpen",
    "class",
    "horizontal",
    "navbar",
    "onEntering",
    "onEntered",
    "onExiting",
    "onExited",
    "expand",
    "toggler"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Collapse", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { isOpen = false } = $$props;
  let { class: className = "" } = $$props;
  let { horizontal = false } = $$props;
  let { navbar = false } = $$props;
  let { onEntering = () => dispatch("opening") } = $$props;
  let { onEntered = () => dispatch("open") } = $$props;
  let { onExiting = () => dispatch("closing") } = $$props;
  let { onExited = () => dispatch("close") } = $$props;
  let { expand = false } = $$props;
  let { toggler = null } = $$props;
  onMount(() => toggle_default(toggler, (e) => {
    $$invalidate(0, isOpen = !isOpen);
    e.preventDefault();
  }));
  let windowWidth = 0;
  let _wasMaximized = false;
  const minWidth = {};
  minWidth["xs"] = 0;
  minWidth["sm"] = 576;
  minWidth["md"] = 768;
  minWidth["lg"] = 992;
  minWidth["xl"] = 1200;
  function notify() {
    dispatch("update", isOpen);
  }
  function introstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function introend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function outrostart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function outroend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function onwindowresize() {
    $$invalidate(7, windowWidth = window.innerWidth);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("class" in $$new_props)
      $$invalidate(10, className = $$new_props.class);
    if ("horizontal" in $$new_props)
      $$invalidate(1, horizontal = $$new_props.horizontal);
    if ("navbar" in $$new_props)
      $$invalidate(2, navbar = $$new_props.navbar);
    if ("onEntering" in $$new_props)
      $$invalidate(3, onEntering = $$new_props.onEntering);
    if ("onEntered" in $$new_props)
      $$invalidate(4, onEntered = $$new_props.onEntered);
    if ("onExiting" in $$new_props)
      $$invalidate(5, onExiting = $$new_props.onExiting);
    if ("onExited" in $$new_props)
      $$invalidate(6, onExited = $$new_props.onExited);
    if ("expand" in $$new_props)
      $$invalidate(11, expand = $$new_props.expand);
    if ("toggler" in $$new_props)
      $$invalidate(12, toggler = $$new_props.toggler);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    collapseIn,
    collapseOut,
    classnames,
    toggle: toggle_default,
    dispatch,
    isOpen,
    className,
    horizontal,
    navbar,
    onEntering,
    onEntered,
    onExiting,
    onExited,
    expand,
    toggler,
    windowWidth,
    _wasMaximized,
    minWidth,
    notify,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("className" in $$props)
      $$invalidate(10, className = $$new_props.className);
    if ("horizontal" in $$props)
      $$invalidate(1, horizontal = $$new_props.horizontal);
    if ("navbar" in $$props)
      $$invalidate(2, navbar = $$new_props.navbar);
    if ("onEntering" in $$props)
      $$invalidate(3, onEntering = $$new_props.onEntering);
    if ("onEntered" in $$props)
      $$invalidate(4, onEntered = $$new_props.onEntered);
    if ("onExiting" in $$props)
      $$invalidate(5, onExiting = $$new_props.onExiting);
    if ("onExited" in $$props)
      $$invalidate(6, onExited = $$new_props.onExited);
    if ("expand" in $$props)
      $$invalidate(11, expand = $$new_props.expand);
    if ("toggler" in $$props)
      $$invalidate(12, toggler = $$new_props.toggler);
    if ("windowWidth" in $$props)
      $$invalidate(7, windowWidth = $$new_props.windowWidth);
    if ("_wasMaximized" in $$props)
      $$invalidate(13, _wasMaximized = $$new_props._wasMaximized);
    if ("classes" in $$props)
      $$invalidate(8, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, horizontal, navbar*/
    1030) {
      $:
        $$invalidate(8, classes = classnames(className, {
          "collapse-horizontal": horizontal,
          "navbar-collapse": navbar
        }));
    }
    if ($$self.$$.dirty & /*navbar, expand, windowWidth, minWidth, isOpen, _wasMaximized*/
    26757) {
      $:
        if (navbar && expand) {
          if (windowWidth >= minWidth[expand] && !isOpen) {
            $$invalidate(0, isOpen = true);
            $$invalidate(13, _wasMaximized = true);
            notify();
          } else if (windowWidth < minWidth[expand] && _wasMaximized) {
            $$invalidate(0, isOpen = false);
            $$invalidate(13, _wasMaximized = false);
            notify();
          }
        }
    }
  };
  return [
    isOpen,
    horizontal,
    navbar,
    onEntering,
    onEntered,
    onExiting,
    onExited,
    windowWidth,
    classes,
    $$restProps,
    className,
    expand,
    toggler,
    _wasMaximized,
    minWidth,
    $$scope,
    slots,
    introstart_handler,
    introend_handler,
    outrostart_handler,
    outroend_handler,
    onwindowresize
  ];
}
var Collapse = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      isOpen: 0,
      class: 10,
      horizontal: 1,
      navbar: 2,
      onEntering: 3,
      onEntered: 4,
      onExiting: 5,
      onExited: 6,
      expand: 11,
      toggler: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Collapse",
      options,
      id: create_fragment3.name
    });
  }
  get isOpen() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get horizontal() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set horizontal(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navbar() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navbar(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onEntering() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onEntering(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onEntered() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onEntered(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onExiting() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onExiting(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onExited() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onExited(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expand() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expand(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggler() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggler(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Collapse_default = Collapse;

// node_modules/@sveltestrap/sveltestrap/dist/AccordionItem/AccordionItem.svelte
var file4 = "node_modules/@sveltestrap/sveltestrap/dist/AccordionItem/AccordionItem.svelte";
var get_header_slot_changes = (dirty) => ({});
var get_header_slot_context = (ctx) => ({});
function create_default_slot_1(ctx) {
  let t0;
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[9].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_header_slot_context
  );
  const block = {
    c: function create() {
      if (header_slot)
        header_slot.c();
      t0 = space();
      t1 = text(
        /*header*/
        ctx[0]
      );
    },
    m: function mount(target, anchor) {
      if (header_slot) {
        header_slot.m(target, anchor);
      }
      insert_dev(target, t0, anchor);
      insert_dev(target, t1, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_header_slot_changes
            ),
            get_header_slot_context
          );
        }
      }
      if (!current || dirty & /*header*/
      1)
        set_data_dev(
          t1,
          /*header*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(62:2) <AccordionHeader on:click={onToggle} class={!isOpen && 'collapsed'}>",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", "accordion-body");
      add_location(div, file4, 66, 4, 1494);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: '(66:2) <Collapse {isOpen} class=\\"accordion-collapse\\" on:introstart on:introend on:outrostart on:outroend>',
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let div;
  let accordionheader;
  let t;
  let collapse;
  let current;
  accordionheader = new AccordionHeader_default({
    props: {
      class: !/*isOpen*/
      ctx[2] && "collapsed",
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  accordionheader.$on(
    "click",
    /*onToggle*/
    ctx[5]
  );
  collapse = new Collapse_default({
    props: {
      isOpen: (
        /*isOpen*/
        ctx[2]
      ),
      class: "accordion-collapse",
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  collapse.$on(
    "introstart",
    /*introstart_handler*/
    ctx[10]
  );
  collapse.$on(
    "introend",
    /*introend_handler*/
    ctx[11]
  );
  collapse.$on(
    "outrostart",
    /*outrostart_handler*/
    ctx[12]
  );
  collapse.$on(
    "outroend",
    /*outroend_handler*/
    ctx[13]
  );
  const block = {
    c: function create() {
      div = element("div");
      create_component(accordionheader.$$.fragment);
      t = space();
      create_component(collapse.$$.fragment);
      attr_dev(
        div,
        "class",
        /*classes*/
        ctx[3]
      );
      add_location(div, file4, 60, 0, 1210);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(accordionheader, div, null);
      append_dev(div, t);
      mount_component(collapse, div, null);
      ctx[14](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const accordionheader_changes = {};
      if (dirty & /*isOpen*/
      4)
        accordionheader_changes.class = !/*isOpen*/
        ctx2[2] && "collapsed";
      if (dirty & /*$$scope, header*/
      32769) {
        accordionheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordionheader.$set(accordionheader_changes);
      const collapse_changes = {};
      if (dirty & /*isOpen*/
      4)
        collapse_changes.isOpen = /*isOpen*/
        ctx2[2];
      if (dirty & /*$$scope*/
      32768) {
        collapse_changes.$$scope = { dirty, ctx: ctx2 };
      }
      collapse.$set(collapse_changes);
      if (!current || dirty & /*classes*/
      8) {
        attr_dev(
          div,
          "class",
          /*classes*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(accordionheader.$$.fragment, local);
      transition_in(collapse.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(accordionheader.$$.fragment, local);
      transition_out(collapse.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(accordionheader);
      destroy_component(collapse);
      ctx[14](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let classes;
  let isOpen;
  let $open;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AccordionItem", slots, ["header", "default"]);
  let { class: className = "" } = $$props;
  let { header = "" } = $$props;
  let { active = false } = $$props;
  const dispatch = createEventDispatcher();
  const { stayOpen, toggle, open } = getContext("accordion");
  validate_store(open, "open");
  component_subscribe($$self, open, (value) => $$invalidate(8, $open = value));
  let accordionRef;
  onMount(() => {
    if (active) {
      toggle(accordionRef);
    }
  });
  const onToggle = () => {
    if (stayOpen) {
      $$invalidate(6, active = !active);
    }
    toggle(accordionRef);
    dispatch("toggle", !isOpen);
  };
  const writable_props = ["class", "header", "active"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AccordionItem> was created with unknown prop '${key}'`);
  });
  function introstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function introend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function outrostart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function outroend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      accordionRef = $$value;
      $$invalidate(1, accordionRef);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(7, className = $$props2.class);
    if ("header" in $$props2)
      $$invalidate(0, header = $$props2.header);
    if ("active" in $$props2)
      $$invalidate(6, active = $$props2.active);
    if ("$$scope" in $$props2)
      $$invalidate(15, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    getContext,
    onMount,
    AccordionHeader: AccordionHeader_default,
    Collapse: Collapse_default,
    classnames,
    className,
    header,
    active,
    dispatch,
    stayOpen,
    toggle,
    open,
    accordionRef,
    onToggle,
    isOpen,
    classes,
    $open
  });
  $$self.$inject_state = ($$props2) => {
    if ("className" in $$props2)
      $$invalidate(7, className = $$props2.className);
    if ("header" in $$props2)
      $$invalidate(0, header = $$props2.header);
    if ("active" in $$props2)
      $$invalidate(6, active = $$props2.active);
    if ("accordionRef" in $$props2)
      $$invalidate(1, accordionRef = $$props2.accordionRef);
    if ("isOpen" in $$props2)
      $$invalidate(2, isOpen = $$props2.isOpen);
    if ("classes" in $$props2)
      $$invalidate(3, classes = $$props2.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    128) {
      $:
        $$invalidate(3, classes = classnames(className, "accordion-item"));
    }
    if ($$self.$$.dirty & /*active, $open, accordionRef*/
    322) {
      $:
        $$invalidate(2, isOpen = stayOpen ? active : $open === accordionRef);
    }
  };
  return [
    header,
    accordionRef,
    isOpen,
    classes,
    open,
    onToggle,
    active,
    className,
    $open,
    slots,
    introstart_handler,
    introend_handler,
    outrostart_handler,
    outroend_handler,
    div_binding,
    $$scope
  ];
}
var AccordionItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { class: 7, header: 0, active: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AccordionItem",
      options,
      id: create_fragment4.name
    });
  }
  get class() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AccordionItem_default = AccordionItem;

// node_modules/@sveltestrap/sveltestrap/dist/Alert/Alert.svelte
var file5 = "node_modules/@sveltestrap/sveltestrap/dist/Alert/Alert.svelte";
var get_heading_slot_changes = (dirty) => ({});
var get_heading_slot_context = (ctx) => ({});
function create_if_block2(ctx) {
  let div;
  let t0;
  let t1;
  let current_block_type_index;
  let if_block2;
  let div_transition;
  let current;
  let if_block0 = (
    /*heading*/
    (ctx[3] || /*$$slots*/
    ctx[11].heading) && create_if_block_3(ctx)
  );
  let if_block1 = (
    /*showClose*/
    ctx[6] && create_if_block_2(ctx)
  );
  const if_block_creators = [create_if_block_1, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*children*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div_levels = [
    /*$$restProps*/
    ctx[10],
    { "data-bs-theme": (
      /*theme*/
      ctx[4]
    ) },
    { class: (
      /*classes*/
      ctx[8]
    ) },
    { role: "alert" }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if_block2.c();
      set_attributes(div, div_data);
      add_location(div, file5, 96, 2, 2002);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t1);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*heading*/
        ctx[3] || /*$$slots*/
        ctx[11].heading
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty & /*heading, $$slots*/
          2056) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*showClose*/
        ctx[6]
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_2(ctx);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block2.c();
        } else {
          if_block2.p(ctx, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div, null);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        1024 && /*$$restProps*/
        ctx[10],
        (!current || dirty & /*theme*/
        16) && { "data-bs-theme": (
          /*theme*/
          ctx[4]
        ) },
        (!current || dirty & /*classes*/
        256) && { class: (
          /*classes*/
          ctx[8]
        ) },
        { role: "alert" }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block2);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(
              div,
              fade,
              /*transition*/
              ctx[5],
              true
            );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(
            div,
            fade,
            /*transition*/
            ctx[5],
            false
          );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if_blocks[current_block_type_index].d();
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(96:0) {#if isOpen}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let h4;
  let t;
  let current;
  const heading_slot_template = (
    /*#slots*/
    ctx[19].heading
  );
  const heading_slot = create_slot(
    heading_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_heading_slot_context
  );
  const block = {
    c: function create() {
      h4 = element("h4");
      t = text(
        /*heading*/
        ctx[3]
      );
      if (heading_slot)
        heading_slot.c();
      attr_dev(h4, "class", "alert-heading");
      add_location(h4, file5, 98, 6, 2158);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h4, anchor);
      append_dev(h4, t);
      if (heading_slot) {
        heading_slot.m(h4, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*heading*/
      8)
        set_data_dev(
          t,
          /*heading*/
          ctx2[3]
        );
      if (heading_slot) {
        if (heading_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            heading_slot,
            heading_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              heading_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_heading_slot_changes
            ),
            get_heading_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(heading_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(heading_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h4);
      }
      if (heading_slot)
        heading_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(98:4) {#if heading || $$slots.heading}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let button;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      attr_dev(button, "type", "button");
      attr_dev(
        button,
        "class",
        /*closeClassNames*/
        ctx[7]
      );
      attr_dev(
        button,
        "aria-label",
        /*closeAriaLabel*/
        ctx[2]
      );
      add_location(button, file5, 103, 6, 2274);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          function() {
            if (is_function(
              /*handleToggle*/
              ctx[9]
            ))
              ctx[9].apply(this, arguments);
          },
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*closeClassNames*/
      128) {
        attr_dev(
          button,
          "class",
          /*closeClassNames*/
          ctx[7]
        );
      }
      if (dirty & /*closeAriaLabel*/
      4) {
        attr_dev(
          button,
          "aria-label",
          /*closeAriaLabel*/
          ctx[2]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(103:4) {#if showClose}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(108:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*children*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*children*/
      2)
        set_data_dev(
          t,
          /*children*/
          ctx2[1]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(106:4) {#if children}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*isOpen*/
    ctx[0] && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isOpen*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isOpen*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let showClose;
  let handleToggle;
  let classes;
  let closeClassNames;
  const omit_props_names = [
    "class",
    "children",
    "closeAriaLabel",
    "closeClassName",
    "color",
    "dismissible",
    "fade",
    "heading",
    "isOpen",
    "toggle",
    "theme",
    "transition"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Alert", slots, ["heading", "default"]);
  const $$slots = compute_slots(slots);
  let { class: className = "" } = $$props;
  let { children = void 0 } = $$props;
  let { closeAriaLabel = "Close" } = $$props;
  let { closeClassName = "" } = $$props;
  let { color = "success" } = $$props;
  let { dismissible = false } = $$props;
  let { fade: fade2 = true } = $$props;
  let { heading = "" } = $$props;
  let { isOpen = true } = $$props;
  let { toggle = void 0 } = $$props;
  let { theme = void 0 } = $$props;
  let { transition = { duration: fade2 ? 400 : 0 } } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(12, className = $$new_props.class);
    if ("children" in $$new_props)
      $$invalidate(1, children = $$new_props.children);
    if ("closeAriaLabel" in $$new_props)
      $$invalidate(2, closeAriaLabel = $$new_props.closeAriaLabel);
    if ("closeClassName" in $$new_props)
      $$invalidate(13, closeClassName = $$new_props.closeClassName);
    if ("color" in $$new_props)
      $$invalidate(14, color = $$new_props.color);
    if ("dismissible" in $$new_props)
      $$invalidate(15, dismissible = $$new_props.dismissible);
    if ("fade" in $$new_props)
      $$invalidate(16, fade2 = $$new_props.fade);
    if ("heading" in $$new_props)
      $$invalidate(3, heading = $$new_props.heading);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("toggle" in $$new_props)
      $$invalidate(17, toggle = $$new_props.toggle);
    if ("theme" in $$new_props)
      $$invalidate(4, theme = $$new_props.theme);
    if ("transition" in $$new_props)
      $$invalidate(5, transition = $$new_props.transition);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    fadeTransition: fade,
    classnames,
    className,
    children,
    closeAriaLabel,
    closeClassName,
    color,
    dismissible,
    fade: fade2,
    heading,
    isOpen,
    toggle,
    theme,
    transition,
    closeClassNames,
    showClose,
    classes,
    handleToggle
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(12, className = $$new_props.className);
    if ("children" in $$props)
      $$invalidate(1, children = $$new_props.children);
    if ("closeAriaLabel" in $$props)
      $$invalidate(2, closeAriaLabel = $$new_props.closeAriaLabel);
    if ("closeClassName" in $$props)
      $$invalidate(13, closeClassName = $$new_props.closeClassName);
    if ("color" in $$props)
      $$invalidate(14, color = $$new_props.color);
    if ("dismissible" in $$props)
      $$invalidate(15, dismissible = $$new_props.dismissible);
    if ("fade" in $$props)
      $$invalidate(16, fade2 = $$new_props.fade);
    if ("heading" in $$props)
      $$invalidate(3, heading = $$new_props.heading);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("toggle" in $$props)
      $$invalidate(17, toggle = $$new_props.toggle);
    if ("theme" in $$props)
      $$invalidate(4, theme = $$new_props.theme);
    if ("transition" in $$props)
      $$invalidate(5, transition = $$new_props.transition);
    if ("closeClassNames" in $$props)
      $$invalidate(7, closeClassNames = $$new_props.closeClassNames);
    if ("showClose" in $$props)
      $$invalidate(6, showClose = $$new_props.showClose);
    if ("classes" in $$props)
      $$invalidate(8, classes = $$new_props.classes);
    if ("handleToggle" in $$props)
      $$invalidate(9, handleToggle = $$new_props.handleToggle);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*dismissible, toggle*/
    163840) {
      $:
        $$invalidate(6, showClose = dismissible || toggle);
    }
    if ($$self.$$.dirty & /*toggle*/
    131072) {
      $:
        $$invalidate(9, handleToggle = toggle || (() => $$invalidate(0, isOpen = false)));
    }
    if ($$self.$$.dirty & /*className, color, showClose*/
    20544) {
      $:
        $$invalidate(8, classes = classnames(className, "alert", `alert-${color}`, { "alert-dismissible": showClose }));
    }
    if ($$self.$$.dirty & /*closeClassName*/
    8192) {
      $:
        $$invalidate(7, closeClassNames = classnames("btn-close", closeClassName));
    }
  };
  return [
    isOpen,
    children,
    closeAriaLabel,
    heading,
    theme,
    transition,
    showClose,
    closeClassNames,
    classes,
    handleToggle,
    $$restProps,
    $$slots,
    className,
    closeClassName,
    color,
    dismissible,
    fade2,
    toggle,
    $$scope,
    slots
  ];
}
var Alert = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      class: 12,
      children: 1,
      closeAriaLabel: 2,
      closeClassName: 13,
      color: 14,
      dismissible: 15,
      fade: 16,
      heading: 3,
      isOpen: 0,
      toggle: 17,
      theme: 4,
      transition: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Alert",
      options,
      id: create_fragment5.name
    });
  }
  get class() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeAriaLabel() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeAriaLabel(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeClassName() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeClassName(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dismissible() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dismissible(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fade() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fade(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get heading() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set heading(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transition() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Alert_default = Alert;

// node_modules/@sveltestrap/sveltestrap/dist/Badge/Badge.svelte
var file6 = "node_modules/@sveltestrap/sveltestrap/dist/Badge/Badge.svelte";
function create_else_block_1(ctx) {
  let span;
  let current_block_type_index;
  let if_block0;
  let t;
  let current;
  const if_block_creators = [create_if_block_4, create_else_block_2];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*children*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = (
    /*positioned*/
    (ctx[4] || /*indicator*/
    ctx[3]) && create_if_block_32(ctx)
  );
  let span_levels = [
    /*$$restProps*/
    ctx[7],
    { class: (
      /*classes*/
      ctx[6]
    ) },
    { "data-bs-theme": (
      /*theme*/
      ctx[5]
    ) }
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      set_attributes(span, span_data);
      add_location(span, file6, 113, 2, 2487);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if_blocks[current_block_type_index].m(span, null);
      append_dev(span, t);
      if (if_block1)
        if_block1.m(span, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(span, t);
      }
      if (
        /*positioned*/
        ctx2[4] || /*indicator*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_32(ctx2);
          if_block1.c();
          if_block1.m(span, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7],
        (!current || dirty & /*classes*/
        64) && { class: (
          /*classes*/
          ctx2[6]
        ) },
        (!current || dirty & /*theme*/
        32) && { "data-bs-theme": (
          /*theme*/
          ctx2[5]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(113:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let a;
  let current_block_type_index;
  let if_block0;
  let t;
  let current;
  const if_block_creators = [create_if_block_22, create_else_block2];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*children*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = (
    /*positioned*/
    (ctx[4] || /*indicator*/
    ctx[3]) && create_if_block_12(ctx)
  );
  let a_levels = [
    /*$$restProps*/
    ctx[7],
    { href: (
      /*href*/
      ctx[2]
    ) },
    { class: (
      /*classes*/
      ctx[6]
    ) },
    { "data-bs-theme": (
      /*theme*/
      ctx[5]
    ) }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      set_attributes(a, a_data);
      add_location(a, file6, 102, 2, 2232);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if_blocks[current_block_type_index].m(a, null);
      append_dev(a, t);
      if (if_block1)
        if_block1.m(a, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(a, t);
      }
      if (
        /*positioned*/
        ctx2[4] || /*indicator*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_12(ctx2);
          if_block1.c();
          if_block1.m(a, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7],
        (!current || dirty & /*href*/
        4) && { href: (
          /*href*/
          ctx2[2]
        ) },
        (!current || dirty & /*classes*/
        64) && { class: (
          /*classes*/
          ctx2[6]
        ) },
        (!current || dirty & /*theme*/
        32) && { "data-bs-theme": (
          /*theme*/
          ctx2[5]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(102:0) {#if href}",
    ctx
  });
  return block;
}
function create_else_block_2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_2.name,
    type: "else",
    source: "(117:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*children*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*children*/
      2)
        set_data_dev(
          t,
          /*children*/
          ctx2[1]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(115:4) {#if children}",
    ctx
  });
  return block;
}
function create_if_block_32(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*ariaLabel*/
        ctx[0]
      );
      attr_dev(span, "class", "visually-hidden");
      add_location(span, file6, 120, 6, 2662);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*ariaLabel*/
      1)
        set_data_dev(
          t,
          /*ariaLabel*/
          ctx2[0]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(120:4) {#if positioned || indicator}",
    ctx
  });
  return block;
}
function create_else_block2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(106:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*children*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*children*/
      2)
        set_data_dev(
          t,
          /*children*/
          ctx2[1]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(104:4) {#if children}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*ariaLabel*/
        ctx[0]
      );
      attr_dev(span, "class", "visually-hidden");
      add_location(span, file6, 109, 6, 2411);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*ariaLabel*/
      1)
        set_data_dev(
          t,
          /*ariaLabel*/
          ctx2[0]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(109:4) {#if positioned || indicator}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block3, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*href*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "ariaLabel",
    "border",
    "class",
    "children",
    "color",
    "href",
    "indicator",
    "pill",
    "positioned",
    "placement",
    "shadow",
    "theme"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Badge", slots, ["default"]);
  let { ariaLabel = "" } = $$props;
  let { border = false } = $$props;
  let { class: className = "" } = $$props;
  let { children = "" } = $$props;
  let { color = "secondary" } = $$props;
  let { href = "" } = $$props;
  let { indicator = false } = $$props;
  let { pill = false } = $$props;
  let { positioned = false } = $$props;
  let { placement = "top-0 start-100" } = $$props;
  let { shadow = false } = $$props;
  let { theme = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ariaLabel" in $$new_props)
      $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
    if ("border" in $$new_props)
      $$invalidate(8, border = $$new_props.border);
    if ("class" in $$new_props)
      $$invalidate(9, className = $$new_props.class);
    if ("children" in $$new_props)
      $$invalidate(1, children = $$new_props.children);
    if ("color" in $$new_props)
      $$invalidate(10, color = $$new_props.color);
    if ("href" in $$new_props)
      $$invalidate(2, href = $$new_props.href);
    if ("indicator" in $$new_props)
      $$invalidate(3, indicator = $$new_props.indicator);
    if ("pill" in $$new_props)
      $$invalidate(11, pill = $$new_props.pill);
    if ("positioned" in $$new_props)
      $$invalidate(4, positioned = $$new_props.positioned);
    if ("placement" in $$new_props)
      $$invalidate(12, placement = $$new_props.placement);
    if ("shadow" in $$new_props)
      $$invalidate(13, shadow = $$new_props.shadow);
    if ("theme" in $$new_props)
      $$invalidate(5, theme = $$new_props.theme);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    ariaLabel,
    border,
    className,
    children,
    color,
    href,
    indicator,
    pill,
    positioned,
    placement,
    shadow,
    theme,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("ariaLabel" in $$props)
      $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
    if ("border" in $$props)
      $$invalidate(8, border = $$new_props.border);
    if ("className" in $$props)
      $$invalidate(9, className = $$new_props.className);
    if ("children" in $$props)
      $$invalidate(1, children = $$new_props.children);
    if ("color" in $$props)
      $$invalidate(10, color = $$new_props.color);
    if ("href" in $$props)
      $$invalidate(2, href = $$new_props.href);
    if ("indicator" in $$props)
      $$invalidate(3, indicator = $$new_props.indicator);
    if ("pill" in $$props)
      $$invalidate(11, pill = $$new_props.pill);
    if ("positioned" in $$props)
      $$invalidate(4, positioned = $$new_props.positioned);
    if ("placement" in $$props)
      $$invalidate(12, placement = $$new_props.placement);
    if ("shadow" in $$props)
      $$invalidate(13, shadow = $$new_props.shadow);
    if ("theme" in $$props)
      $$invalidate(5, theme = $$new_props.theme);
    if ("classes" in $$props)
      $$invalidate(6, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*color, pill, positioned, placement, indicator, border, shadow, className*/
    16152) {
      $:
        $$invalidate(6, classes = classnames(
          "badge",
          `text-bg-${color}`,
          pill ? "rounded-pill" : false,
          positioned ? "position-absolute translate-middle" : false,
          positioned ? placement : false,
          indicator ? "p-2" : false,
          border ? typeof border === "string" ? border : "border" : false,
          shadow ? typeof shadow === "string" ? shadow : "shadow" : false,
          className
        ));
    }
  };
  return [
    ariaLabel,
    children,
    href,
    indicator,
    positioned,
    theme,
    classes,
    $$restProps,
    border,
    className,
    color,
    pill,
    placement,
    shadow,
    $$scope,
    slots
  ];
}
var Badge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      ariaLabel: 0,
      border: 8,
      class: 9,
      children: 1,
      color: 10,
      href: 2,
      indicator: 3,
      pill: 11,
      positioned: 4,
      placement: 12,
      shadow: 13,
      theme: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Badge",
      options,
      id: create_fragment6.name
    });
  }
  get ariaLabel() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indicator() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indicator(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pill() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pill(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get positioned() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positioned(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placement() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placement(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Badge_default = Badge;

// node_modules/@sveltestrap/sveltestrap/dist/Breadcrumb/Breadcrumb.svelte
var file7 = "node_modules/@sveltestrap/sveltestrap/dist/Breadcrumb/Breadcrumb.svelte";
function create_else_block3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(47:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*children*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*children*/
      2)
        set_data_dev(
          t,
          /*children*/
          ctx2[1]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(45:4) {#if children}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let nav;
  let ol;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block4, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*children*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let nav_levels = [
    { style: (
      /*styles*/
      ctx[2]
    ) },
    /*$$restProps*/
    ctx[4],
    { class: (
      /*className*/
      ctx[0]
    ) }
  ];
  let nav_data = {};
  for (let i = 0; i < nav_levels.length; i += 1) {
    nav_data = assign(nav_data, nav_levels[i]);
  }
  const block = {
    c: function create() {
      nav = element("nav");
      ol = element("ol");
      if_block.c();
      attr_dev(
        ol,
        "class",
        /*listClasses*/
        ctx[3]
      );
      add_location(ol, file7, 43, 2, 1005);
      set_attributes(nav, nav_data);
      add_location(nav, file7, 42, 0, 947);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, nav, anchor);
      append_dev(nav, ol);
      if_blocks[current_block_type_index].m(ol, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(ol, null);
      }
      if (!current || dirty & /*listClasses*/
      8) {
        attr_dev(
          ol,
          "class",
          /*listClasses*/
          ctx2[3]
        );
      }
      set_attributes(nav, nav_data = get_spread_update(nav_levels, [
        (!current || dirty & /*styles*/
        4) && { style: (
          /*styles*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        (!current || dirty & /*className*/
        1) && { class: (
          /*className*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(nav);
      }
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let listClasses;
  let styles;
  const omit_props_names = ["class", "children", "divider", "listClassName", "style"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Breadcrumb", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { children = "" } = $$props;
  let { divider = "" } = $$props;
  let { listClassName = "" } = $$props;
  let { style = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(0, className = $$new_props.class);
    if ("children" in $$new_props)
      $$invalidate(1, children = $$new_props.children);
    if ("divider" in $$new_props)
      $$invalidate(5, divider = $$new_props.divider);
    if ("listClassName" in $$new_props)
      $$invalidate(6, listClassName = $$new_props.listClassName);
    if ("style" in $$new_props)
      $$invalidate(7, style = $$new_props.style);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    children,
    divider,
    listClassName,
    style,
    styles,
    listClasses
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(0, className = $$new_props.className);
    if ("children" in $$props)
      $$invalidate(1, children = $$new_props.children);
    if ("divider" in $$props)
      $$invalidate(5, divider = $$new_props.divider);
    if ("listClassName" in $$props)
      $$invalidate(6, listClassName = $$new_props.listClassName);
    if ("style" in $$props)
      $$invalidate(7, style = $$new_props.style);
    if ("styles" in $$props)
      $$invalidate(2, styles = $$new_props.styles);
    if ("listClasses" in $$props)
      $$invalidate(3, listClasses = $$new_props.listClasses);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*listClassName*/
    64) {
      $:
        $$invalidate(3, listClasses = classnames("breadcrumb", listClassName));
    }
    if ($$self.$$.dirty & /*divider, style*/
    160) {
      $:
        $$invalidate(2, styles = divider ? `--bs-breadcrumb-divider: '${divider}'; ${style || ""}` : style);
    }
  };
  return [
    className,
    children,
    styles,
    listClasses,
    $$restProps,
    divider,
    listClassName,
    style,
    $$scope,
    slots
  ];
}
var Breadcrumb = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, {
      class: 0,
      children: 1,
      divider: 5,
      listClassName: 6,
      style: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Breadcrumb",
      options,
      id: create_fragment7.name
    });
  }
  get class() {
    throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get divider() {
    throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set divider(value) {
    throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listClassName() {
    throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listClassName(value) {
    throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Breadcrumb_default = Breadcrumb;

// node_modules/@sveltestrap/sveltestrap/dist/BreadcrumbItem/BreadcrumbItem.svelte
var file8 = "node_modules/@sveltestrap/sveltestrap/dist/BreadcrumbItem/BreadcrumbItem.svelte";
function create_else_block4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(32:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*children*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*children*/
      2)
        set_data_dev(
          t,
          /*children*/
          ctx2[1]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(30:2) {#if children}",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let li;
  let current_block_type_index;
  let if_block;
  let li_aria_current_value;
  let current;
  const if_block_creators = [create_if_block5, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*children*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let li_levels = [
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) },
    {
      "aria-current": li_aria_current_value = /*active*/
      ctx[0] ? "page" : void 0
    }
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if_block.c();
      set_attributes(li, li_data);
      add_location(li, file8, 28, 0, 606);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      if_blocks[current_block_type_index].m(li, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(li, null);
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) },
        (!current || dirty & /*active*/
        1 && li_aria_current_value !== (li_aria_current_value = /*active*/
        ctx2[0] ? "page" : void 0)) && { "aria-current": li_aria_current_value }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "active", "children"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BreadcrumbItem", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  let { children = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(0, active = $$new_props.active);
    if ("children" in $$new_props)
      $$invalidate(1, children = $$new_props.children);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    active,
    children,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(0, active = $$new_props.active);
    if ("children" in $$props)
      $$invalidate(1, children = $$new_props.children);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, active*/
    17) {
      $:
        $$invalidate(2, classes = classnames(className, active ? "active" : false, "breadcrumb-item"));
    }
  };
  return [active, children, classes, $$restProps, className, $$scope, slots];
}
var BreadcrumbItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { class: 4, active: 0, children: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BreadcrumbItem",
      options,
      id: create_fragment8.name
    });
  }
  get class() {
    throw new Error("<BreadcrumbItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BreadcrumbItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<BreadcrumbItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<BreadcrumbItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<BreadcrumbItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<BreadcrumbItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BreadcrumbItem_default = BreadcrumbItem;

// node_modules/@sveltestrap/sveltestrap/dist/Button/Button.svelte
var file9 = "node_modules/@sveltestrap/sveltestrap/dist/Button/Button.svelte";
function create_else_block_12(ctx) {
  let button;
  let button_aria_label_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  let button_levels = [
    /*$$restProps*/
    ctx[8],
    { class: (
      /*classes*/
      ctx[6]
    ) },
    { disabled: (
      /*disabled*/
      ctx[2]
    ) },
    { value: (
      /*value*/
      ctx[4]
    ) },
    {
      "aria-label": button_aria_label_value = /*ariaLabel*/
      ctx[7] || /*defaultAriaLabel*/
      ctx[5]
    }
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block_1 = {
    c: function create() {
      button = element("button");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      set_attributes(button, button_data);
      add_location(button, file9, 122, 2, 2298);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      ctx[21](button);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler_1*/
          ctx[19],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*children, $$scope*/
        65538)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*$$restProps*/
        256 && /*$$restProps*/
        ctx2[8],
        (!current || dirty & /*classes*/
        64) && { class: (
          /*classes*/
          ctx2[6]
        ) },
        (!current || dirty & /*disabled*/
        4) && { disabled: (
          /*disabled*/
          ctx2[2]
        ) },
        (!current || dirty & /*value*/
        16) && { value: (
          /*value*/
          ctx2[4]
        ) },
        (!current || dirty & /*ariaLabel, defaultAriaLabel*/
        160 && button_aria_label_value !== (button_aria_label_value = /*ariaLabel*/
        ctx2[7] || /*defaultAriaLabel*/
        ctx2[5])) && { "aria-label": button_aria_label_value }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[21](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_else_block_12.name,
    type: "else",
    source: "(122:0) {:else}",
    ctx
  });
  return block_1;
}
function create_if_block6(ctx) {
  let a;
  let current_block_type_index;
  let if_block;
  let a_aria_label_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_13, create_else_block5];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*children*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let a_levels = [
    /*$$restProps*/
    ctx[8],
    { class: (
      /*classes*/
      ctx[6]
    ) },
    { href: (
      /*href*/
      ctx[3]
    ) },
    {
      "aria-label": a_aria_label_value = /*ariaLabel*/
      ctx[7] || /*defaultAriaLabel*/
      ctx[5]
    }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block_1 = {
    c: function create() {
      a = element("a");
      if_block.c();
      set_attributes(a, a_data);
      toggle_class(
        a,
        "disabled",
        /*disabled*/
        ctx[2]
      );
      add_location(a, file9, 106, 2, 2048);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if_blocks[current_block_type_index].m(a, null);
      ctx[20](a);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*click_handler*/
          ctx[18],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(a, null);
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*$$restProps*/
        256 && /*$$restProps*/
        ctx2[8],
        (!current || dirty & /*classes*/
        64) && { class: (
          /*classes*/
          ctx2[6]
        ) },
        (!current || dirty & /*href*/
        8) && { href: (
          /*href*/
          ctx2[3]
        ) },
        (!current || dirty & /*ariaLabel, defaultAriaLabel*/
        160 && a_aria_label_value !== (a_aria_label_value = /*ariaLabel*/
        ctx2[7] || /*defaultAriaLabel*/
        ctx2[5])) && { "aria-label": a_aria_label_value }
      ]));
      toggle_class(
        a,
        "disabled",
        /*disabled*/
        ctx2[2]
      );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if_blocks[current_block_type_index].d();
      ctx[20](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block6.name,
    type: "if",
    source: "(106:0) {#if href}",
    ctx
  });
  return block_1;
}
function create_else_block_22(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  const block_1 = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_else_block_22.name,
    type: "else",
    source: "(135:6) {:else}",
    ctx
  });
  return block_1;
}
function create_if_block_23(ctx) {
  let t;
  const block_1 = {
    c: function create() {
      t = text(
        /*children*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*children*/
      2)
        set_data_dev(
          t,
          /*children*/
          ctx2[1]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_23.name,
    type: "if",
    source: "(133:6) {#if children}",
    ctx
  });
  return block_1;
}
function fallback_block(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_23, create_else_block_22];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*children*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block_1 = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: fallback_block.name,
    type: "fallback",
    source: "(132:10)        ",
    ctx
  });
  return block_1;
}
function create_else_block5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  const block_1 = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_else_block5.name,
    type: "else",
    source: "(118:4) {:else}",
    ctx
  });
  return block_1;
}
function create_if_block_13(ctx) {
  let t;
  const block_1 = {
    c: function create() {
      t = text(
        /*children*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*children*/
      2)
        set_data_dev(
          t,
          /*children*/
          ctx2[1]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_13.name,
    type: "if",
    source: "(116:4) {#if children}",
    ctx
  });
  return block_1;
}
function create_fragment9(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block6, create_else_block_12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*href*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block_1 = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block_1;
}
function instance9($$self, $$props, $$invalidate) {
  let ariaLabel;
  let classes;
  let defaultAriaLabel;
  const omit_props_names = [
    "class",
    "active",
    "block",
    "children",
    "close",
    "color",
    "disabled",
    "href",
    "inner",
    "outline",
    "size",
    "value"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Button", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  let { block = false } = $$props;
  let { children = "" } = $$props;
  let { close = false } = $$props;
  let { color = "secondary" } = $$props;
  let { disabled = false } = $$props;
  let { href = "" } = $$props;
  let { inner = void 0 } = $$props;
  let { outline = false } = $$props;
  let { size = "" } = $$props;
  let { value = "" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(0, inner);
    });
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(0, inner);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(9, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(10, active = $$new_props.active);
    if ("block" in $$new_props)
      $$invalidate(11, block = $$new_props.block);
    if ("children" in $$new_props)
      $$invalidate(1, children = $$new_props.children);
    if ("close" in $$new_props)
      $$invalidate(12, close = $$new_props.close);
    if ("color" in $$new_props)
      $$invalidate(13, color = $$new_props.color);
    if ("disabled" in $$new_props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("href" in $$new_props)
      $$invalidate(3, href = $$new_props.href);
    if ("inner" in $$new_props)
      $$invalidate(0, inner = $$new_props.inner);
    if ("outline" in $$new_props)
      $$invalidate(14, outline = $$new_props.outline);
    if ("size" in $$new_props)
      $$invalidate(15, size = $$new_props.size);
    if ("value" in $$new_props)
      $$invalidate(4, value = $$new_props.value);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    active,
    block,
    children,
    close,
    color,
    disabled,
    href,
    inner,
    outline,
    size,
    value,
    defaultAriaLabel,
    classes,
    ariaLabel
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(9, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(10, active = $$new_props.active);
    if ("block" in $$props)
      $$invalidate(11, block = $$new_props.block);
    if ("children" in $$props)
      $$invalidate(1, children = $$new_props.children);
    if ("close" in $$props)
      $$invalidate(12, close = $$new_props.close);
    if ("color" in $$props)
      $$invalidate(13, color = $$new_props.color);
    if ("disabled" in $$props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("href" in $$props)
      $$invalidate(3, href = $$new_props.href);
    if ("inner" in $$props)
      $$invalidate(0, inner = $$new_props.inner);
    if ("outline" in $$props)
      $$invalidate(14, outline = $$new_props.outline);
    if ("size" in $$props)
      $$invalidate(15, size = $$new_props.size);
    if ("value" in $$props)
      $$invalidate(4, value = $$new_props.value);
    if ("defaultAriaLabel" in $$props)
      $$invalidate(5, defaultAriaLabel = $$new_props.defaultAriaLabel);
    if ("classes" in $$props)
      $$invalidate(6, classes = $$new_props.classes);
    if ("ariaLabel" in $$props)
      $$invalidate(7, ariaLabel = $$new_props.ariaLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(7, ariaLabel = $$props["aria-label"]);
    if ($$self.$$.dirty & /*className, close, outline, color, size, block, active*/
    65024) {
      $:
        $$invalidate(6, classes = classnames(className, close ? "btn-close" : "btn", close || `btn${outline ? "-outline" : ""}-${color}`, size ? `btn-${size}` : false, block ? "d-block w-100" : false, { active }));
    }
    if ($$self.$$.dirty & /*close*/
    4096) {
      $:
        $$invalidate(5, defaultAriaLabel = close ? "Close" : null);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    inner,
    children,
    disabled,
    href,
    value,
    defaultAriaLabel,
    classes,
    ariaLabel,
    $$restProps,
    className,
    active,
    block,
    close,
    color,
    outline,
    size,
    $$scope,
    slots,
    click_handler,
    click_handler_1,
    a_binding,
    button_binding
  ];
}
var Button = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      class: 9,
      active: 10,
      block: 11,
      children: 1,
      close: 12,
      color: 13,
      disabled: 2,
      href: 3,
      inner: 0,
      outline: 14,
      size: 15,
      value: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Button",
      options,
      id: create_fragment9.name
    });
  }
  get class() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get block() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set block(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get close() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set close(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inner() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inner(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Button_default = Button;

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element2) {
  return element2 ? (element2.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element2 = state.elements[name];
    if (!isHTMLElement(element2) || !getNodeName(element2)) {
      return;
    }
    Object.assign(element2.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element2.removeAttribute(name2);
      } else {
        element2.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element2 = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element2) || !getNodeName(element2)) {
        return;
      }
      Object.assign(element2.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element2.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element2, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element2.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element2)) {
    scaleX = element2.offsetWidth > 0 ? round(clientRect.width) / element2.offsetWidth || 1 : 1;
    scaleY = element2.offsetHeight > 0 ? round(clientRect.height) / element2.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element2) ? getWindow(element2) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element2) {
  var clientRect = getBoundingClientRect(element2);
  var width = element2.offsetWidth;
  var height = element2.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element2.offsetLeft,
    y: element2.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle(element2) {
  return getWindow(element2).getComputedStyle(element2);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element2) {
  return ["table", "td", "th"].indexOf(getNodeName(element2)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element2) {
  return ((isElement(element2) ? element2.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element2.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element2) {
  if (getNodeName(element2) === "html") {
    return element2;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element2.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element2.parentNode || // DOM Element detected
    (isShadowRoot(element2) ? element2.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element2)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element2) {
  if (!isHTMLElement(element2) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element2).position === "fixed") {
    return null;
  }
  return element2.offsetParent;
}
function getContainingBlock(element2) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element2)) {
    var elementCss = getComputedStyle(element2);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element2);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element2) {
  var window2 = getWindow(element2);
  var offsetParent = getTrueOffsetParent(element2);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance93 = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance93.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance93.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance93.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance93.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element2, strategy) {
  var win = getWindow(element2);
  var html = getDocumentElement(element2);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element2),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element2) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element2);
  var winScroll = getWindowScroll(element2);
  var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element2);
  var y = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element2) {
  var _getComputedStyle = getComputedStyle(element2), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element2, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element2);
  var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element2, strategy) {
  var rect = getBoundingClientRect(element2, false, strategy === "fixed");
  rect.top = rect.top + element2.clientTop;
  rect.left = rect.left + element2.clientLeft;
  rect.bottom = rect.top + element2.clientHeight;
  rect.right = rect.left + element2.clientWidth;
  rect.width = element2.clientWidth;
  rect.height = element2.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element2, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element2, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));
}
function getClippingParents(element2) {
  var clippingParents2 = listScrollParents(getParentNode(element2));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element2).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element2, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element2) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element2, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element2, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element2 = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element2.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element2.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element2 = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element2) {
  return {
    scrollLeft: element2.scrollLeft,
    scrollTop: element2.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element2) {
  var rect = element2.getBoundingClientRect();
  var scaleX = round(rect.width) / element2.offsetWidth || 1;
  var scaleY = round(rect.height) / element2.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element2) {
    return !(element2 && typeof element2.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper4(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance93 = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance93.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance: instance93
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance93.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance93;
    }
    instance93.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance: instance93,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance93;
  };
}
var createPopper = popperGenerator();

// node_modules/@popperjs/core/lib/popper-lite.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
var createPopper2 = popperGenerator({
  defaultModifiers
});

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper3 = popperGenerator({
  defaultModifiers: defaultModifiers2
});

// node_modules/@sveltestrap/sveltestrap/dist/popper.js
function createPopperActions(initOptions) {
  let contentNode;
  let options = initOptions;
  let popperInstance = null;
  let referenceNode;
  const initPopper = () => {
    if (referenceNode && contentNode) {
      popperInstance = createPopper3(referenceNode, contentNode, options);
    }
  };
  const deinitPopper = () => {
    if (popperInstance) {
      popperInstance.destroy();
      popperInstance = null;
    }
  };
  const referenceAction = (node) => {
    referenceNode = node;
    initPopper();
    return {
      destroy() {
        deinitPopper();
      }
    };
  };
  const contentAction = (node, contentOptions) => {
    contentNode = node;
    options = Object.assign(Object.assign({}, initOptions), contentOptions);
    initPopper();
    return {
      update(newContentOptions) {
        options = Object.assign(Object.assign({}, initOptions), newContentOptions);
        if (popperInstance && options) {
          popperInstance.setOptions(options);
        }
      },
      destroy() {
        deinitPopper();
      }
    };
  };
  return [referenceAction, contentAction, () => popperInstance];
}

// node_modules/@sveltestrap/sveltestrap/dist/Dropdown/DropdownContext.js
var createContext = () => writable({});

// node_modules/@sveltestrap/sveltestrap/dist/Dropdown/Dropdown.svelte
var { Error: Error_1 } = globals;
var file10 = "node_modules/@sveltestrap/sveltestrap/dist/Dropdown/Dropdown.svelte";
function create_else_block6(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[4],
    { class: (
      /*classes*/
      ctx[3]
    ) },
    { "data-bs-theme": (
      /*theme*/
      ctx[1]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file10, 190, 2, 4835);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[22](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) },
        (!current || dirty & /*theme*/
        2) && { "data-bs-theme": (
          /*theme*/
          ctx2[1]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[22](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block6.name,
    type: "else",
    source: "(190:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block7(ctx) {
  let li;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  let li_levels = [
    /*$$restProps*/
    ctx[4],
    { class: (
      /*classes*/
      ctx[3]
    ) },
    { "data-bs-theme": (
      /*theme*/
      ctx[1]
    ) }
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if (default_slot)
        default_slot.c();
      set_attributes(li, li_data);
      add_location(li, file10, 186, 2, 4722);
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      ctx[21](li);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) },
        (!current || dirty & /*theme*/
        2) && { "data-bs-theme": (
          /*theme*/
          ctx2[1]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[21](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(186:0) {#if nav}",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block7, create_else_block6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*nav*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let subItemIsActive;
  let classes;
  let handleToggle;
  const omit_props_names = [
    "class",
    "active",
    "autoClose",
    "direction",
    "dropup",
    "group",
    "inNavbar",
    "isOpen",
    "nav",
    "setActiveFromChild",
    "size",
    "theme",
    "toggle"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Dropdown", slots, ["default"]);
  const noop2 = () => void 0;
  let context = createContext();
  setContext("dropdownContext", context);
  const navbarContext = getContext("navbar");
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  let { autoClose = true } = $$props;
  let { direction = "down" } = $$props;
  let { dropup = false } = $$props;
  let { group = false } = $$props;
  let { inNavbar = navbarContext ? navbarContext.inNavbar : false } = $$props;
  let { isOpen = false } = $$props;
  let { nav = false } = $$props;
  let { setActiveFromChild = false } = $$props;
  let { size = "" } = $$props;
  let { theme = null } = $$props;
  let { toggle = void 0 } = $$props;
  const [popperRef, popperContent] = createPopperActions();
  const validDirections = ["up", "down", "left", "right", "start", "end"];
  if (validDirections.indexOf(direction) === -1) {
    throw new Error(`Invalid direction sent: '${direction}' is not one of 'up', 'down', 'left', 'right', 'start', 'end'`);
  }
  let component;
  let dropdownDirection;
  function handleDocumentClick(e) {
    if (e && (e.which === 3 || e.type === "keyup" && e.which !== 9))
      return;
    if (component.contains(e.target) && component !== e.target && (e.type !== "keyup" || e.which === 9)) {
      return;
    }
    if (autoClose === true || autoClose === "outside") {
      handleToggle(e);
    }
  }
  onDestroy(() => {
    if (typeof document !== "undefined") {
      ["click", "touchstart", "keyup"].forEach((event) => document.removeEventListener(event, handleDocumentClick, true));
    }
  });
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      component = $$value;
      $$invalidate(2, component);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      component = $$value;
      $$invalidate(2, component);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(6, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(7, active = $$new_props.active);
    if ("autoClose" in $$new_props)
      $$invalidate(8, autoClose = $$new_props.autoClose);
    if ("direction" in $$new_props)
      $$invalidate(9, direction = $$new_props.direction);
    if ("dropup" in $$new_props)
      $$invalidate(10, dropup = $$new_props.dropup);
    if ("group" in $$new_props)
      $$invalidate(11, group = $$new_props.group);
    if ("inNavbar" in $$new_props)
      $$invalidate(12, inNavbar = $$new_props.inNavbar);
    if ("isOpen" in $$new_props)
      $$invalidate(5, isOpen = $$new_props.isOpen);
    if ("nav" in $$new_props)
      $$invalidate(0, nav = $$new_props.nav);
    if ("setActiveFromChild" in $$new_props)
      $$invalidate(13, setActiveFromChild = $$new_props.setActiveFromChild);
    if ("size" in $$new_props)
      $$invalidate(14, size = $$new_props.size);
    if ("theme" in $$new_props)
      $$invalidate(1, theme = $$new_props.theme);
    if ("toggle" in $$new_props)
      $$invalidate(15, toggle = $$new_props.toggle);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    setContext,
    onDestroy,
    createPopperActions,
    classnames,
    createContext,
    noop: noop2,
    context,
    navbarContext,
    className,
    active,
    autoClose,
    direction,
    dropup,
    group,
    inNavbar,
    isOpen,
    nav,
    setActiveFromChild,
    size,
    theme,
    toggle,
    popperRef,
    popperContent,
    validDirections,
    component,
    dropdownDirection,
    handleDocumentClick,
    handleToggle,
    subItemIsActive,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("context" in $$props)
      $$invalidate(24, context = $$new_props.context);
    if ("className" in $$props)
      $$invalidate(6, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(7, active = $$new_props.active);
    if ("autoClose" in $$props)
      $$invalidate(8, autoClose = $$new_props.autoClose);
    if ("direction" in $$props)
      $$invalidate(9, direction = $$new_props.direction);
    if ("dropup" in $$props)
      $$invalidate(10, dropup = $$new_props.dropup);
    if ("group" in $$props)
      $$invalidate(11, group = $$new_props.group);
    if ("inNavbar" in $$props)
      $$invalidate(12, inNavbar = $$new_props.inNavbar);
    if ("isOpen" in $$props)
      $$invalidate(5, isOpen = $$new_props.isOpen);
    if ("nav" in $$props)
      $$invalidate(0, nav = $$new_props.nav);
    if ("setActiveFromChild" in $$props)
      $$invalidate(13, setActiveFromChild = $$new_props.setActiveFromChild);
    if ("size" in $$props)
      $$invalidate(14, size = $$new_props.size);
    if ("theme" in $$props)
      $$invalidate(1, theme = $$new_props.theme);
    if ("toggle" in $$props)
      $$invalidate(15, toggle = $$new_props.toggle);
    if ("component" in $$props)
      $$invalidate(2, component = $$new_props.component);
    if ("dropdownDirection" in $$props)
      $$invalidate(16, dropdownDirection = $$new_props.dropdownDirection);
    if ("handleToggle" in $$props)
      $$invalidate(17, handleToggle = $$new_props.handleToggle);
    if ("subItemIsActive" in $$props)
      $$invalidate(18, subItemIsActive = $$new_props.subItemIsActive);
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*setActiveFromChild, component*/
    8196) {
      $:
        $$invalidate(18, subItemIsActive = !!(setActiveFromChild && component && typeof component.querySelector === "function" && component.querySelector(".active")));
    }
    if ($$self.$$.dirty & /*direction*/
    512) {
      $: {
        if (direction === "left")
          $$invalidate(16, dropdownDirection = "start");
        else if (direction === "right")
          $$invalidate(16, dropdownDirection = "end");
        else
          $$invalidate(16, dropdownDirection = direction);
      }
    }
    if ($$self.$$.dirty & /*toggle, isOpen*/
    32800) {
      $:
        $$invalidate(17, handleToggle = toggle || (() => $$invalidate(5, isOpen = !isOpen)));
    }
    if ($$self.$$.dirty & /*className, direction, dropdownDirection, nav, active, setActiveFromChild, subItemIsActive, group, size, isOpen*/
    355041) {
      $:
        $$invalidate(3, classes = classnames(className, direction !== "down" && `drop${dropdownDirection}`, nav && active ? "active" : false, setActiveFromChild && subItemIsActive ? "active" : false, {
          "btn-group": group,
          [`btn-group-${size}`]: !!size,
          dropdown: !group,
          show: isOpen,
          "nav-item": nav
        }));
    }
    if ($$self.$$.dirty & /*isOpen*/
    32) {
      $: {
        if (typeof document !== "undefined") {
          if (isOpen) {
            ["click", "touchstart", "keyup"].forEach((event) => document.addEventListener(event, handleDocumentClick, true));
          } else {
            ["click", "touchstart", "keyup"].forEach((event) => document.removeEventListener(event, handleDocumentClick, true));
          }
        }
      }
    }
    if ($$self.$$.dirty & /*handleToggle, isOpen, autoClose, direction, dropup, nav, inNavbar*/
    136993) {
      $: {
        context.update(() => {
          return {
            toggle: handleToggle,
            isOpen,
            autoClose,
            direction: direction === "down" && dropup ? "up" : direction,
            inNavbar: nav || inNavbar,
            popperRef: nav ? noop2 : popperRef,
            popperContent: nav ? noop2 : popperContent
          };
        });
      }
    }
  };
  return [
    nav,
    theme,
    component,
    classes,
    $$restProps,
    isOpen,
    className,
    active,
    autoClose,
    direction,
    dropup,
    group,
    inNavbar,
    setActiveFromChild,
    size,
    toggle,
    dropdownDirection,
    handleToggle,
    subItemIsActive,
    $$scope,
    slots,
    li_binding,
    div_binding
  ];
}
var Dropdown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, {
      class: 6,
      active: 7,
      autoClose: 8,
      direction: 9,
      dropup: 10,
      group: 11,
      inNavbar: 12,
      isOpen: 5,
      nav: 0,
      setActiveFromChild: 13,
      size: 14,
      theme: 1,
      toggle: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dropdown",
      options,
      id: create_fragment10.name
    });
  }
  get class() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoClose() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoClose(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dropup() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dropup(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get group() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inNavbar() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inNavbar(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nav() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nav(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setActiveFromChild() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set setActiveFromChild(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Dropdown_default = Dropdown;

// node_modules/@sveltestrap/sveltestrap/dist/ButtonDropdown/ButtonDropdown.svelte
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(5:0) <Dropdown {...$$restProps} group on:click>",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let dropdown;
  let current;
  const dropdown_spread_levels = [
    /*$$restProps*/
    ctx[0],
    { group: true }
  ];
  let dropdown_props = {
    $$slots: { default: [create_default_slot2] },
    $$scope: { ctx }
  };
  for (let i = 0; i < dropdown_spread_levels.length; i += 1) {
    dropdown_props = assign(dropdown_props, dropdown_spread_levels[i]);
  }
  dropdown = new Dropdown_default({ props: dropdown_props, $$inline: true });
  dropdown.$on(
    "click",
    /*click_handler*/
    ctx[2]
  );
  const block = {
    c: function create() {
      create_component(dropdown.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(dropdown, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const dropdown_changes = dirty & /*$$restProps*/
      1 ? get_spread_update(dropdown_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[0]
      ), dropdown_spread_levels[1]]) : {};
      if (dirty & /*$$scope*/
      8) {
        dropdown_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dropdown.$set(dropdown_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dropdown.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dropdown.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(dropdown, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ButtonDropdown", slots, ["default"]);
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ Dropdown: Dropdown_default });
  return [$$restProps, slots, click_handler, $$scope];
}
var ButtonDropdown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ButtonDropdown",
      options,
      id: create_fragment11.name
    });
  }
};
var ButtonDropdown_default = ButtonDropdown;

// node_modules/@sveltestrap/sveltestrap/dist/ButtonGroup/ButtonGroup.svelte
var file11 = "node_modules/@sveltestrap/sveltestrap/dist/ButtonGroup/ButtonGroup.svelte";
function create_fragment12(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file11, 28, 0, 591);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "size", "vertical"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ButtonGroup", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { size = "" } = $$props;
  let { vertical = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("size" in $$new_props)
      $$invalidate(3, size = $$new_props.size);
    if ("vertical" in $$new_props)
      $$invalidate(4, vertical = $$new_props.vertical);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    size,
    vertical,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("size" in $$props)
      $$invalidate(3, size = $$new_props.size);
    if ("vertical" in $$props)
      $$invalidate(4, vertical = $$new_props.vertical);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, size, vertical*/
    28) {
      $:
        $$invalidate(0, classes = classnames(className, size ? `btn-group-${size}` : false, vertical ? "btn-group-vertical" : "btn-group"));
    }
  };
  return [classes, $$restProps, className, size, vertical, $$scope, slots];
}
var ButtonGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, { class: 2, size: 3, vertical: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ButtonGroup",
      options,
      id: create_fragment12.name
    });
  }
  get class() {
    throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vertical() {
    throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vertical(value) {
    throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ButtonGroup_default = ButtonGroup;

// node_modules/@sveltestrap/sveltestrap/dist/ButtonToolbar/ButtonToolbar.svelte
var file12 = "node_modules/@sveltestrap/sveltestrap/dist/ButtonToolbar/ButtonToolbar.svelte";
function create_fragment13(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { role: "toolbar" },
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file12, 14, 0, 271);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        { role: "toolbar" },
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ButtonToolbar", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "btn-toolbar"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var ButtonToolbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ButtonToolbar",
      options,
      id: create_fragment13.name
    });
  }
  get class() {
    throw new Error("<ButtonToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ButtonToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ButtonToolbar_default = ButtonToolbar;

// node_modules/@sveltestrap/sveltestrap/dist/Card/Card.svelte
var file13 = "node_modules/@sveltestrap/sveltestrap/dist/Card/Card.svelte";
function create_fragment14(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[2],
    { "data-bs-theme": (
      /*theme*/
      ctx[0]
    ) },
    { class: (
      /*classes*/
      ctx[1]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file13, 55, 0, 1108);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*click_handler*/
          ctx[10],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*theme*/
        1) && { "data-bs-theme": (
          /*theme*/
          ctx2[0]
        ) },
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "body", "color", "inverse", "outline", "theme"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Card", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { body = false } = $$props;
  let { color = "" } = $$props;
  let { inverse = false } = $$props;
  let { outline = false } = $$props;
  let { theme = void 0 } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("body" in $$new_props)
      $$invalidate(4, body = $$new_props.body);
    if ("color" in $$new_props)
      $$invalidate(5, color = $$new_props.color);
    if ("inverse" in $$new_props)
      $$invalidate(6, inverse = $$new_props.inverse);
    if ("outline" in $$new_props)
      $$invalidate(7, outline = $$new_props.outline);
    if ("theme" in $$new_props)
      $$invalidate(0, theme = $$new_props.theme);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    body,
    color,
    inverse,
    outline,
    theme,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("body" in $$props)
      $$invalidate(4, body = $$new_props.body);
    if ("color" in $$props)
      $$invalidate(5, color = $$new_props.color);
    if ("inverse" in $$props)
      $$invalidate(6, inverse = $$new_props.inverse);
    if ("outline" in $$props)
      $$invalidate(7, outline = $$new_props.outline);
    if ("theme" in $$props)
      $$invalidate(0, theme = $$new_props.theme);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, inverse, body, color, outline*/
    248) {
      $:
        $$invalidate(1, classes = classnames(className, "card", inverse ? "text-white" : false, body ? "card-body" : false, color ? `${outline ? "border" : "bg"}-${color}` : false));
    }
  };
  return [
    theme,
    classes,
    $$restProps,
    className,
    body,
    color,
    inverse,
    outline,
    $$scope,
    slots,
    click_handler
  ];
}
var Card = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, {
      class: 3,
      body: 4,
      color: 5,
      inverse: 6,
      outline: 7,
      theme: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Card",
      options,
      id: create_fragment14.name
    });
  }
  get class() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get body() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set body(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inverse() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inverse(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Card_default = Card;

// node_modules/@sveltestrap/sveltestrap/dist/CardBody/CardBody.svelte
var file14 = "node_modules/@sveltestrap/sveltestrap/dist/CardBody/CardBody.svelte";
function create_fragment15(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file14, 14, 0, 269);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardBody", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-body"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardBody = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardBody",
      options,
      id: create_fragment15.name
    });
  }
  get class() {
    throw new Error("<CardBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardBody_default = CardBody;

// node_modules/@sveltestrap/sveltestrap/dist/CardColumns/CardColumns.svelte
var file15 = "node_modules/@sveltestrap/sveltestrap/dist/CardColumns/CardColumns.svelte";
function create_fragment16(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file15, 14, 0, 272);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardColumns", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-columns"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardColumns = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardColumns",
      options,
      id: create_fragment16.name
    });
  }
  get class() {
    throw new Error("<CardColumns>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardColumns>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardColumns_default = CardColumns;

// node_modules/@sveltestrap/sveltestrap/dist/CardDeck/CardDeck.svelte
var file16 = "node_modules/@sveltestrap/sveltestrap/dist/CardDeck/CardDeck.svelte";
function create_fragment17(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file16, 14, 0, 269);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardDeck", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-deck"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardDeck = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardDeck",
      options,
      id: create_fragment17.name
    });
  }
  get class() {
    throw new Error("<CardDeck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardDeck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardDeck_default = CardDeck;

// node_modules/@sveltestrap/sveltestrap/dist/CardFooter/CardFooter.svelte
var file17 = "node_modules/@sveltestrap/sveltestrap/dist/CardFooter/CardFooter.svelte";
function create_fragment18(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file17, 14, 0, 271);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardFooter", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-footer"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardFooter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardFooter",
      options,
      id: create_fragment18.name
    });
  }
  get class() {
    throw new Error("<CardFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardFooter_default = CardFooter;

// node_modules/@sveltestrap/sveltestrap/dist/CardGroup/CardGroup.svelte
var file18 = "node_modules/@sveltestrap/sveltestrap/dist/CardGroup/CardGroup.svelte";
function create_fragment19(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file18, 14, 0, 270);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardGroup", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-group"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardGroup",
      options,
      id: create_fragment19.name
    });
  }
  get class() {
    throw new Error("<CardGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardGroup_default = CardGroup;

// node_modules/@sveltestrap/sveltestrap/dist/CardHeader/CardHeader.svelte
var file19 = "node_modules/@sveltestrap/sveltestrap/dist/CardHeader/CardHeader.svelte";
function create_else_block7(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[2],
    { class: (
      /*classes*/
      ctx[1]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file19, 28, 2, 623);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*click_handler_1*/
          ctx[7],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block7.name,
    type: "else",
    source: "(27:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block8(ctx) {
  let h3;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let h3_levels = [
    /*$$restProps*/
    ctx[2],
    { class: (
      /*classes*/
      ctx[1]
    ) }
  ];
  let h3_data = {};
  for (let i = 0; i < h3_levels.length; i += 1) {
    h3_data = assign(h3_data, h3_levels[i]);
  }
  const block = {
    c: function create() {
      h3 = element("h3");
      if (default_slot)
        default_slot.c();
      set_attributes(h3, h3_data);
      add_location(h3, file19, 23, 2, 484);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h3, anchor);
      if (default_slot) {
        default_slot.m(h3, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          h3,
          "click",
          /*click_handler*/
          ctx[6],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h3, h3_data = get_spread_update(h3_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h3);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(22:0) {#if tag === 'h3'}",
    ctx
  });
  return block;
}
function create_fragment20(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block8, create_else_block7];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*tag*/
      ctx2[0] === "h3"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "tag"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardHeader", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { tag = "div" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("tag" in $$new_props)
      $$invalidate(0, tag = $$new_props.tag);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, tag, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("tag" in $$props)
      $$invalidate(0, tag = $$new_props.tag);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    8) {
      $:
        $$invalidate(1, classes = classnames(className, "card-header"));
    }
  };
  return [
    tag,
    classes,
    $$restProps,
    className,
    $$scope,
    slots,
    click_handler,
    click_handler_1
  ];
}
var CardHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, { class: 3, tag: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardHeader",
      options,
      id: create_fragment20.name
    });
  }
  get class() {
    throw new Error("<CardHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<CardHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<CardHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardHeader_default = CardHeader;

// node_modules/@sveltestrap/sveltestrap/dist/CardImg/CardImg.svelte
var file20 = "node_modules/@sveltestrap/sveltestrap/dist/CardImg/CardImg.svelte";
function create_fragment21(ctx) {
  let img;
  let img_src_value;
  let img_levels = [
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) },
    { src: img_src_value = /*src*/
    ctx[0] },
    { alt: (
      /*alt*/
      ctx[1]
    ) }
  ];
  let img_data = {};
  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = assign(img_data, img_levels[i]);
  }
  const block = {
    c: function create() {
      img = element("img");
      set_attributes(img, img_data);
      add_location(img, file20, 56, 0, 911);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(img, img_data = get_spread_update(img_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        dirty & /*classes*/
        4 && { class: (
          /*classes*/
          ctx2[2]
        ) },
        dirty & /*src*/
        1 && !src_url_equal(img.src, img_src_value = /*src*/
        ctx2[0]) && { src: img_src_value },
        dirty & /*alt*/
        2 && { alt: (
          /*alt*/
          ctx2[1]
        ) }
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(img);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "top", "bottom", "src", "alt"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardImg", slots, []);
  let { class: className = "" } = $$props;
  let { top: top2 = false } = $$props;
  let { bottom: bottom2 = false } = $$props;
  let { src } = $$props;
  let { alt = "" } = $$props;
  let classes = "";
  $$self.$$.on_mount.push(function() {
    if (src === void 0 && !("src" in $$props || $$self.$$.bound[$$self.$$.props["src"]])) {
      console.warn("<CardImg> was created without expected prop 'src'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("top" in $$new_props)
      $$invalidate(5, top2 = $$new_props.top);
    if ("bottom" in $$new_props)
      $$invalidate(6, bottom2 = $$new_props.bottom);
    if ("src" in $$new_props)
      $$invalidate(0, src = $$new_props.src);
    if ("alt" in $$new_props)
      $$invalidate(1, alt = $$new_props.alt);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    top: top2,
    bottom: bottom2,
    src,
    alt,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("top" in $$props)
      $$invalidate(5, top2 = $$new_props.top);
    if ("bottom" in $$props)
      $$invalidate(6, bottom2 = $$new_props.bottom);
    if ("src" in $$props)
      $$invalidate(0, src = $$new_props.src);
    if ("alt" in $$props)
      $$invalidate(1, alt = $$new_props.alt);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*top, bottom, className*/
    112) {
      $: {
        let cardImgClassName = "card-img";
        if (top2) {
          cardImgClassName = "card-img-top";
        }
        if (bottom2) {
          cardImgClassName = "card-img-bottom";
        }
        $$invalidate(2, classes = classnames(className, cardImgClassName));
      }
    }
  };
  return [src, alt, classes, $$restProps, className, top2, bottom2];
}
var CardImg = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, {
      class: 4,
      top: 5,
      bottom: 6,
      src: 0,
      alt: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardImg",
      options,
      id: create_fragment21.name
    });
  }
  get class() {
    throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get top() {
    throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set top(value) {
    throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bottom() {
    throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bottom(value) {
    throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get src() {
    throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardImg_default = CardImg;

// node_modules/@sveltestrap/sveltestrap/dist/CardImgOverlay/CardImgOverlay.svelte
var file21 = "node_modules/@sveltestrap/sveltestrap/dist/CardImgOverlay/CardImgOverlay.svelte";
function create_fragment22(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file21, 14, 0, 276);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardImgOverlay", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-img-overlay"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardImgOverlay = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardImgOverlay",
      options,
      id: create_fragment22.name
    });
  }
  get class() {
    throw new Error("<CardImgOverlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardImgOverlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardImgOverlay_default = CardImgOverlay;

// node_modules/@sveltestrap/sveltestrap/dist/CardLink/CardLink.svelte
var file22 = "node_modules/@sveltestrap/sveltestrap/dist/CardLink/CardLink.svelte";
function create_fragment23(ctx) {
  let a;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let a_levels = [
    /*$$restProps*/
    ctx[2],
    { class: (
      /*classes*/
      ctx[1]
    ) },
    { href: (
      /*href*/
      ctx[0]
    ) }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
      add_location(a, file22, 21, 0, 379);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) },
        (!current || dirty & /*href*/
        1) && { href: (
          /*href*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "href"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardLink", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { href = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("href" in $$new_props)
      $$invalidate(0, href = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, href, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("href" in $$props)
      $$invalidate(0, href = $$new_props.href);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    8) {
      $:
        $$invalidate(1, classes = classnames(className, "card-link"));
    }
  };
  return [href, classes, $$restProps, className, $$scope, slots];
}
var CardLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, { class: 3, href: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardLink",
      options,
      id: create_fragment23.name
    });
  }
  get class() {
    throw new Error("<CardLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<CardLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<CardLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardLink_default = CardLink;

// node_modules/@sveltestrap/sveltestrap/dist/CardSubtitle/CardSubtitle.svelte
var file23 = "node_modules/@sveltestrap/sveltestrap/dist/CardSubtitle/CardSubtitle.svelte";
function create_fragment24(ctx) {
  let h6;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let h6_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let h6_data = {};
  for (let i = 0; i < h6_levels.length; i += 1) {
    h6_data = assign(h6_data, h6_levels[i]);
  }
  const block = {
    c: function create() {
      h6 = element("h6");
      if (default_slot)
        default_slot.c();
      set_attributes(h6, h6_data);
      add_location(h6, file23, 14, 0, 273);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h6, anchor);
      if (default_slot) {
        default_slot.m(h6, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h6, h6_data = get_spread_update(h6_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h6);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance24($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardSubtitle", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-subtitle"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardSubtitle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardSubtitle",
      options,
      id: create_fragment24.name
    });
  }
  get class() {
    throw new Error("<CardSubtitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardSubtitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardSubtitle_default = CardSubtitle;

// node_modules/@sveltestrap/sveltestrap/dist/CardText/CardText.svelte
var file24 = "node_modules/@sveltestrap/sveltestrap/dist/CardText/CardText.svelte";
function create_fragment25(ctx) {
  let p;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let p_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let p_data = {};
  for (let i = 0; i < p_levels.length; i += 1) {
    p_data = assign(p_data, p_levels[i]);
  }
  const block = {
    c: function create() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      set_attributes(p, p_data);
      add_location(p, file24, 14, 0, 269);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance25($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardText", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-text"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardText = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance25, create_fragment25, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardText",
      options,
      id: create_fragment25.name
    });
  }
  get class() {
    throw new Error("<CardText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardText_default = CardText;

// node_modules/@sveltestrap/sveltestrap/dist/CardTitle/CardTitle.svelte
var file25 = "node_modules/@sveltestrap/sveltestrap/dist/CardTitle/CardTitle.svelte";
function create_fragment26(ctx) {
  let h5;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let h5_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let h5_data = {};
  for (let i = 0; i < h5_levels.length; i += 1) {
    h5_data = assign(h5_data, h5_levels[i]);
  }
  const block = {
    c: function create() {
      h5 = element("h5");
      if (default_slot)
        default_slot.c();
      set_attributes(h5, h5_data);
      add_location(h5, file25, 14, 0, 270);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h5, anchor);
      if (default_slot) {
        default_slot.m(h5, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h5, h5_data = get_spread_update(h5_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h5);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardTitle", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-title"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardTitle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardTitle",
      options,
      id: create_fragment26.name
    });
  }
  get class() {
    throw new Error("<CardTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardTitle_default = CardTitle;

// node_modules/@sveltestrap/sveltestrap/dist/Carousel/Carousel.svelte
var file26 = "node_modules/@sveltestrap/sveltestrap/dist/Carousel/Carousel.svelte";
function create_fragment27(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[6],
    { role: "presentation" },
    { class: (
      /*classes*/
      ctx[2]
    ) },
    { "data-bs-theme": (
      /*theme*/
      ctx[1]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file26, 129, 0, 2784);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "keydown",
            /*handleKeydown*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        { role: "presentation" },
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) },
        (!current || dirty & /*theme*/
        2) && { "data-bs-theme": (
          /*theme*/
          ctx2[1]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance27($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "activeIndex", "interval", "items", "keyboard", "pause", "ride", "theme"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Carousel", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { activeIndex = 0 } = $$props;
  let { interval = 5e3 } = $$props;
  let { items = [] } = $$props;
  let { keyboard = true } = $$props;
  let { pause = true } = $$props;
  let { ride = true } = $$props;
  let { theme = void 0 } = $$props;
  let _rideTimeoutId = false;
  let _removeVisibilityChangeListener = false;
  let classes = "";
  onMount(() => {
    setRideTimeout();
    _removeVisibilityChangeListener = browserEvent(document, "visibilitychange", () => {
      if (document.visibilityState === "hidden") {
        clearRideTimeout();
      } else {
        setRideTimeout();
      }
    });
  });
  onDestroy(() => {
    if (_rideTimeoutId) {
      clearTimeout(_rideTimeoutId);
    }
    if (_removeVisibilityChangeListener) {
      _removeVisibilityChangeListener();
    }
  });
  function handleKeydown(event) {
    if (!keyboard) {
      return;
    }
    let direction = "";
    if (event.key === "ArrowLeft") {
      direction = "prev";
    } else if (event.key === "ArrowRight") {
      direction = "next";
    } else {
      return;
    }
    $$invalidate(7, activeIndex = getNewCarouselActiveIndex(direction, items, activeIndex));
  }
  function setRideTimeout() {
    clearRideTimeout();
    if (ride) {
      _rideTimeoutId = setTimeout(autoNext, interval);
    }
  }
  function clearRideTimeout() {
    if (_rideTimeoutId) {
      clearTimeout(_rideTimeoutId);
    }
  }
  function autoNext() {
    $$invalidate(7, activeIndex = getNewCarouselActiveIndex("next", items, activeIndex));
  }
  const mouseenter_handler = () => pause ? clearRideTimeout() : void 0;
  const mouseleave_handler = () => pause ? setRideTimeout() : void 0;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(8, className = $$new_props.class);
    if ("activeIndex" in $$new_props)
      $$invalidate(7, activeIndex = $$new_props.activeIndex);
    if ("interval" in $$new_props)
      $$invalidate(9, interval = $$new_props.interval);
    if ("items" in $$new_props)
      $$invalidate(10, items = $$new_props.items);
    if ("keyboard" in $$new_props)
      $$invalidate(11, keyboard = $$new_props.keyboard);
    if ("pause" in $$new_props)
      $$invalidate(0, pause = $$new_props.pause);
    if ("ride" in $$new_props)
      $$invalidate(12, ride = $$new_props.ride);
    if ("theme" in $$new_props)
      $$invalidate(1, theme = $$new_props.theme);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    onMount,
    browserEvent,
    classnames,
    getNewCarouselActiveIndex,
    className,
    activeIndex,
    interval,
    items,
    keyboard,
    pause,
    ride,
    theme,
    _rideTimeoutId,
    _removeVisibilityChangeListener,
    classes,
    handleKeydown,
    setRideTimeout,
    clearRideTimeout,
    autoNext
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(8, className = $$new_props.className);
    if ("activeIndex" in $$props)
      $$invalidate(7, activeIndex = $$new_props.activeIndex);
    if ("interval" in $$props)
      $$invalidate(9, interval = $$new_props.interval);
    if ("items" in $$props)
      $$invalidate(10, items = $$new_props.items);
    if ("keyboard" in $$props)
      $$invalidate(11, keyboard = $$new_props.keyboard);
    if ("pause" in $$props)
      $$invalidate(0, pause = $$new_props.pause);
    if ("ride" in $$props)
      $$invalidate(12, ride = $$new_props.ride);
    if ("theme" in $$props)
      $$invalidate(1, theme = $$new_props.theme);
    if ("_rideTimeoutId" in $$props)
      _rideTimeoutId = $$new_props._rideTimeoutId;
    if ("_removeVisibilityChangeListener" in $$props)
      _removeVisibilityChangeListener = $$new_props._removeVisibilityChangeListener;
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    256) {
      $:
        $$invalidate(2, classes = classnames(className, "carousel", "slide"));
    }
  };
  return [
    pause,
    theme,
    classes,
    handleKeydown,
    setRideTimeout,
    clearRideTimeout,
    $$restProps,
    activeIndex,
    className,
    interval,
    items,
    keyboard,
    ride,
    $$scope,
    slots,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var Carousel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, {
      class: 8,
      activeIndex: 7,
      interval: 9,
      items: 10,
      keyboard: 11,
      pause: 0,
      ride: 12,
      theme: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Carousel",
      options,
      id: create_fragment27.name
    });
  }
  get class() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeIndex() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeIndex(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interval() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interval(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get items() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keyboard() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keyboard(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pause() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pause(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ride() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ride(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Carousel_default = Carousel;

// node_modules/@sveltestrap/sveltestrap/dist/CarouselCaption/CarouselCaption.svelte
var file27 = "node_modules/@sveltestrap/sveltestrap/dist/CarouselCaption/CarouselCaption.svelte";
function create_if_block_14(ctx) {
  let h5;
  let t;
  const block = {
    c: function create() {
      h5 = element("h5");
      t = text(
        /*captionHeader*/
        ctx[0]
      );
      add_location(h5, file27, 31, 21, 598);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h5, anchor);
      append_dev(h5, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*captionHeader*/
      1)
        set_data_dev(
          t,
          /*captionHeader*/
          ctx2[0]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h5);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(32:2) {#if captionHeader}",
    ctx
  });
  return block;
}
function create_if_block9(ctx) {
  let p;
  let t;
  const block = {
    c: function create() {
      p = element("p");
      t = text(
        /*captionText*/
        ctx[1]
      );
      add_location(p, file27, 32, 19, 647);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
      append_dev(p, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*captionText*/
      2)
        set_data_dev(
          t,
          /*captionText*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(33:2) {#if captionText}",
    ctx
  });
  return block;
}
function create_fragment28(ctx) {
  let div;
  let t0;
  let t1;
  let current;
  let if_block0 = (
    /*captionHeader*/
    ctx[0] && create_if_block_14(ctx)
  );
  let if_block1 = (
    /*captionText*/
    ctx[1] && create_if_block9(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file27, 30, 0, 538);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t1);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*captionHeader*/
        ctx2[0]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_14(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*captionText*/
        ctx2[1]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block9(ctx2);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "captionHeader", "captionText"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CarouselCaption", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { captionHeader = "" } = $$props;
  let { captionText = "" } = $$props;
  let classes = "";
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("captionHeader" in $$new_props)
      $$invalidate(0, captionHeader = $$new_props.captionHeader);
    if ("captionText" in $$new_props)
      $$invalidate(1, captionText = $$new_props.captionText);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    captionHeader,
    captionText,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("captionHeader" in $$props)
      $$invalidate(0, captionHeader = $$new_props.captionHeader);
    if ("captionText" in $$props)
      $$invalidate(1, captionText = $$new_props.captionText);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    16) {
      $:
        $$invalidate(2, classes = classnames(className, "carousel-caption", "d-none", "d-md-block"));
    }
  };
  return [captionHeader, captionText, classes, $$restProps, className, $$scope, slots];
}
var CarouselCaption = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, {
      class: 4,
      captionHeader: 0,
      captionText: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CarouselCaption",
      options,
      id: create_fragment28.name
    });
  }
  get class() {
    throw new Error("<CarouselCaption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CarouselCaption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get captionHeader() {
    throw new Error("<CarouselCaption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set captionHeader(value) {
    throw new Error("<CarouselCaption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get captionText() {
    throw new Error("<CarouselCaption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set captionText(value) {
    throw new Error("<CarouselCaption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CarouselCaption_default = CarouselCaption;

// node_modules/@sveltestrap/sveltestrap/dist/CarouselControl/CarouselControl.svelte
var file28 = "node_modules/@sveltestrap/sveltestrap/dist/CarouselControl/CarouselControl.svelte";
function create_fragment29(ctx) {
  let a;
  let span0;
  let span0_class_value;
  let t0;
  let span1;
  let t1;
  let a_href_value;
  let mounted;
  let dispose;
  let a_levels = [
    /*$$restProps*/
    ctx[4],
    { class: (
      /*classes*/
      ctx[1]
    ) },
    { role: "button" },
    {
      href: a_href_value = "#" + /*direction*/
      ctx[0]
    }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(
        /*screenText*/
        ctx[2]
      );
      attr_dev(span0, "class", span0_class_value = "carousel-control-" + /*direction*/
      ctx[0] + "-icon");
      attr_dev(span0, "aria-hidden", "true");
      add_location(span0, file28, 65, 2, 1537);
      attr_dev(span1, "class", "visually-hidden");
      add_location(span1, file28, 66, 2, 1609);
      set_attributes(a, a_data);
      add_location(a, file28, 64, 0, 1425);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      append_dev(a, span0);
      append_dev(a, t0);
      append_dev(a, span1);
      append_dev(span1, t1);
      if (!mounted) {
        dispose = listen_dev(a, "click", prevent_default(
          /*clickHandler*/
          ctx[3]
        ), false, true, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*direction*/
      1 && span0_class_value !== (span0_class_value = "carousel-control-" + /*direction*/
      ctx2[0] + "-icon")) {
        attr_dev(span0, "class", span0_class_value);
      }
      if (dirty & /*screenText*/
      4)
        set_data_dev(
          t1,
          /*screenText*/
          ctx2[2]
        );
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        dirty & /*classes*/
        2 && { class: (
          /*classes*/
          ctx2[1]
        ) },
        { role: "button" },
        dirty & /*direction*/
        1 && a_href_value !== (a_href_value = "#" + /*direction*/
        ctx2[0]) && { href: a_href_value }
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance29($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "direction", "directionText", "activeIndex", "items", "wrap"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CarouselControl", slots, []);
  let { class: className = "" } = $$props;
  let { direction = "" } = $$props;
  let { directionText = "" } = $$props;
  let { activeIndex = 0 } = $$props;
  let { items = [] } = $$props;
  let { wrap = true } = $$props;
  let classes = "";
  let screenText = "";
  function clickHandler() {
    const endOrBeginning = direction === "next" && activeIndex + 1 > items.length - 1 || direction === "prev" && activeIndex - 1 < 0;
    if (!wrap && endOrBeginning) {
      return;
    }
    $$invalidate(5, activeIndex = getNewCarouselActiveIndex(direction, items, activeIndex));
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(6, className = $$new_props.class);
    if ("direction" in $$new_props)
      $$invalidate(0, direction = $$new_props.direction);
    if ("directionText" in $$new_props)
      $$invalidate(7, directionText = $$new_props.directionText);
    if ("activeIndex" in $$new_props)
      $$invalidate(5, activeIndex = $$new_props.activeIndex);
    if ("items" in $$new_props)
      $$invalidate(8, items = $$new_props.items);
    if ("wrap" in $$new_props)
      $$invalidate(9, wrap = $$new_props.wrap);
  };
  $$self.$capture_state = () => ({
    classnames,
    getNewCarouselActiveIndex,
    className,
    direction,
    directionText,
    activeIndex,
    items,
    wrap,
    classes,
    screenText,
    clickHandler
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(6, className = $$new_props.className);
    if ("direction" in $$props)
      $$invalidate(0, direction = $$new_props.direction);
    if ("directionText" in $$props)
      $$invalidate(7, directionText = $$new_props.directionText);
    if ("activeIndex" in $$props)
      $$invalidate(5, activeIndex = $$new_props.activeIndex);
    if ("items" in $$props)
      $$invalidate(8, items = $$new_props.items);
    if ("wrap" in $$props)
      $$invalidate(9, wrap = $$new_props.wrap);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
    if ("screenText" in $$props)
      $$invalidate(2, screenText = $$new_props.screenText);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*direction, className*/
    65) {
      $:
        $$invalidate(1, classes = classnames(`carousel-control-${direction}`, className));
    }
    if ($$self.$$.dirty & /*directionText, direction*/
    129) {
      $:
        $$invalidate(2, screenText = directionText ? directionText : direction === "next" ? "Next" : "Previous");
    }
  };
  return [
    direction,
    classes,
    screenText,
    clickHandler,
    $$restProps,
    activeIndex,
    className,
    directionText,
    items,
    wrap
  ];
}
var CarouselControl = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, {
      class: 6,
      direction: 0,
      directionText: 7,
      activeIndex: 5,
      items: 8,
      wrap: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CarouselControl",
      options,
      id: create_fragment29.name
    });
  }
  get class() {
    throw new Error("<CarouselControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CarouselControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<CarouselControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<CarouselControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get directionText() {
    throw new Error("<CarouselControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set directionText(value) {
    throw new Error("<CarouselControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeIndex() {
    throw new Error("<CarouselControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeIndex(value) {
    throw new Error("<CarouselControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get items() {
    throw new Error("<CarouselControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<CarouselControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrap() {
    throw new Error("<CarouselControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrap(value) {
    throw new Error("<CarouselControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CarouselControl_default = CarouselControl;

// node_modules/@sveltestrap/sveltestrap/dist/CarouselIndicators/CarouselIndicators.svelte
var file29 = "node_modules/@sveltestrap/sveltestrap/dist/CarouselIndicators/CarouselIndicators.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  child_ctx[8] = i;
  return child_ctx;
}
function create_each_block(ctx) {
  let button;
  let t0_value = (
    /*item*/
    (ctx[6].title ? (
      /*item*/
      ctx[6].title
    ) : "") + ""
  );
  let t0;
  let t1;
  let button_aria_current_value;
  let button_aria_label_value;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[5](
        /*index*/
        ctx[8]
      )
    );
  }
  const block = {
    c: function create() {
      button = element("button");
      t0 = text(t0_value);
      t1 = space();
      attr_dev(button, "data-bs-target", "");
      attr_dev(button, "aria-current", button_aria_current_value = /*activeIndex*/
      ctx[0] === /*index*/
      ctx[8]);
      attr_dev(button, "aria-label", button_aria_label_value = /*item*/
      ctx[6].title);
      toggle_class(
        button,
        "active",
        /*activeIndex*/
        ctx[0] === /*index*/
        ctx[8]
      );
      add_location(button, file29, 32, 4, 581);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      append_dev(button, t0);
      append_dev(button, t1);
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler, false, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*items*/
      2 && t0_value !== (t0_value = /*item*/
      (ctx[6].title ? (
        /*item*/
        ctx[6].title
      ) : "") + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*activeIndex*/
      1 && button_aria_current_value !== (button_aria_current_value = /*activeIndex*/
      ctx[0] === /*index*/
      ctx[8])) {
        attr_dev(button, "aria-current", button_aria_current_value);
      }
      if (dirty & /*items*/
      2 && button_aria_label_value !== (button_aria_label_value = /*item*/
      ctx[6].title)) {
        attr_dev(button, "aria-label", button_aria_label_value);
      }
      if (dirty & /*activeIndex*/
      1) {
        toggle_class(
          button,
          "active",
          /*activeIndex*/
          ctx[0] === /*index*/
          ctx[8]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(32:2) {#each items as item, index}",
    ctx
  });
  return block;
}
function create_fragment30(ctx) {
  let div;
  let each_value = ensure_array_like_dev(
    /*items*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  let div_levels = [
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      set_attributes(div, div_data);
      add_location(div, file29, 30, 0, 507);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*activeIndex, items*/
      3) {
        each_value = ensure_array_like_dev(
          /*items*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        dirty & /*classes*/
        4 && { class: (
          /*classes*/
          ctx2[2]
        ) }
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance30($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "items", "activeIndex"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CarouselIndicators", slots, []);
  let { class: className = "" } = $$props;
  let { items = [] } = $$props;
  let { activeIndex = 0 } = $$props;
  let classes = "";
  const click_handler = (index) => $$invalidate(0, activeIndex = index);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("items" in $$new_props)
      $$invalidate(1, items = $$new_props.items);
    if ("activeIndex" in $$new_props)
      $$invalidate(0, activeIndex = $$new_props.activeIndex);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    items,
    activeIndex,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("items" in $$props)
      $$invalidate(1, items = $$new_props.items);
    if ("activeIndex" in $$props)
      $$invalidate(0, activeIndex = $$new_props.activeIndex);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    16) {
      $:
        $$invalidate(2, classes = classnames(className, "carousel-indicators"));
    }
  };
  return [activeIndex, items, classes, $$restProps, className, click_handler];
}
var CarouselIndicators = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, { class: 4, items: 1, activeIndex: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CarouselIndicators",
      options,
      id: create_fragment30.name
    });
  }
  get class() {
    throw new Error("<CarouselIndicators>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CarouselIndicators>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get items() {
    throw new Error("<CarouselIndicators>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<CarouselIndicators>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeIndex() {
    throw new Error("<CarouselIndicators>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeIndex(value) {
    throw new Error("<CarouselIndicators>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CarouselIndicators_default = CarouselIndicators;

// node_modules/@sveltestrap/sveltestrap/dist/CarouselItem/CarouselItem.svelte
var file30 = "node_modules/@sveltestrap/sveltestrap/dist/CarouselItem/CarouselItem.svelte";
function create_fragment31(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[3],
    {
      class: div_class_value = /*classes*/
      ctx[2] + " active"
    }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      toggle_class(
        div,
        "active",
        /*itemIndex*/
        ctx[1] === /*activeIndex*/
        ctx[0]
      );
      add_location(div, file30, 30, 0, 513);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        4 && div_class_value !== (div_class_value = /*classes*/
        ctx2[2] + " active")) && { class: div_class_value }
      ]));
      toggle_class(
        div,
        "active",
        /*itemIndex*/
        ctx2[1] === /*activeIndex*/
        ctx2[0]
      );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance31($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "activeIndex", "itemIndex"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CarouselItem", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { activeIndex = 0 } = $$props;
  let { itemIndex = 0 } = $$props;
  let classes = "";
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("activeIndex" in $$new_props)
      $$invalidate(0, activeIndex = $$new_props.activeIndex);
    if ("itemIndex" in $$new_props)
      $$invalidate(1, itemIndex = $$new_props.itemIndex);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    activeIndex,
    itemIndex,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("activeIndex" in $$props)
      $$invalidate(0, activeIndex = $$new_props.activeIndex);
    if ("itemIndex" in $$props)
      $$invalidate(1, itemIndex = $$new_props.itemIndex);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    16) {
      $:
        $$invalidate(2, classes = classnames(className, "carousel-item"));
    }
  };
  return [activeIndex, itemIndex, classes, $$restProps, className, $$scope, slots];
}
var CarouselItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment31, safe_not_equal, { class: 4, activeIndex: 0, itemIndex: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CarouselItem",
      options,
      id: create_fragment31.name
    });
  }
  get class() {
    throw new Error("<CarouselItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CarouselItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeIndex() {
    throw new Error("<CarouselItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeIndex(value) {
    throw new Error("<CarouselItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemIndex() {
    throw new Error("<CarouselItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemIndex(value) {
    throw new Error("<CarouselItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CarouselItem_default = CarouselItem;

// node_modules/@sveltestrap/sveltestrap/dist/Col/Col.svelte
var file31 = "node_modules/@sveltestrap/sveltestrap/dist/Col/Col.svelte";
function create_fragment32(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    {
      class: div_class_value = /*colClasses*/
      ctx[0].join(" ")
    }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file31, 63, 0, 1537);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        { class: div_class_value }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "xs", "sm", "md", "lg", "xl", "xxl"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Col", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { xs = void 0 } = $$props;
  let { sm = void 0 } = $$props;
  let { md = void 0 } = $$props;
  let { lg = void 0 } = $$props;
  let { xl = void 0 } = $$props;
  let { xxl = void 0 } = $$props;
  const colClasses = [];
  const lookup = { xs, sm, md, lg, xl, xxl };
  Object.keys(lookup).forEach((colWidth) => {
    const columnProp = lookup[colWidth];
    if (!columnProp && columnProp !== "") {
      return;
    }
    const isXs = colWidth === "xs";
    if (isObject(columnProp)) {
      const colSizeInterfix = isXs ? "-" : `-${colWidth}-`;
      const colClass = getColumnSizeClass(isXs, colWidth, columnProp.size);
      if (columnProp.size || columnProp.size === "") {
        colClasses.push(colClass);
      }
      if (columnProp.push) {
        colClasses.push(`push${colSizeInterfix}${columnProp.push}`);
      }
      if (columnProp.pull) {
        colClasses.push(`pull${colSizeInterfix}${columnProp.pull}`);
      }
      if (columnProp.offset) {
        colClasses.push(`offset${colSizeInterfix}${columnProp.offset}`);
      }
      if (columnProp.order) {
        colClasses.push(`order${colSizeInterfix}${columnProp.order}`);
      }
    } else {
      colClasses.push(getColumnSizeClass(isXs, colWidth, columnProp));
    }
  });
  if (!colClasses.length) {
    colClasses.push("col");
  }
  if (className) {
    colClasses.push(className);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("xs" in $$new_props)
      $$invalidate(3, xs = $$new_props.xs);
    if ("sm" in $$new_props)
      $$invalidate(4, sm = $$new_props.sm);
    if ("md" in $$new_props)
      $$invalidate(5, md = $$new_props.md);
    if ("lg" in $$new_props)
      $$invalidate(6, lg = $$new_props.lg);
    if ("xl" in $$new_props)
      $$invalidate(7, xl = $$new_props.xl);
    if ("xxl" in $$new_props)
      $$invalidate(8, xxl = $$new_props.xxl);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getColumnSizeClass,
    isObject,
    className,
    xs,
    sm,
    md,
    lg,
    xl,
    xxl,
    colClasses,
    lookup
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("xs" in $$props)
      $$invalidate(3, xs = $$new_props.xs);
    if ("sm" in $$props)
      $$invalidate(4, sm = $$new_props.sm);
    if ("md" in $$props)
      $$invalidate(5, md = $$new_props.md);
    if ("lg" in $$props)
      $$invalidate(6, lg = $$new_props.lg);
    if ("xl" in $$props)
      $$invalidate(7, xl = $$new_props.xl);
    if ("xxl" in $$props)
      $$invalidate(8, xxl = $$new_props.xxl);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [colClasses, $$restProps, className, xs, sm, md, lg, xl, xxl, $$scope, slots];
}
var Col = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, {
      class: 2,
      xs: 3,
      sm: 4,
      md: 5,
      lg: 6,
      xl: 7,
      xxl: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Col",
      options,
      id: create_fragment32.name
    });
  }
  get class() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xs() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xs(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sm() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sm(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get md() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set md(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lg() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lg(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xl() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xl(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xxl() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xxl(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Col_default = Col;

// node_modules/@sveltestrap/sveltestrap/dist/Column/Column.svelte
var file32 = "node_modules/@sveltestrap/sveltestrap/dist/Column/Column.svelte";
var get_header_slot_changes2 = (dirty) => ({});
var get_header_slot_context2 = (ctx) => ({});
var get_footer_slot_changes = (dirty) => ({});
var get_footer_slot_context = (ctx) => ({});
function create_else_block8(ctx) {
  let td;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let td_levels = [
    { class: (
      /*className*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[7]
  ];
  let td_data = {};
  for (let i = 0; i < td_levels.length; i += 1) {
    td_data = assign(td_data, td_levels[i]);
  }
  const block = {
    c: function create() {
      td = element("td");
      if (default_slot)
        default_slot.c();
      set_attributes(td, td_data);
      add_location(td, file32, 27, 2, 600);
    },
    m: function mount(target, anchor) {
      insert_dev(target, td, anchor);
      if (default_slot) {
        default_slot.m(td, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(td, td_data = get_spread_update(td_levels, [
        (!current || dirty & /*className*/
        1) && { class: (
          /*className*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block8.name,
    type: "else",
    source: "(27:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_33(ctx) {
  let th;
  let t;
  let current;
  let if_block = (
    /*header*/
    ctx[2] && create_if_block_42(ctx)
  );
  const header_slot_template = (
    /*#slots*/
    ctx[9].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_header_slot_context2
  );
  let th_levels = [
    /*$$restProps*/
    ctx[7]
  ];
  let th_data = {};
  for (let i = 0; i < th_levels.length; i += 1) {
    th_data = assign(th_data, th_levels[i]);
  }
  const block = {
    c: function create() {
      th = element("th");
      if (if_block)
        if_block.c();
      t = space();
      if (header_slot)
        header_slot.c();
      set_attributes(th, th_data);
      add_location(th, file32, 22, 2, 503);
    },
    m: function mount(target, anchor) {
      insert_dev(target, th, anchor);
      if (if_block)
        if_block.m(th, null);
      append_dev(th, t);
      if (header_slot) {
        header_slot.m(th, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*header*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_42(ctx2);
          if_block.c();
          if_block.m(th, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_header_slot_changes2
            ),
            get_header_slot_context2
          );
        }
      }
      set_attributes(th, th_data = get_spread_update(th_levels, [dirty & /*$$restProps*/
      128 && /*$$restProps*/
      ctx2[7]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
      if (if_block)
        if_block.d();
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_33.name,
    type: "if",
    source: "(22:15) ",
    ctx
  });
  return block;
}
function create_if_block_15(ctx) {
  let th;
  let t;
  let current;
  let if_block = (
    /*footer*/
    ctx[1] && create_if_block_24(ctx)
  );
  const footer_slot_template = (
    /*#slots*/
    ctx[9].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_footer_slot_context
  );
  let th_levels = [
    /*$$restProps*/
    ctx[7]
  ];
  let th_data = {};
  for (let i = 0; i < th_levels.length; i += 1) {
    th_data = assign(th_data, th_levels[i]);
  }
  const block = {
    c: function create() {
      th = element("th");
      if (if_block)
        if_block.c();
      t = space();
      if (footer_slot)
        footer_slot.c();
      set_attributes(th, th_data);
      add_location(th, file32, 17, 2, 398);
    },
    m: function mount(target, anchor) {
      insert_dev(target, th, anchor);
      if (if_block)
        if_block.m(th, null);
      append_dev(th, t);
      if (footer_slot) {
        footer_slot.m(th, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*footer*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_24(ctx2);
          if_block.c();
          if_block.m(th, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_footer_slot_changes
            ),
            get_footer_slot_context
          );
        }
      }
      set_attributes(th, th_data = get_spread_update(th_levels, [dirty & /*$$restProps*/
      128 && /*$$restProps*/
      ctx2[7]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
      if (if_block)
        if_block.d();
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(17:15) ",
    ctx
  });
  return block;
}
function create_if_block10(ctx) {
  let col;
  const block = {
    c: function create() {
      col = element("col");
      set_style(
        col,
        "width",
        /*width*/
        ctx[3]
      );
      add_location(col, file32, 15, 2, 348);
    },
    m: function mount(target, anchor) {
      insert_dev(target, col, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*width*/
      8) {
        set_style(
          col,
          "width",
          /*width*/
          ctx2[3]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(col);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(15:0) {#if colgroup}",
    ctx
  });
  return block;
}
function create_if_block_42(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*header*/
        ctx[2]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*header*/
      4)
        set_data_dev(
          t,
          /*header*/
          ctx2[2]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_42.name,
    type: "if",
    source: "(24:4) {#if header}",
    ctx
  });
  return block;
}
function create_if_block_24(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*footer*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*footer*/
      2)
        set_data_dev(
          t,
          /*footer*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_24.name,
    type: "if",
    source: "(19:4) {#if footer}",
    ctx
  });
  return block;
}
function create_fragment33(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block10, create_if_block_15, create_if_block_33, create_else_block8];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*colgroup*/
      ctx2[4]
    )
      return 0;
    if (
      /*foot*/
      ctx2[6]
    )
      return 1;
    if (
      /*head*/
      ctx2[5]
    )
      return 2;
    return 3;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if_block.p(ctx2, dirty);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance33($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "footer", "header", "width"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Column", slots, ["footer", "header", "default"]);
  let { class: className = "" } = $$props;
  let { footer = void 0 } = $$props;
  let { header = void 0 } = $$props;
  let { width = void 0 } = $$props;
  const colgroup = getContext("colgroup");
  const head = getContext("header");
  const foot = getContext("footer");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(0, className = $$new_props.class);
    if ("footer" in $$new_props)
      $$invalidate(1, footer = $$new_props.footer);
    if ("header" in $$new_props)
      $$invalidate(2, header = $$new_props.header);
    if ("width" in $$new_props)
      $$invalidate(3, width = $$new_props.width);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    className,
    footer,
    header,
    width,
    colgroup,
    head,
    foot
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(0, className = $$new_props.className);
    if ("footer" in $$props)
      $$invalidate(1, footer = $$new_props.footer);
    if ("header" in $$props)
      $$invalidate(2, header = $$new_props.header);
    if ("width" in $$props)
      $$invalidate(3, width = $$new_props.width);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    className,
    footer,
    header,
    width,
    colgroup,
    head,
    foot,
    $$restProps,
    $$scope,
    slots
  ];
}
var Column = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment33, safe_not_equal, { class: 0, footer: 1, header: 2, width: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Column",
      options,
      id: create_fragment33.name
    });
  }
  get class() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get footer() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set footer(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Column_default = Column;

// node_modules/@sveltestrap/sveltestrap/dist/Container/Container.svelte
var file33 = "node_modules/@sveltestrap/sveltestrap/dist/Container/Container.svelte";
function create_fragment34(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file33, 59, 0, 1182);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance34($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "sm", "md", "lg", "xl", "xxl", "fluid"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Container", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { sm = void 0 } = $$props;
  let { md = void 0 } = $$props;
  let { lg = void 0 } = $$props;
  let { xl = void 0 } = $$props;
  let { xxl = void 0 } = $$props;
  let { fluid = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("sm" in $$new_props)
      $$invalidate(3, sm = $$new_props.sm);
    if ("md" in $$new_props)
      $$invalidate(4, md = $$new_props.md);
    if ("lg" in $$new_props)
      $$invalidate(5, lg = $$new_props.lg);
    if ("xl" in $$new_props)
      $$invalidate(6, xl = $$new_props.xl);
    if ("xxl" in $$new_props)
      $$invalidate(7, xxl = $$new_props.xxl);
    if ("fluid" in $$new_props)
      $$invalidate(8, fluid = $$new_props.fluid);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    sm,
    md,
    lg,
    xl,
    xxl,
    fluid,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("sm" in $$props)
      $$invalidate(3, sm = $$new_props.sm);
    if ("md" in $$props)
      $$invalidate(4, md = $$new_props.md);
    if ("lg" in $$props)
      $$invalidate(5, lg = $$new_props.lg);
    if ("xl" in $$props)
      $$invalidate(6, xl = $$new_props.xl);
    if ("xxl" in $$props)
      $$invalidate(7, xxl = $$new_props.xxl);
    if ("fluid" in $$props)
      $$invalidate(8, fluid = $$new_props.fluid);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, sm, md, lg, xl, xxl, fluid*/
    508) {
      $:
        $$invalidate(0, classes = classnames(className, {
          "container-sm": sm,
          "container-md": md,
          "container-lg": lg,
          "container-xl": xl,
          "container-xxl": xxl,
          "container-fluid": fluid,
          container: !sm && !md && !lg && !xl && !xxl && !fluid
        }));
    }
  };
  return [classes, $$restProps, className, sm, md, lg, xl, xxl, fluid, $$scope, slots];
}
var Container = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance34, create_fragment34, safe_not_equal, {
      class: 2,
      sm: 3,
      md: 4,
      lg: 5,
      xl: 6,
      xxl: 7,
      fluid: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Container",
      options,
      id: create_fragment34.name
    });
  }
  get class() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sm() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sm(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get md() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set md(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lg() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lg(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xl() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xl(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xxl() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xxl(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fluid() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fluid(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Container_default = Container;

// node_modules/@sveltestrap/sveltestrap/dist/DropdownItem/DropdownItem.svelte
var file34 = "node_modules/@sveltestrap/sveltestrap/dist/DropdownItem/DropdownItem.svelte";
function create_else_block9(ctx) {
  let button;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let button_levels = [
    { type: "button" },
    /*$$restProps*/
    ctx[6],
    { class: (
      /*classes*/
      ctx[3]
    ) }
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      set_attributes(button, button_data);
      add_location(button, file34, 51, 4, 1219);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*click_handler_1*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*handleItemClick*/
            ctx[5],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block9.name,
    type: "else",
    source: "(51:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_25(ctx) {
  let a;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let a_levels = [
    /*$$restProps*/
    ctx[6],
    { click: "" },
    { href: (
      /*href*/
      ctx[2]
    ) },
    { class: (
      /*classes*/
      ctx[3]
    ) }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
      add_location(a, file34, 47, 4, 1104);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*handleItemClick*/
          ctx[5],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        { click: "" },
        (!current || dirty & /*href*/
        4) && { href: (
          /*href*/
          ctx2[2]
        ) },
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_25.name,
    type: "if",
    source: "(47:17) ",
    ctx
  });
  return block;
}
function create_if_block_16(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[6],
    { class: (
      /*classes*/
      ctx[3]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file34, 43, 4, 981);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "click",
            /*handleItemClick*/
            ctx[5],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_16.name,
    type: "if",
    source: "(42:20) ",
    ctx
  });
  return block;
}
function create_if_block11(ctx) {
  let h6;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let h6_levels = [
    /*$$restProps*/
    ctx[6],
    { class: (
      /*classes*/
      ctx[3]
    ) }
  ];
  let h6_data = {};
  for (let i = 0; i < h6_levels.length; i += 1) {
    h6_data = assign(h6_data, h6_levels[i]);
  }
  const block = {
    c: function create() {
      h6 = element("h6");
      if (default_slot)
        default_slot.c();
      set_attributes(h6, h6_data);
      add_location(h6, file34, 38, 4, 830);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h6, anchor);
      if (default_slot) {
        default_slot.m(h6, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h6, h6_data = get_spread_update(h6_levels, [
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h6);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block11.name,
    type: "if",
    source: "(38:2) {#if header}",
    ctx
  });
  return block;
}
function create_fragment35(ctx) {
  let li;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block11, create_if_block_16, create_if_block_25, create_else_block9];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*header*/
      ctx2[1]
    )
      return 0;
    if (
      /*divider*/
      ctx2[0]
    )
      return 1;
    if (
      /*href*/
      ctx2[2]
    )
      return 2;
    return 3;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      li = element("li");
      if_block.c();
      add_location(li, file34, 36, 0, 806);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      if_blocks[current_block_type_index].m(li, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(li, null);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance35($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "active", "disabled", "divider", "header", "toggle", "href"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $context;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownItem", slots, ["default"]);
  const context = getContext("dropdownContext");
  validate_store(context, "context");
  component_subscribe($$self, context, (value) => $$invalidate(15, $context = value));
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  let { disabled = false } = $$props;
  let { divider = false } = $$props;
  let { header = false } = $$props;
  let { toggle = true } = $$props;
  let { href = "" } = $$props;
  function handleItemClick(e) {
    if (disabled || header || divider) {
      e.preventDefault();
      return;
    }
    if (toggle && ($context.autoClose === true || $context.autoClose === "inside")) {
      $context.toggle(e);
    }
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(7, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(8, active = $$new_props.active);
    if ("disabled" in $$new_props)
      $$invalidate(9, disabled = $$new_props.disabled);
    if ("divider" in $$new_props)
      $$invalidate(0, divider = $$new_props.divider);
    if ("header" in $$new_props)
      $$invalidate(1, header = $$new_props.header);
    if ("toggle" in $$new_props)
      $$invalidate(10, toggle = $$new_props.toggle);
    if ("href" in $$new_props)
      $$invalidate(2, href = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    classnames,
    context,
    className,
    active,
    disabled,
    divider,
    header,
    toggle,
    href,
    handleItemClick,
    classes,
    $context
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(7, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(8, active = $$new_props.active);
    if ("disabled" in $$props)
      $$invalidate(9, disabled = $$new_props.disabled);
    if ("divider" in $$props)
      $$invalidate(0, divider = $$new_props.divider);
    if ("header" in $$props)
      $$invalidate(1, header = $$new_props.header);
    if ("toggle" in $$props)
      $$invalidate(10, toggle = $$new_props.toggle);
    if ("href" in $$props)
      $$invalidate(2, href = $$new_props.href);
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, disabled, divider, header, active*/
    899) {
      $:
        $$invalidate(3, classes = classnames(className, {
          disabled,
          "dropdown-item": !divider && !header,
          active,
          "dropdown-header": header,
          "dropdown-divider": divider
        }));
    }
  };
  return [
    divider,
    header,
    href,
    classes,
    context,
    handleItemClick,
    $$restProps,
    className,
    active,
    disabled,
    toggle,
    $$scope,
    slots,
    click_handler,
    click_handler_1
  ];
}
var DropdownItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment35, safe_not_equal, {
      class: 7,
      active: 8,
      disabled: 9,
      divider: 0,
      header: 1,
      toggle: 10,
      href: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownItem",
      options,
      id: create_fragment35.name
    });
  }
  get class() {
    throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get divider() {
    throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set divider(value) {
    throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownItem_default = DropdownItem;

// node_modules/@sveltestrap/sveltestrap/dist/DropdownMenu/DropdownMenu.svelte
var file35 = "node_modules/@sveltestrap/sveltestrap/dist/DropdownMenu/DropdownMenu.svelte";
function create_fragment36(ctx) {
  let ul;
  let ul_data_bs_popper_value;
  let $context_popperContent_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let ul_levels = [
    /*$$restProps*/
    ctx[4],
    { class: (
      /*classes*/
      ctx[1]
    ) },
    {
      "data-bs-popper": ul_data_bs_popper_value = /*$context*/
      ctx[0].inNavbar ? "static" : void 0
    }
  ];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      set_attributes(ul, ul_data);
      add_location(ul, file35, 45, 0, 904);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer($context_popperContent_action = /*$context*/
        ctx[0].popperContent(
          ul,
          /*popperOptions*/
          ctx[2]
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) },
        (!current || dirty & /*$context*/
        1 && ul_data_bs_popper_value !== (ul_data_bs_popper_value = /*$context*/
        ctx2[0].inNavbar ? "static" : void 0)) && {
          "data-bs-popper": ul_data_bs_popper_value
        }
      ]));
      if ($context_popperContent_action && is_function($context_popperContent_action.update) && dirty & /*popperOptions*/
      4)
        $context_popperContent_action.update.call(
          null,
          /*popperOptions*/
          ctx2[2]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance36($$self, $$props, $$invalidate) {
  let popperOptions;
  let classes;
  const omit_props_names = ["class", "end", "right"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $context;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownMenu", slots, ["default"]);
  const context = getContext("dropdownContext");
  validate_store(context, "context");
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  let { class: className = "" } = $$props;
  let { end: end2 = false } = $$props;
  let { right: right2 = false } = $$props;
  const popperPlacement = (direction, end3) => {
    let prefix = direction;
    if (direction === "up") {
      prefix = "top";
    }
    if (direction === "down") {
      prefix = "bottom";
    }
    let suffix = end3 ? "end" : "start";
    return `${prefix}-${suffix}`;
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("end" in $$new_props)
      $$invalidate(6, end2 = $$new_props.end);
    if ("right" in $$new_props)
      $$invalidate(7, right2 = $$new_props.right);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    classnames,
    context,
    className,
    end: end2,
    right: right2,
    popperPlacement,
    classes,
    popperOptions,
    $context
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("end" in $$props)
      $$invalidate(6, end2 = $$new_props.end);
    if ("right" in $$props)
      $$invalidate(7, right2 = $$new_props.right);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
    if ("popperOptions" in $$props)
      $$invalidate(2, popperOptions = $$new_props.popperOptions);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$context, end, right*/
    193) {
      $:
        $$invalidate(2, popperOptions = {
          modifiers: [
            { name: "flip" },
            {
              name: "offset",
              options: { offset: [0, 2] }
            }
          ],
          placement: popperPlacement($context.direction, end2 || right2)
        });
    }
    if ($$self.$$.dirty & /*className, end, right, $context*/
    225) {
      $:
        $$invalidate(1, classes = classnames(className, "dropdown-menu", {
          "dropdown-menu-end": end2 || right2,
          show: $context.isOpen
        }));
    }
  };
  return [
    $context,
    classes,
    popperOptions,
    context,
    $$restProps,
    className,
    end2,
    right2,
    $$scope,
    slots
  ];
}
var DropdownMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance36, create_fragment36, safe_not_equal, { class: 5, end: 6, right: 7 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownMenu",
      options,
      id: create_fragment36.name
    });
  }
  get class() {
    throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get end() {
    throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set end(value) {
    throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get right() {
    throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set right(value) {
    throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownMenu_default = DropdownMenu;

// node_modules/@sveltestrap/sveltestrap/dist/DropdownToggle/DropdownToggle.svelte
var file36 = "node_modules/@sveltestrap/sveltestrap/dist/DropdownToggle/DropdownToggle.svelte";
function create_else_block10(ctx) {
  let button;
  let button_aria_expanded_value;
  let $context_popperRef_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block_3(ctx);
  let button_levels = [
    /*$$restProps*/
    ctx[9],
    { type: "button" },
    {
      "aria-expanded": button_aria_expanded_value = /*$context*/
      ctx[5].isOpen
    },
    { class: (
      /*btnClasses*/
      ctx[6]
    ) }
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block_1 = {
    c: function create() {
      button = element("button");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      set_attributes(button, button_data);
      add_location(button, file36, 97, 2, 2102);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      ctx[28](button);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer($context_popperRef_action = /*$context*/
          ctx[5].popperRef(button)),
          listen_dev(
            button,
            "click",
            /*click_handler_3*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*toggleButton*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*ariaLabel*/
        2)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*$$restProps*/
        512 && /*$$restProps*/
        ctx2[9],
        { type: "button" },
        (!current || dirty & /*$context*/
        32 && button_aria_expanded_value !== (button_aria_expanded_value = /*$context*/
        ctx2[5].isOpen)) && {
          "aria-expanded": button_aria_expanded_value
        },
        (!current || dirty & /*btnClasses*/
        64) && { class: (
          /*btnClasses*/
          ctx2[6]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[28](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_else_block10.name,
    type: "else",
    source: "(97:0) {:else}",
    ctx
  });
  return block_1;
}
function create_if_block_26(ctx) {
  let span;
  let span_aria_expanded_value;
  let $context_popperRef_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block_2(ctx);
  let span_levels = [
    /*$$restProps*/
    ctx[9],
    {
      "aria-expanded": span_aria_expanded_value = /*$context*/
      ctx[5].isOpen
    },
    { class: (
      /*classes*/
      ctx[4]
    ) }
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block_1 = {
    c: function create() {
      span = element("span");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      set_attributes(span, span_data);
      add_location(span, file36, 83, 2, 1827);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(span, null);
      }
      ctx[27](span);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer($context_popperRef_action = /*$context*/
          ctx[5].popperRef(span)),
          listen_dev(
            span,
            "click",
            /*click_handler_2*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            span,
            "click",
            /*toggleButton*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*ariaLabel*/
        2)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*$$restProps*/
        512 && /*$$restProps*/
        ctx2[9],
        (!current || dirty & /*$context*/
        32 && span_aria_expanded_value !== (span_aria_expanded_value = /*$context*/
        ctx2[5].isOpen)) && {
          "aria-expanded": span_aria_expanded_value
        },
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[27](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_26.name,
    type: "if",
    source: "(82:25) ",
    ctx
  });
  return block_1;
}
function create_if_block_17(ctx) {
  let div;
  let div_aria_expanded_value;
  let $context_popperRef_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block_1(ctx);
  let div_levels = [
    /*$$restProps*/
    ctx[9],
    {
      "aria-expanded": div_aria_expanded_value = /*$context*/
      ctx[5].isOpen
    },
    { class: (
      /*classes*/
      ctx[4]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block_1 = {
    c: function create() {
      div = element("div");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      set_attributes(div, div_data);
      add_location(div, file36, 68, 2, 1475);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(div, null);
      }
      ctx[26](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer($context_popperRef_action = /*$context*/
          ctx[5].popperRef(div)),
          listen_dev(
            div,
            "click",
            /*click_handler_1*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "click",
            /*toggleButton*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*ariaLabel*/
        2)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        512 && /*$$restProps*/
        ctx2[9],
        (!current || dirty & /*$context*/
        32 && div_aria_expanded_value !== (div_aria_expanded_value = /*$context*/
        ctx2[5].isOpen)) && { "aria-expanded": div_aria_expanded_value },
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[26](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_17.name,
    type: "if",
    source: "(67:24) ",
    ctx
  });
  return block_1;
}
function create_if_block12(ctx) {
  let a;
  let a_aria_expanded_value;
  let $context_popperRef_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block2(ctx);
  let a_levels = [
    /*$$restProps*/
    ctx[9],
    { href: "#nav" },
    {
      "aria-expanded": a_aria_expanded_value = /*$context*/
      ctx[5].isOpen
    },
    { class: (
      /*classes*/
      ctx[4]
    ) }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block_1 = {
    c: function create() {
      a = element("a");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      set_attributes(a, a_data);
      add_location(a, file36, 52, 2, 1112);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(a, null);
      }
      ctx[25](a);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer($context_popperRef_action = /*$context*/
          ctx[5].popperRef(a)),
          listen_dev(
            a,
            "click",
            /*click_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "click",
            /*toggleButton*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*ariaLabel*/
        2)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*$$restProps*/
        512 && /*$$restProps*/
        ctx2[9],
        { href: "#nav" },
        (!current || dirty & /*$context*/
        32 && a_aria_expanded_value !== (a_aria_expanded_value = /*$context*/
        ctx2[5].isOpen)) && { "aria-expanded": a_aria_expanded_value },
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[25](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block12.name,
    type: "if",
    source: "(52:0) {#if nav}",
    ctx
  });
  return block_1;
}
function fallback_block_3(ctx) {
  let span;
  let t;
  const block_1 = {
    c: function create() {
      span = element("span");
      t = text(
        /*ariaLabel*/
        ctx[1]
      );
      attr_dev(span, "class", "visually-hidden");
      add_location(span, file36, 108, 6, 2319);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*ariaLabel*/
      2)
        set_data_dev(
          t,
          /*ariaLabel*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: fallback_block_3.name,
    type: "fallback",
    source: "(108:10)        ",
    ctx
  });
  return block_1;
}
function fallback_block_2(ctx) {
  let span;
  let t;
  const block_1 = {
    c: function create() {
      span = element("span");
      t = text(
        /*ariaLabel*/
        ctx[1]
      );
      attr_dev(span, "class", "visually-hidden");
      add_location(span, file36, 93, 6, 2021);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*ariaLabel*/
      2)
        set_data_dev(
          t,
          /*ariaLabel*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: fallback_block_2.name,
    type: "fallback",
    source: "(93:10)        ",
    ctx
  });
  return block_1;
}
function fallback_block_1(ctx) {
  let span;
  let t;
  const block_1 = {
    c: function create() {
      span = element("span");
      t = text(
        /*ariaLabel*/
        ctx[1]
      );
      attr_dev(span, "class", "visually-hidden");
      add_location(span, file36, 78, 6, 1668);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*ariaLabel*/
      2)
        set_data_dev(
          t,
          /*ariaLabel*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(78:10)        ",
    ctx
  });
  return block_1;
}
function fallback_block2(ctx) {
  let span;
  let t;
  const block_1 = {
    c: function create() {
      span = element("span");
      t = text(
        /*ariaLabel*/
        ctx[1]
      );
      attr_dev(span, "class", "visually-hidden");
      add_location(span, file36, 63, 6, 1319);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*ariaLabel*/
      2)
        set_data_dev(
          t,
          /*ariaLabel*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: fallback_block2.name,
    type: "fallback",
    source: "(63:10)        ",
    ctx
  });
  return block_1;
}
function create_fragment37(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block12, create_if_block_17, create_if_block_26, create_else_block10];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*nav*/
      ctx2[2]
    )
      return 0;
    if (
      /*tag*/
      ctx2[3] === "div"
    )
      return 1;
    if (
      /*tag*/
      ctx2[3] === "span"
    )
      return 2;
    return 3;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block_1 = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block_1;
}
function instance37($$self, $$props, $$invalidate) {
  let classes;
  let btnClasses;
  const omit_props_names = [
    "class",
    "ariaLabel",
    "active",
    "block",
    "caret",
    "color",
    "disabled",
    "inner",
    "nav",
    "outline",
    "size",
    "split",
    "tag"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $context;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownToggle", slots, ["default"]);
  const context = getContext("dropdownContext");
  validate_store(context, "context");
  component_subscribe($$self, context, (value) => $$invalidate(5, $context = value));
  let { class: className = "" } = $$props;
  let { ariaLabel = "Toggle Dropdown" } = $$props;
  let { active = false } = $$props;
  let { block = false } = $$props;
  let { caret = false } = $$props;
  let { color = "secondary" } = $$props;
  let { disabled = false } = $$props;
  let { inner = void 0 } = $$props;
  let { nav = false } = $$props;
  let { outline = false } = $$props;
  let { size = "" } = $$props;
  let { split = false } = $$props;
  let { tag = null } = $$props;
  function toggleButton(e) {
    if (disabled) {
      e.preventDefault();
      return;
    }
    if (nav) {
      e.preventDefault();
    }
    $context.toggle(e);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(0, inner);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(0, inner);
    });
  }
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(0, inner);
    });
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(0, inner);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(10, className = $$new_props.class);
    if ("ariaLabel" in $$new_props)
      $$invalidate(1, ariaLabel = $$new_props.ariaLabel);
    if ("active" in $$new_props)
      $$invalidate(11, active = $$new_props.active);
    if ("block" in $$new_props)
      $$invalidate(12, block = $$new_props.block);
    if ("caret" in $$new_props)
      $$invalidate(13, caret = $$new_props.caret);
    if ("color" in $$new_props)
      $$invalidate(14, color = $$new_props.color);
    if ("disabled" in $$new_props)
      $$invalidate(15, disabled = $$new_props.disabled);
    if ("inner" in $$new_props)
      $$invalidate(0, inner = $$new_props.inner);
    if ("nav" in $$new_props)
      $$invalidate(2, nav = $$new_props.nav);
    if ("outline" in $$new_props)
      $$invalidate(16, outline = $$new_props.outline);
    if ("size" in $$new_props)
      $$invalidate(17, size = $$new_props.size);
    if ("split" in $$new_props)
      $$invalidate(18, split = $$new_props.split);
    if ("tag" in $$new_props)
      $$invalidate(3, tag = $$new_props.tag);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    classnames,
    context,
    className,
    ariaLabel,
    active,
    block,
    caret,
    color,
    disabled,
    inner,
    nav,
    outline,
    size,
    split,
    tag,
    toggleButton,
    classes,
    btnClasses,
    $context
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(10, className = $$new_props.className);
    if ("ariaLabel" in $$props)
      $$invalidate(1, ariaLabel = $$new_props.ariaLabel);
    if ("active" in $$props)
      $$invalidate(11, active = $$new_props.active);
    if ("block" in $$props)
      $$invalidate(12, block = $$new_props.block);
    if ("caret" in $$props)
      $$invalidate(13, caret = $$new_props.caret);
    if ("color" in $$props)
      $$invalidate(14, color = $$new_props.color);
    if ("disabled" in $$props)
      $$invalidate(15, disabled = $$new_props.disabled);
    if ("inner" in $$props)
      $$invalidate(0, inner = $$new_props.inner);
    if ("nav" in $$props)
      $$invalidate(2, nav = $$new_props.nav);
    if ("outline" in $$props)
      $$invalidate(16, outline = $$new_props.outline);
    if ("size" in $$props)
      $$invalidate(17, size = $$new_props.size);
    if ("split" in $$props)
      $$invalidate(18, split = $$new_props.split);
    if ("tag" in $$props)
      $$invalidate(3, tag = $$new_props.tag);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
    if ("btnClasses" in $$props)
      $$invalidate(6, btnClasses = $$new_props.btnClasses);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, caret, split, nav, $context*/
    271396) {
      $:
        $$invalidate(4, classes = classnames(className, {
          "dropdown-toggle": caret || split,
          "dropdown-toggle-split": split,
          "nav-link": nav,
          show: $context.isOpen
        }));
    }
    if ($$self.$$.dirty & /*classes, outline, color, size, block, active*/
    219152) {
      $:
        $$invalidate(6, btnClasses = classnames(classes, "btn", `btn${outline ? "-outline" : ""}-${color}`, size ? `btn-${size}` : false, block ? "d-block w-100" : false, { active }));
    }
  };
  return [
    inner,
    ariaLabel,
    nav,
    tag,
    classes,
    $context,
    btnClasses,
    context,
    toggleButton,
    $$restProps,
    className,
    active,
    block,
    caret,
    color,
    disabled,
    outline,
    size,
    split,
    $$scope,
    slots,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    a_binding,
    div_binding,
    span_binding,
    button_binding
  ];
}
var DropdownToggle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance37, create_fragment37, safe_not_equal, {
      class: 10,
      ariaLabel: 1,
      active: 11,
      block: 12,
      caret: 13,
      color: 14,
      disabled: 15,
      inner: 0,
      nav: 2,
      outline: 16,
      size: 17,
      split: 18,
      tag: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownToggle",
      options,
      id: create_fragment37.name
    });
  }
  get class() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabel() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get block() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set block(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caret() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caret(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inner() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inner(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nav() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nav(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get split() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set split(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownToggle_default = DropdownToggle;

// node_modules/@sveltestrap/sveltestrap/dist/Fade/Fade.svelte
var file37 = "node_modules/@sveltestrap/sveltestrap/dist/Fade/Fade.svelte";
function create_if_block13(ctx) {
  let div;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[6],
    { class: (
      /*className*/
      ctx[1]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file37, 60, 2, 1386);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "introstart",
            /*introstart_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "introend",
            /*introend_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outrostart",
            /*outrostart_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outroend",
            /*outroend_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "introstart",
            function() {
              if (is_function(
                /*onEntering*/
                ctx[2]
              ))
                ctx[2].apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "introend",
            function() {
              if (is_function(
                /*onEntered*/
                ctx[3]
              ))
                ctx[3].apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outrostart",
            function() {
              if (is_function(
                /*onExiting*/
                ctx[4]
              ))
                ctx[4].apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outroend",
            function() {
              if (is_function(
                /*onExited*/
                ctx[5]
              ))
                ctx[5].apply(this, arguments);
            },
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx[6],
        (!current || dirty & /*className*/
        2) && { class: (
          /*className*/
          ctx[1]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, fade, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, fade, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block13.name,
    type: "if",
    source: "(60:0) {#if isOpen}",
    ctx
  });
  return block;
}
function create_fragment38(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*isOpen*/
    ctx[0] && create_if_block13(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isOpen*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isOpen*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block13(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance38($$self, $$props, $$invalidate) {
  const omit_props_names = ["isOpen", "class", "onEntering", "onEntered", "onExiting", "onExited", "toggler"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Fade", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { isOpen = false } = $$props;
  let { class: className = "" } = $$props;
  let { onEntering = () => dispatch("opening") } = $$props;
  let { onEntered = () => dispatch("open") } = $$props;
  let { onExiting = () => dispatch("closing") } = $$props;
  let { onExited = () => dispatch("close") } = $$props;
  let { toggler = null } = $$props;
  onMount(() => toggle_default(toggler, (e) => {
    $$invalidate(0, isOpen = !isOpen);
    e.preventDefault();
  }));
  function introstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function introend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function outrostart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function outroend_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("onEntering" in $$new_props)
      $$invalidate(2, onEntering = $$new_props.onEntering);
    if ("onEntered" in $$new_props)
      $$invalidate(3, onEntered = $$new_props.onEntered);
    if ("onExiting" in $$new_props)
      $$invalidate(4, onExiting = $$new_props.onExiting);
    if ("onExited" in $$new_props)
      $$invalidate(5, onExited = $$new_props.onExited);
    if ("toggler" in $$new_props)
      $$invalidate(7, toggler = $$new_props.toggler);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    fade,
    toggle: toggle_default,
    dispatch,
    isOpen,
    className,
    onEntering,
    onEntered,
    onExiting,
    onExited,
    toggler
  });
  $$self.$inject_state = ($$new_props) => {
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("onEntering" in $$props)
      $$invalidate(2, onEntering = $$new_props.onEntering);
    if ("onEntered" in $$props)
      $$invalidate(3, onEntered = $$new_props.onEntered);
    if ("onExiting" in $$props)
      $$invalidate(4, onExiting = $$new_props.onExiting);
    if ("onExited" in $$props)
      $$invalidate(5, onExited = $$new_props.onExited);
    if ("toggler" in $$props)
      $$invalidate(7, toggler = $$new_props.toggler);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    isOpen,
    className,
    onEntering,
    onEntered,
    onExiting,
    onExited,
    $$restProps,
    toggler,
    $$scope,
    slots,
    introstart_handler,
    introend_handler,
    outrostart_handler,
    outroend_handler
  ];
}
var Fade = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance38, create_fragment38, safe_not_equal, {
      isOpen: 0,
      class: 1,
      onEntering: 2,
      onEntered: 3,
      onExiting: 4,
      onExited: 5,
      toggler: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fade",
      options,
      id: create_fragment38.name
    });
  }
  get isOpen() {
    throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onEntering() {
    throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onEntering(value) {
    throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onEntered() {
    throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onEntered(value) {
    throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onExiting() {
    throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onExiting(value) {
    throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onExited() {
    throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onExited(value) {
    throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggler() {
    throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggler(value) {
    throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Fade_default = Fade;

// node_modules/@sveltestrap/sveltestrap/dist/Figure/Figure.svelte
var file38 = "node_modules/@sveltestrap/sveltestrap/dist/Figure/Figure.svelte";
var get_caption_slot_changes = (dirty) => ({});
var get_caption_slot_context = (ctx) => ({});
function create_if_block14(ctx) {
  let figcaption;
  let t;
  let current;
  const caption_slot_template = (
    /*#slots*/
    ctx[7].caption
  );
  const caption_slot = create_slot(
    caption_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_caption_slot_context
  );
  const block = {
    c: function create() {
      figcaption = element("figcaption");
      t = text(
        /*caption*/
        ctx[1]
      );
      if (caption_slot)
        caption_slot.c();
      attr_dev(figcaption, "class", "figure-caption");
      add_location(figcaption, file38, 36, 4, 760);
    },
    m: function mount(target, anchor) {
      insert_dev(target, figcaption, anchor);
      append_dev(figcaption, t);
      if (caption_slot) {
        caption_slot.m(figcaption, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*caption*/
      2)
        set_data_dev(
          t,
          /*caption*/
          ctx2[1]
        );
      if (caption_slot) {
        if (caption_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            caption_slot,
            caption_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              caption_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_caption_slot_changes
            ),
            get_caption_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(caption_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(caption_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(figcaption);
      }
      if (caption_slot)
        caption_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block14.name,
    type: "if",
    source: "(36:2) {#if caption || $$slots.caption}",
    ctx
  });
  return block;
}
function create_fragment39(ctx) {
  let img;
  let t0;
  let figure;
  let t1;
  let current;
  let img_levels = [
    { alt: (
      /*alt*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) }
  ];
  let img_data = {};
  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = assign(img_data, img_levels[i]);
  }
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let if_block = (
    /*caption*/
    (ctx[1] || /*$$slots*/
    ctx[4].caption) && create_if_block14(ctx)
  );
  let figure_levels = [
    { class: (
      /*classes*/
      ctx[2]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let figure_data = {};
  for (let i = 0; i < figure_levels.length; i += 1) {
    figure_data = assign(figure_data, figure_levels[i]);
  }
  const block = {
    c: function create() {
      img = element("img");
      t0 = space();
      figure = element("figure");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block)
        if_block.c();
      set_attributes(img, img_data);
      add_location(img, file38, 31, 0, 620);
      set_attributes(figure, figure_data);
      add_location(figure, file38, 33, 0, 668);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
      insert_dev(target, t0, anchor);
      insert_dev(target, figure, anchor);
      if (default_slot) {
        default_slot.m(figure, null);
      }
      append_dev(figure, t1);
      if (if_block)
        if_block.m(figure, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(img, img_data = get_spread_update(img_levels, [
        (!current || dirty & /*alt*/
        1) && { alt: (
          /*alt*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) }
      ]));
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*caption*/
        ctx2[1] || /*$$slots*/
        ctx2[4].caption
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*caption, $$slots*/
          18) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block14(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(figure, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(figure, figure_data = get_spread_update(figure_levels, [
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(img);
        detach_dev(t0);
        detach_dev(figure);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance39($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "alt", "caption"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Figure", slots, ["default", "caption"]);
  const $$slots = compute_slots(slots);
  setContext("figure", true);
  let { class: className = "" } = $$props;
  let { alt = void 0 } = $$props;
  let { caption = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("alt" in $$new_props)
      $$invalidate(0, alt = $$new_props.alt);
    if ("caption" in $$new_props)
      $$invalidate(1, caption = $$new_props.caption);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    classnames,
    className,
    alt,
    caption,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("alt" in $$props)
      $$invalidate(0, alt = $$new_props.alt);
    if ("caption" in $$props)
      $$invalidate(1, caption = $$new_props.caption);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    32) {
      $:
        $$invalidate(2, classes = classnames("figure", className));
    }
  };
  return [alt, caption, classes, $$restProps, $$slots, className, $$scope, slots];
}
var Figure = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance39, create_fragment39, safe_not_equal, { class: 5, alt: 0, caption: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Figure",
      options,
      id: create_fragment39.name
    });
  }
  get class() {
    throw new Error("<Figure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Figure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error("<Figure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<Figure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caption() {
    throw new Error("<Figure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caption(value) {
    throw new Error("<Figure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Figure_default = Figure;

// node_modules/@sveltestrap/sveltestrap/dist/Form/Form.svelte
var file39 = "node_modules/@sveltestrap/sveltestrap/dist/Form/Form.svelte";
function create_fragment40(ctx) {
  let form;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let form_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let form_data = {};
  for (let i = 0; i < form_levels.length; i += 1) {
    form_data = assign(form_data, form_levels[i]);
  }
  const block = {
    c: function create() {
      form = element("form");
      if (default_slot)
        default_slot.c();
      set_attributes(form, form_data);
      add_location(form, file39, 14, 0, 282);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, form, anchor);
      if (default_slot) {
        default_slot.m(form, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          form,
          "submit",
          /*submit_handler*/
          ctx[7],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(form, form_data = get_spread_update(form_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(form);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance40($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "inline", "validated"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Form", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { inline = false } = $$props;
  let { validated = false } = $$props;
  function submit_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("inline" in $$new_props)
      $$invalidate(3, inline = $$new_props.inline);
    if ("validated" in $$new_props)
      $$invalidate(4, validated = $$new_props.validated);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    inline,
    validated,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("inline" in $$props)
      $$invalidate(3, inline = $$new_props.inline);
    if ("validated" in $$props)
      $$invalidate(4, validated = $$new_props.validated);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, inline, validated*/
    28) {
      $:
        $$invalidate(0, classes = classnames(className, {
          "form-inline": inline,
          "was-validated": validated
        }));
    }
  };
  return [
    classes,
    $$restProps,
    className,
    inline,
    validated,
    $$scope,
    slots,
    submit_handler
  ];
}
var Form = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance40, create_fragment40, safe_not_equal, { class: 2, inline: 3, validated: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Form",
      options,
      id: create_fragment40.name
    });
  }
  get class() {
    throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validated() {
    throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validated(value) {
    throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Form_default = Form;

// node_modules/@sveltestrap/sveltestrap/dist/FormCheck/FormCheck.svelte
var file40 = "node_modules/@sveltestrap/sveltestrap/dist/FormCheck/FormCheck.svelte";
var get_label_slot_changes = (dirty) => ({});
var get_label_slot_context = (ctx) => ({});
function create_else_block11(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[11],
    { class: (
      /*inputClasses*/
      ctx[9]
    ) },
    { id: (
      /*idFor*/
      ctx[8]
    ) },
    { type: "checkbox" },
    { disabled: (
      /*disabled*/
      ctx[3]
    ) },
    { name: (
      /*name*/
      ctx[5]
    ) },
    { __value: (
      /*value*/
      ctx[7]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file40, 68, 4, 1456);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      input.checked = /*checked*/
      ctx[0];
      ctx[39](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler_2*/
            ctx[38]
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler_2*/
            ctx[29],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_2*/
            ctx[30],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_2*/
            ctx[31],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_2*/
            ctx[32],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        2048 && /*$$restProps*/
        ctx2[11],
        dirty[0] & /*inputClasses*/
        512 && { class: (
          /*inputClasses*/
          ctx2[9]
        ) },
        dirty[0] & /*idFor*/
        256 && { id: (
          /*idFor*/
          ctx2[8]
        ) },
        { type: "checkbox" },
        dirty[0] & /*disabled*/
        8 && { disabled: (
          /*disabled*/
          ctx2[3]
        ) },
        dirty[0] & /*name*/
        32 && { name: (
          /*name*/
          ctx2[5]
        ) },
        dirty[0] & /*value*/
        128 && { __value: (
          /*value*/
          ctx2[7]
        ) }
      ]));
      if (dirty[0] & /*checked*/
      1) {
        input.checked = /*checked*/
        ctx2[0];
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      ctx[39](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block11.name,
    type: "else",
    source: "(68:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_27(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[11],
    { class: (
      /*inputClasses*/
      ctx[9]
    ) },
    { id: (
      /*idFor*/
      ctx[8]
    ) },
    { type: "checkbox" },
    { disabled: (
      /*disabled*/
      ctx[3]
    ) },
    { name: (
      /*name*/
      ctx[5]
    ) },
    { __value: (
      /*value*/
      ctx[7]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file40, 52, 4, 1192);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      input.checked = /*checked*/
      ctx[0];
      ctx[37](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler_1*/
            ctx[36]
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler_1*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_1*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_1*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_1*/
            ctx[28],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        2048 && /*$$restProps*/
        ctx2[11],
        dirty[0] & /*inputClasses*/
        512 && { class: (
          /*inputClasses*/
          ctx2[9]
        ) },
        dirty[0] & /*idFor*/
        256 && { id: (
          /*idFor*/
          ctx2[8]
        ) },
        { type: "checkbox" },
        dirty[0] & /*disabled*/
        8 && { disabled: (
          /*disabled*/
          ctx2[3]
        ) },
        dirty[0] & /*name*/
        32 && { name: (
          /*name*/
          ctx2[5]
        ) },
        dirty[0] & /*value*/
        128 && { __value: (
          /*value*/
          ctx2[7]
        ) }
      ]));
      if (dirty[0] & /*checked*/
      1) {
        input.checked = /*checked*/
        ctx2[0];
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      ctx[37](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_27.name,
    type: "if",
    source: "(52:30) ",
    ctx
  });
  return block;
}
function create_if_block_18(ctx) {
  let input;
  let binding_group;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[11],
    { class: (
      /*inputClasses*/
      ctx[9]
    ) },
    { id: (
      /*idFor*/
      ctx[8]
    ) },
    { type: "radio" },
    { disabled: (
      /*disabled*/
      ctx[3]
    ) },
    { name: (
      /*name*/
      ctx[5]
    ) },
    { __value: (
      /*value*/
      ctx[7]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  binding_group = init_binding_group(
    /*$$binding_groups*/
    ctx[34][0]
  );
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file40, 36, 4, 912);
      binding_group.p(input);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      input.checked = input.__value === /*group*/
      ctx[1];
      ctx[35](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[33]
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        2048 && /*$$restProps*/
        ctx2[11],
        dirty[0] & /*inputClasses*/
        512 && { class: (
          /*inputClasses*/
          ctx2[9]
        ) },
        dirty[0] & /*idFor*/
        256 && { id: (
          /*idFor*/
          ctx2[8]
        ) },
        { type: "radio" },
        dirty[0] & /*disabled*/
        8 && { disabled: (
          /*disabled*/
          ctx2[3]
        ) },
        dirty[0] & /*name*/
        32 && { name: (
          /*name*/
          ctx2[5]
        ) },
        dirty[0] & /*value*/
        128 && { __value: (
          /*value*/
          ctx2[7]
        ) }
      ]));
      if (dirty[0] & /*group*/
      2) {
        input.checked = input.__value === /*group*/
        ctx2[1];
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      ctx[35](null);
      binding_group.r();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_18.name,
    type: "if",
    source: "(36:2) {#if type === 'radio'}",
    ctx
  });
  return block;
}
function create_if_block15(ctx) {
  let label_1;
  let current;
  const label_slot_template = (
    /*#slots*/
    ctx[20].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_label_slot_context
  );
  const label_slot_or_fallback = label_slot || fallback_block3(ctx);
  const block = {
    c: function create() {
      label_1 = element("label");
      if (label_slot_or_fallback)
        label_slot_or_fallback.c();
      attr_dev(label_1, "class", "form-check-label");
      attr_dev(
        label_1,
        "for",
        /*idFor*/
        ctx[8]
      );
      add_location(label_1, file40, 85, 4, 1732);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label_1, anchor);
      if (label_slot_or_fallback) {
        label_slot_or_fallback.m(label_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty[0] & /*$$scope*/
        524288)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_label_slot_changes
            ),
            get_label_slot_context
          );
        }
      } else {
        if (label_slot_or_fallback && label_slot_or_fallback.p && (!current || dirty[0] & /*label*/
        16)) {
          label_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*idFor*/
      256) {
        attr_dev(
          label_1,
          "for",
          /*idFor*/
          ctx2[8]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label_1);
      }
      if (label_slot_or_fallback)
        label_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block15.name,
    type: "if",
    source: "(85:2) {#if label}",
    ctx
  });
  return block;
}
function fallback_block3(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*label*/
        ctx[4]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*label*/
      16)
        set_data_dev(
          t,
          /*label*/
          ctx2[4]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block3.name,
    type: "fallback",
    source: "(87:25) {label}",
    ctx
  });
  return block;
}
function create_fragment41(ctx) {
  let div;
  let t;
  let current;
  function select_block_type(ctx2, dirty) {
    if (
      /*type*/
      ctx2[6] === "radio"
    )
      return create_if_block_18;
    if (
      /*type*/
      ctx2[6] === "switch"
    )
      return create_if_block_27;
    return create_else_block11;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block0 = current_block_type(ctx);
  let if_block1 = (
    /*label*/
    ctx[4] && create_if_block15(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      attr_dev(
        div,
        "class",
        /*classes*/
        ctx[10]
      );
      add_location(div, file40, 34, 0, 861);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if_block0.m(div, null);
      append_dev(div, t);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div, t);
        }
      }
      if (
        /*label*/
        ctx2[4]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*label*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block15(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*classes*/
      1024) {
        attr_dev(
          div,
          "class",
          /*classes*/
          ctx2[10]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance41($$self, $$props, $$invalidate) {
  let classes;
  let inputClasses;
  let idFor;
  const omit_props_names = [
    "class",
    "checked",
    "disabled",
    "group",
    "id",
    "inline",
    "inner",
    "invalid",
    "label",
    "name",
    "reverse",
    "size",
    "type",
    "valid",
    "value"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FormCheck", slots, ["label"]);
  let { class: className = "" } = $$props;
  let { checked = false } = $$props;
  let { disabled = false } = $$props;
  let { group = void 0 } = $$props;
  let { id = void 0 } = $$props;
  let { inline = false } = $$props;
  let { inner = void 0 } = $$props;
  let { invalid = false } = $$props;
  let { label = "" } = $$props;
  let { name = "" } = $$props;
  let { reverse = false } = $$props;
  let { size = "" } = $$props;
  let { type = "checkbox" } = $$props;
  let { valid = false } = $$props;
  let { value = void 0 } = $$props;
  const $$binding_groups = [[]];
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function input_change_handler() {
    group = this.__value;
    $$invalidate(1, group);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(2, inner);
    });
  }
  function input_change_handler_1() {
    checked = this.checked;
    $$invalidate(0, checked);
  }
  function input_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(2, inner);
    });
  }
  function input_change_handler_2() {
    checked = this.checked;
    $$invalidate(0, checked);
  }
  function input_binding_2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(2, inner);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(12, className = $$new_props.class);
    if ("checked" in $$new_props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("disabled" in $$new_props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("group" in $$new_props)
      $$invalidate(1, group = $$new_props.group);
    if ("id" in $$new_props)
      $$invalidate(13, id = $$new_props.id);
    if ("inline" in $$new_props)
      $$invalidate(14, inline = $$new_props.inline);
    if ("inner" in $$new_props)
      $$invalidate(2, inner = $$new_props.inner);
    if ("invalid" in $$new_props)
      $$invalidate(15, invalid = $$new_props.invalid);
    if ("label" in $$new_props)
      $$invalidate(4, label = $$new_props.label);
    if ("name" in $$new_props)
      $$invalidate(5, name = $$new_props.name);
    if ("reverse" in $$new_props)
      $$invalidate(16, reverse = $$new_props.reverse);
    if ("size" in $$new_props)
      $$invalidate(17, size = $$new_props.size);
    if ("type" in $$new_props)
      $$invalidate(6, type = $$new_props.type);
    if ("valid" in $$new_props)
      $$invalidate(18, valid = $$new_props.valid);
    if ("value" in $$new_props)
      $$invalidate(7, value = $$new_props.value);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    checked,
    disabled,
    group,
    id,
    inline,
    inner,
    invalid,
    label,
    name,
    reverse,
    size,
    type,
    valid,
    value,
    idFor,
    inputClasses,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(12, className = $$new_props.className);
    if ("checked" in $$props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("disabled" in $$props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("group" in $$props)
      $$invalidate(1, group = $$new_props.group);
    if ("id" in $$props)
      $$invalidate(13, id = $$new_props.id);
    if ("inline" in $$props)
      $$invalidate(14, inline = $$new_props.inline);
    if ("inner" in $$props)
      $$invalidate(2, inner = $$new_props.inner);
    if ("invalid" in $$props)
      $$invalidate(15, invalid = $$new_props.invalid);
    if ("label" in $$props)
      $$invalidate(4, label = $$new_props.label);
    if ("name" in $$props)
      $$invalidate(5, name = $$new_props.name);
    if ("reverse" in $$props)
      $$invalidate(16, reverse = $$new_props.reverse);
    if ("size" in $$props)
      $$invalidate(17, size = $$new_props.size);
    if ("type" in $$props)
      $$invalidate(6, type = $$new_props.type);
    if ("valid" in $$props)
      $$invalidate(18, valid = $$new_props.valid);
    if ("value" in $$props)
      $$invalidate(7, value = $$new_props.value);
    if ("idFor" in $$props)
      $$invalidate(8, idFor = $$new_props.idFor);
    if ("inputClasses" in $$props)
      $$invalidate(9, inputClasses = $$new_props.inputClasses);
    if ("classes" in $$props)
      $$invalidate(10, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*className, reverse, type, inline, size*/
    217152) {
      $:
        $$invalidate(10, classes = classnames(className, "form-check", {
          "form-check-reverse": reverse,
          "form-switch": type === "switch",
          "form-check-inline": inline,
          [`form-control-${size}`]: size
        }));
    }
    if ($$self.$$.dirty[0] & /*invalid, valid*/
    294912) {
      $:
        $$invalidate(9, inputClasses = classnames("form-check-input", { "is-invalid": invalid, "is-valid": valid }));
    }
    if ($$self.$$.dirty[0] & /*id, label*/
    8208) {
      $:
        $$invalidate(8, idFor = id || label);
    }
  };
  return [
    checked,
    group,
    inner,
    disabled,
    label,
    name,
    type,
    value,
    idFor,
    inputClasses,
    classes,
    $$restProps,
    className,
    id,
    inline,
    invalid,
    reverse,
    size,
    valid,
    $$scope,
    slots,
    blur_handler,
    change_handler,
    focus_handler,
    input_handler,
    blur_handler_1,
    change_handler_1,
    focus_handler_1,
    input_handler_1,
    blur_handler_2,
    change_handler_2,
    focus_handler_2,
    input_handler_2,
    input_change_handler,
    $$binding_groups,
    input_binding,
    input_change_handler_1,
    input_binding_1,
    input_change_handler_2,
    input_binding_2
  ];
}
var FormCheck = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance41,
      create_fragment41,
      safe_not_equal,
      {
        class: 12,
        checked: 0,
        disabled: 3,
        group: 1,
        id: 13,
        inline: 14,
        inner: 2,
        invalid: 15,
        label: 4,
        name: 5,
        reverse: 16,
        size: 17,
        type: 6,
        valid: 18,
        value: 7
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FormCheck",
      options,
      id: create_fragment41.name
    });
  }
  get class() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get group() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inner() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inner(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reverse() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set reverse(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valid() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valid(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FormCheck_default = FormCheck;

// node_modules/@sveltestrap/sveltestrap/dist/FormFeedback/FormFeedback.svelte
var file41 = "node_modules/@sveltestrap/sveltestrap/dist/FormFeedback/FormFeedback.svelte";
function create_fragment42(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file41, 16, 0, 355);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance42($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "valid", "tooltip"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FormFeedback", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { valid = void 0 } = $$props;
  let { tooltip = false } = $$props;
  let classes;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("valid" in $$new_props)
      $$invalidate(3, valid = $$new_props.valid);
    if ("tooltip" in $$new_props)
      $$invalidate(4, tooltip = $$new_props.tooltip);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    valid,
    tooltip,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("valid" in $$props)
      $$invalidate(3, valid = $$new_props.valid);
    if ("tooltip" in $$props)
      $$invalidate(4, tooltip = $$new_props.tooltip);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*tooltip, className, valid*/
    28) {
      $: {
        const validMode = tooltip ? "tooltip" : "feedback";
        $$invalidate(0, classes = classnames(className, valid ? `valid-${validMode}` : `invalid-${validMode}`));
      }
    }
  };
  return [classes, $$restProps, className, valid, tooltip, $$scope, slots];
}
var FormFeedback = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance42, create_fragment42, safe_not_equal, { class: 2, valid: 3, tooltip: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FormFeedback",
      options,
      id: create_fragment42.name
    });
  }
  get class() {
    throw new Error("<FormFeedback>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FormFeedback>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valid() {
    throw new Error("<FormFeedback>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valid(value) {
    throw new Error("<FormFeedback>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltip() {
    throw new Error("<FormFeedback>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltip(value) {
    throw new Error("<FormFeedback>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FormFeedback_default = FormFeedback;

// node_modules/@sveltestrap/sveltestrap/dist/FormGroup/FormGroup.svelte
var file42 = "node_modules/@sveltestrap/sveltestrap/dist/FormGroup/FormGroup.svelte";
var get_label_slot_changes_1 = (dirty) => ({});
var get_label_slot_context_1 = (ctx) => ({});
var get_label_slot_changes2 = (dirty) => ({});
var get_label_slot_context2 = (ctx) => ({});
function create_else_block12(ctx) {
  let div;
  let t;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  let if_block = (
    /*label*/
    (ctx[0] || /*$$slots*/
    ctx[4].label) && create_if_block_28(ctx)
  );
  let div_levels = [
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      set_attributes(div, div_data);
      add_location(div, file42, 79, 2, 1635);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_dev(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*label*/
        ctx2[0] || /*$$slots*/
        ctx2[4].label
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*label, $$slots*/
          17) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_28(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block12.name,
    type: "else",
    source: "(79:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block16(ctx) {
  let fieldset;
  let t;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  let if_block = (
    /*label*/
    (ctx[0] || /*$$slots*/
    ctx[4].label) && create_if_block_19(ctx)
  );
  let fieldset_levels = [
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) }
  ];
  let fieldset_data = {};
  for (let i = 0; i < fieldset_levels.length; i += 1) {
    fieldset_data = assign(fieldset_data, fieldset_levels[i]);
  }
  const block = {
    c: function create() {
      fieldset = element("fieldset");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      set_attributes(fieldset, fieldset_data);
      add_location(fieldset, file42, 68, 2, 1373);
    },
    m: function mount(target, anchor) {
      insert_dev(target, fieldset, anchor);
      if (default_slot) {
        default_slot.m(fieldset, null);
      }
      append_dev(fieldset, t);
      if (if_block)
        if_block.m(fieldset, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*label*/
        ctx2[0] || /*$$slots*/
        ctx2[4].label
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*label, $$slots*/
          17) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_19(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(fieldset, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(fieldset, fieldset_data = get_spread_update(fieldset_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(fieldset);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block16.name,
    type: "if",
    source: "(68:0) {#if tag === 'fieldset'}",
    ctx
  });
  return block;
}
function create_if_block_28(ctx) {
  let label_1;
  let t0;
  let t1;
  let current;
  const label_slot_template = (
    /*#slots*/
    ctx[13].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_label_slot_context_1
  );
  const block = {
    c: function create() {
      label_1 = element("label");
      t0 = text(
        /*label*/
        ctx[0]
      );
      t1 = space();
      if (label_slot)
        label_slot.c();
      add_location(label_1, file42, 83, 6, 1789);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label_1, anchor);
      append_dev(label_1, t0);
      append_dev(label_1, t1);
      if (label_slot) {
        label_slot.m(label_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*label*/
      1)
        set_data_dev(
          t0,
          /*label*/
          ctx2[0]
        );
      if (label_slot) {
        if (label_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_label_slot_changes_1
            ),
            get_label_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label_1);
      }
      if (label_slot)
        label_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_28.name,
    type: "if",
    source: "(82:4) {#if label || $$slots.label}",
    ctx
  });
  return block;
}
function create_if_block_19(ctx) {
  let label_1;
  let t0;
  let t1;
  let current;
  const label_slot_template = (
    /*#slots*/
    ctx[13].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_label_slot_context2
  );
  const block = {
    c: function create() {
      label_1 = element("label");
      t0 = text(
        /*label*/
        ctx[0]
      );
      t1 = space();
      if (label_slot)
        label_slot.c();
      add_location(label_1, file42, 72, 6, 1532);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label_1, anchor);
      append_dev(label_1, t0);
      append_dev(label_1, t1);
      if (label_slot) {
        label_slot.m(label_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*label*/
      1)
        set_data_dev(
          t0,
          /*label*/
          ctx2[0]
        );
      if (label_slot) {
        if (label_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_label_slot_changes2
            ),
            get_label_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label_1);
      }
      if (label_slot)
        label_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_19.name,
    type: "if",
    source: "(71:4) {#if label || $$slots.label}",
    ctx
  });
  return block;
}
function create_fragment43(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block16, create_else_block12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*tag*/
      ctx2[1] === "fieldset"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment43.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance43($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "check", "disabled", "floating", "inline", "label", "row", "spacing", "tag"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FormGroup", slots, ["default", "label"]);
  const $$slots = compute_slots(slots);
  let { class: className = "" } = $$props;
  let { check = false } = $$props;
  let { disabled = false } = $$props;
  let { floating = false } = $$props;
  let { inline = false } = $$props;
  let { label = "" } = $$props;
  let { row = false } = $$props;
  let { spacing = "mb-3" } = $$props;
  let { tag = null } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("check" in $$new_props)
      $$invalidate(6, check = $$new_props.check);
    if ("disabled" in $$new_props)
      $$invalidate(7, disabled = $$new_props.disabled);
    if ("floating" in $$new_props)
      $$invalidate(8, floating = $$new_props.floating);
    if ("inline" in $$new_props)
      $$invalidate(9, inline = $$new_props.inline);
    if ("label" in $$new_props)
      $$invalidate(0, label = $$new_props.label);
    if ("row" in $$new_props)
      $$invalidate(10, row = $$new_props.row);
    if ("spacing" in $$new_props)
      $$invalidate(11, spacing = $$new_props.spacing);
    if ("tag" in $$new_props)
      $$invalidate(1, tag = $$new_props.tag);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    check,
    disabled,
    floating,
    inline,
    label,
    row,
    spacing,
    tag,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("check" in $$props)
      $$invalidate(6, check = $$new_props.check);
    if ("disabled" in $$props)
      $$invalidate(7, disabled = $$new_props.disabled);
    if ("floating" in $$props)
      $$invalidate(8, floating = $$new_props.floating);
    if ("inline" in $$props)
      $$invalidate(9, inline = $$new_props.inline);
    if ("label" in $$props)
      $$invalidate(0, label = $$new_props.label);
    if ("row" in $$props)
      $$invalidate(10, row = $$new_props.row);
    if ("spacing" in $$props)
      $$invalidate(11, spacing = $$new_props.spacing);
    if ("tag" in $$props)
      $$invalidate(1, tag = $$new_props.tag);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, spacing, row, check, inline, floating, disabled*/
    4064) {
      $:
        $$invalidate(2, classes = classnames(className, spacing, {
          row,
          "form-check": check,
          "form-check-inline": check && inline,
          "form-floating": floating,
          disabled: check && disabled
        }));
    }
  };
  return [
    label,
    tag,
    classes,
    $$restProps,
    $$slots,
    className,
    check,
    disabled,
    floating,
    inline,
    row,
    spacing,
    $$scope,
    slots
  ];
}
var FormGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance43, create_fragment43, safe_not_equal, {
      class: 5,
      check: 6,
      disabled: 7,
      floating: 8,
      inline: 9,
      label: 0,
      row: 10,
      spacing: 11,
      tag: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FormGroup",
      options,
      id: create_fragment43.name
    });
  }
  get class() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get check() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set check(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get floating() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set floating(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get row() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set row(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FormGroup_default = FormGroup;

// node_modules/@sveltestrap/sveltestrap/dist/FormText/FormText.svelte
var file43 = "node_modules/@sveltestrap/sveltestrap/dist/FormText/FormText.svelte";
function create_fragment44(ctx) {
  let small;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let small_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let small_data = {};
  for (let i = 0; i < small_levels.length; i += 1) {
    small_data = assign(small_data, small_levels[i]);
  }
  const block = {
    c: function create() {
      small = element("small");
      if (default_slot)
        default_slot.c();
      set_attributes(small, small_data);
      add_location(small, file43, 11, 0, 281);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, small, anchor);
      if (default_slot) {
        default_slot.m(small, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(small, small_data = get_spread_update(small_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(small);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment44.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance44($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "inline", "color"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FormText", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { inline = false } = $$props;
  let { color = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("inline" in $$new_props)
      $$invalidate(3, inline = $$new_props.inline);
    if ("color" in $$new_props)
      $$invalidate(4, color = $$new_props.color);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    inline,
    color,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("inline" in $$props)
      $$invalidate(3, inline = $$new_props.inline);
    if ("color" in $$props)
      $$invalidate(4, color = $$new_props.color);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, inline, color*/
    28) {
      $:
        $$invalidate(0, classes = classnames(className, !inline ? "form-text" : false, color ? `text-${color}` : false));
    }
  };
  return [classes, $$restProps, className, inline, color, $$scope, slots];
}
var FormText = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance44, create_fragment44, safe_not_equal, { class: 2, inline: 3, color: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FormText",
      options,
      id: create_fragment44.name
    });
  }
  get class() {
    throw new Error("<FormText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FormText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<FormText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<FormText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<FormText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<FormText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FormText_default = FormText;

// node_modules/@sveltestrap/sveltestrap/dist/Icon/Icon.svelte
var file44 = "node_modules/@sveltestrap/sveltestrap/dist/Icon/Icon.svelte";
function create_fragment45(ctx) {
  let i;
  let i_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let i_data = {};
  for (let i2 = 0; i2 < i_levels.length; i2 += 1) {
    i_data = assign(i_data, i_levels[i2]);
  }
  const block = {
    c: function create() {
      i = element("i");
      set_attributes(i, i_data);
      add_location(i, file44, 21, 0, 376);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, i, anchor);
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(i, i_data = get_spread_update(i_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        dirty & /*classes*/
        1 && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(i);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment45.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance45($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "name"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Icon", slots, []);
  let { class: className = "" } = $$props;
  let { name = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("name" in $$new_props)
      $$invalidate(3, name = $$new_props.name);
  };
  $$self.$capture_state = () => ({ classnames, className, name, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("name" in $$props)
      $$invalidate(3, name = $$new_props.name);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, name*/
    12) {
      $:
        $$invalidate(0, classes = classnames(className, `bi-${name}`));
    }
  };
  return [classes, $$restProps, className, name];
}
var Icon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance45, create_fragment45, safe_not_equal, { class: 2, name: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Icon",
      options,
      id: create_fragment45.name
    });
  }
  get class() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Icon_default = Icon;

// node_modules/@sveltestrap/sveltestrap/dist/Image/Image.svelte
var file45 = "node_modules/@sveltestrap/sveltestrap/dist/Image/Image.svelte";
function create_fragment46(ctx) {
  let img;
  let img_levels = [
    { alt: (
      /*alt*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[3],
    { "data-bs-theme": (
      /*theme*/
      ctx[1]
    ) },
    { class: (
      /*classes*/
      ctx[2]
    ) }
  ];
  let img_data = {};
  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = assign(img_data, img_levels[i]);
  }
  const block = {
    c: function create() {
      img = element("img");
      set_attributes(img, img_data);
      add_location(img, file45, 52, 0, 1021);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(img, img_data = get_spread_update(img_levels, [
        dirty & /*alt*/
        1 && { alt: (
          /*alt*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        dirty & /*theme*/
        2 && { "data-bs-theme": (
          /*theme*/
          ctx2[1]
        ) },
        dirty & /*classes*/
        4 && { class: (
          /*classes*/
          ctx2[2]
        ) }
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(img);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment46.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance46($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "alt", "figure", "fluid", "theme", "thumbnail"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Image", slots, []);
  let { class: className = "" } = $$props;
  let { alt = void 0 } = $$props;
  let { figure = getContext("figure") } = $$props;
  let { fluid = false } = $$props;
  let { theme = null } = $$props;
  let { thumbnail = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("alt" in $$new_props)
      $$invalidate(0, alt = $$new_props.alt);
    if ("figure" in $$new_props)
      $$invalidate(5, figure = $$new_props.figure);
    if ("fluid" in $$new_props)
      $$invalidate(6, fluid = $$new_props.fluid);
    if ("theme" in $$new_props)
      $$invalidate(1, theme = $$new_props.theme);
    if ("thumbnail" in $$new_props)
      $$invalidate(7, thumbnail = $$new_props.thumbnail);
  };
  $$self.$capture_state = () => ({
    getContext,
    classnames,
    className,
    alt,
    figure,
    fluid,
    theme,
    thumbnail,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("alt" in $$props)
      $$invalidate(0, alt = $$new_props.alt);
    if ("figure" in $$props)
      $$invalidate(5, figure = $$new_props.figure);
    if ("fluid" in $$props)
      $$invalidate(6, fluid = $$new_props.fluid);
    if ("theme" in $$props)
      $$invalidate(1, theme = $$new_props.theme);
    if ("thumbnail" in $$props)
      $$invalidate(7, thumbnail = $$new_props.thumbnail);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, figure, fluid, thumbnail*/
    240) {
      $:
        $$invalidate(2, classes = classnames(className, {
          "figure-img": figure,
          "img-fluid": fluid,
          "img-thumbnail": thumbnail
        }));
    }
  };
  return [alt, theme, classes, $$restProps, className, figure, fluid, thumbnail];
}
var Image = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance46, create_fragment46, safe_not_equal, {
      class: 4,
      alt: 0,
      figure: 5,
      fluid: 6,
      theme: 1,
      thumbnail: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Image",
      options,
      id: create_fragment46.name
    });
  }
  get class() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get figure() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set figure(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fluid() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fluid(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get thumbnail() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set thumbnail(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Image_default = Image;

// node_modules/@sveltestrap/sveltestrap/dist/InlineContainer/InlineContainer.svelte
var file46 = "node_modules/@sveltestrap/sveltestrap/dist/InlineContainer/InlineContainer.svelte";
function create_fragment47(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      add_location(div, file46, 4, 0, 68);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment47.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance47($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InlineContainer", slots, ["default"]);
  let x = "wtf svelte?";
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<InlineContainer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ x });
  $$self.$inject_state = ($$props2) => {
    if ("x" in $$props2)
      x = $$props2.x;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [$$scope, slots];
}
var InlineContainer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance47, create_fragment47, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InlineContainer",
      options,
      id: create_fragment47.name
    });
  }
};
var InlineContainer_default = InlineContainer;

// node_modules/@sveltestrap/sveltestrap/dist/Input/Input.svelte
var file47 = "node_modules/@sveltestrap/sveltestrap/dist/Input/Input.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[130] = list[i];
  return child_ctx;
}
function create_if_block_10(ctx) {
  let select;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[28].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[129],
    null
  );
  let select_levels = [
    /*$$restProps*/
    ctx[25],
    { "data-bs-theme": (
      /*theme*/
      ctx[19]
    ) },
    { class: (
      /*classes*/
      ctx[23]
    ) },
    { name: (
      /*name*/
      ctx[15]
    ) },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { readonly: (
      /*readonly*/
      ctx[17]
    ) }
  ];
  let select_data = {};
  for (let i = 0; i < select_levels.length; i += 1) {
    select_data = assign(select_data, select_levels[i]);
  }
  const block = {
    c: function create() {
      select = element("select");
      if (default_slot)
        default_slot.c();
      set_attributes(select, select_data);
      if (
        /*value*/
        ctx[6] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[127].call(select)
        ));
      add_location(select, file47, 445, 2, 9199);
    },
    m: function mount(target, anchor) {
      insert_dev(target, select, anchor);
      if (default_slot) {
        default_slot.m(select, null);
      }
      "value" in select_data && (select_data.multiple ? select_options : select_option)(select, select_data.value);
      if (select.autofocus)
        select.focus();
      select_option(
        select,
        /*value*/
        ctx[6],
        true
      );
      ctx[128](select);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            select,
            "change",
            /*select_change_handler*/
            ctx[127]
          ),
          listen_dev(
            select,
            "blur",
            /*blur_handler_8*/
            ctx[97],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "click",
            /*click_handler_7*/
            ctx[98],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "change",
            /*change_handler_7*/
            ctx[99],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "focus",
            /*focus_handler_8*/
            ctx[100],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "input",
            /*input_handler_7*/
            ctx[101],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[4] & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[129],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[129]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[129],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(select, select_data = get_spread_update(select_levels, [
        dirty[0] & /*$$restProps*/
        33554432 && /*$$restProps*/
        ctx2[25],
        (!current || dirty[0] & /*theme*/
        524288) && { "data-bs-theme": (
          /*theme*/
          ctx2[19]
        ) },
        (!current || dirty[0] & /*classes*/
        8388608) && { class: (
          /*classes*/
          ctx2[23]
        ) },
        (!current || dirty[0] & /*name*/
        32768) && { name: (
          /*name*/
          ctx2[15]
        ) },
        (!current || dirty[0] & /*disabled*/
        256) && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        (!current || dirty[0] & /*readonly*/
        131072) && { readonly: (
          /*readonly*/
          ctx2[17]
        ) }
      ]));
      if (dirty[0] & /*$$restProps, theme, classes, name, disabled, readonly*/
      42631424 && "value" in select_data)
        (select_data.multiple ? select_options : select_option)(select, select_data.value);
      if (dirty[0] & /*value*/
      64) {
        select_option(
          select,
          /*value*/
          ctx2[6]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(select);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[128](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(445:40) ",
    ctx
  });
  return block;
}
function create_if_block_9(ctx) {
  let textarea;
  let mounted;
  let dispose;
  let textarea_levels = [
    /*$$restProps*/
    ctx[25],
    { "data-bs-theme": (
      /*theme*/
      ctx[19]
    ) },
    { class: (
      /*classes*/
      ctx[23]
    ) },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { name: (
      /*name*/
      ctx[15]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[16]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[17]
    ) }
  ];
  let textarea_data = {};
  for (let i = 0; i < textarea_levels.length; i += 1) {
    textarea_data = assign(textarea_data, textarea_levels[i]);
  }
  const block = {
    c: function create() {
      textarea = element("textarea");
      set_attributes(textarea, textarea_data);
      add_location(textarea, file47, 423, 2, 8837);
    },
    m: function mount(target, anchor) {
      insert_dev(target, textarea, anchor);
      if (textarea.autofocus)
        textarea.focus();
      set_input_value(
        textarea,
        /*value*/
        ctx[6]
      );
      ctx[126](textarea);
      if (!mounted) {
        dispose = [
          listen_dev(
            textarea,
            "input",
            /*textarea_input_handler*/
            ctx[125]
          ),
          listen_dev(
            textarea,
            "blur",
            /*blur_handler_7*/
            ctx[87],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "change",
            /*change_handler_6*/
            ctx[88],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "click",
            /*click_handler_6*/
            ctx[89],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "focus",
            /*focus_handler_7*/
            ctx[90],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "input",
            /*input_handler_6*/
            ctx[91],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "keydown",
            /*keydown_handler_7*/
            ctx[92],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "keypress",
            /*keypress_handler_7*/
            ctx[93],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "keyup",
            /*keyup_handler_7*/
            ctx[94],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "mousedown",
            /*mousedown_handler_7*/
            ctx[95],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            textarea,
            "mouseup",
            /*mouseup_handler_7*/
            ctx[96],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
        dirty[0] & /*$$restProps*/
        33554432 && /*$$restProps*/
        ctx2[25],
        dirty[0] & /*theme*/
        524288 && { "data-bs-theme": (
          /*theme*/
          ctx2[19]
        ) },
        dirty[0] & /*classes*/
        8388608 && { class: (
          /*classes*/
          ctx2[23]
        ) },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*name*/
        32768 && { name: (
          /*name*/
          ctx2[15]
        ) },
        dirty[0] & /*placeholder*/
        65536 && { placeholder: (
          /*placeholder*/
          ctx2[16]
        ) },
        dirty[0] & /*readonly*/
        131072 && { readOnly: (
          /*readonly*/
          ctx2[17]
        ) }
      ]));
      if (dirty[0] & /*value*/
      64) {
        set_input_value(
          textarea,
          /*value*/
          ctx2[6]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(textarea);
      }
      ctx[126](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(423:29) ",
    ctx
  });
  return block;
}
function create_if_block_29(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block_34,
    create_if_block_43,
    create_if_block_5,
    create_if_block_6,
    create_if_block_7,
    create_if_block_8,
    create_else_block_13
  ];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*type*/
      ctx2[20] === "text" || /*type*/
      ctx2[20] === "password" || /*type*/
      ctx2[20] === "search" || /*type*/
      ctx2[20] === "tel" || /*type*/
      ctx2[20] === "url"
    )
      return 0;
    if (
      /*type*/
      ctx2[20] === "color"
    )
      return 1;
    if (
      /*type*/
      ctx2[20] === "email"
    )
      return 2;
    if (
      /*type*/
      ctx2[20] === "file"
    )
      return 3;
    if (
      /*type*/
      ctx2[20] === "checkbox" || /*type*/
      ctx2[20] === "radio" || /*type*/
      ctx2[20] === "switch"
    )
      return 4;
    if (
      /*type*/
      ctx2[20] === "date" || /*type*/
      ctx2[20] === "datetime" || /*type*/
      ctx2[20] === "datetime-local" || /*type*/
      ctx2[20] === "month" || /*type*/
      ctx2[20] === "number" || /*type*/
      ctx2[20] === "time" || /*type*/
      ctx2[20] === "range" || /*type*/
      ctx2[20] === "week"
    )
      return 5;
    return 6;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_29.name,
    type: "if",
    source: "(246:0) {#if tag === 'input'}",
    ctx
  });
  return block;
}
function create_else_block_13(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[25],
    { "data-bs-theme": (
      /*theme*/
      ctx[19]
    ) },
    { class: (
      /*classes*/
      ctx[23]
    ) },
    { type: (
      /*type*/
      ctx[20]
    ) },
    { name: (
      /*name*/
      ctx[15]
    ) },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[16]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[17]
    ) },
    { value: (
      /*value*/
      ctx[6]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file47, 400, 4, 8427);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if ("value" in input_data) {
        input.value = input_data.value;
      }
      if (input.autofocus)
        input.focus();
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "blur",
            /*blur_handler_6*/
            ctx[79],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*handleInput*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "click",
            /*click_handler_5*/
            ctx[80],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_6*/
            ctx[81],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*handleInput*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_6*/
            ctx[82],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler_6*/
            ctx[83],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_6*/
            ctx[84],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "mousedown",
            /*mousedown_handler_6*/
            ctx[85],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "mouseup",
            /*mouseup_handler_6*/
            ctx[86],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        33554432 && /*$$restProps*/
        ctx2[25],
        dirty[0] & /*theme*/
        524288 && { "data-bs-theme": (
          /*theme*/
          ctx2[19]
        ) },
        dirty[0] & /*classes*/
        8388608 && { class: (
          /*classes*/
          ctx2[23]
        ) },
        dirty[0] & /*type*/
        1048576 && { type: (
          /*type*/
          ctx2[20]
        ) },
        dirty[0] & /*name*/
        32768 && { name: (
          /*name*/
          ctx2[15]
        ) },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*placeholder*/
        65536 && { placeholder: (
          /*placeholder*/
          ctx2[16]
        ) },
        dirty[0] & /*readonly*/
        131072 && { readOnly: (
          /*readonly*/
          ctx2[17]
        ) },
        dirty[0] & /*value*/
        64 && input.value !== /*value*/
        ctx2[6] && { value: (
          /*value*/
          ctx2[6]
        ) }
      ]));
      if ("value" in input_data) {
        input.value = input_data.value;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_13.name,
    type: "else",
    source: "(400:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[25],
    { type: (
      /*type*/
      ctx[20]
    ) },
    { "data-bs-theme": (
      /*theme*/
      ctx[19]
    ) },
    { class: (
      /*classes*/
      ctx[23]
    ) },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { max: (
      /*max*/
      ctx[12]
    ) },
    { min: (
      /*min*/
      ctx[13]
    ) },
    { name: (
      /*name*/
      ctx[15]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[16]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[17]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file47, 375, 4, 8013);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[6]
      );
      ctx[124](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler_3*/
            ctx[123]
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler_5*/
            ctx[69],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_5*/
            ctx[70],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "click",
            /*click_handler_4*/
            ctx[71],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_5*/
            ctx[72],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_5*/
            ctx[73],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_5*/
            ctx[74],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler_5*/
            ctx[75],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_5*/
            ctx[76],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "mousedown",
            /*mousedown_handler_5*/
            ctx[77],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "mouseup",
            /*mouseup_handler_5*/
            ctx[78],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        33554432 && /*$$restProps*/
        ctx2[25],
        dirty[0] & /*type*/
        1048576 && { type: (
          /*type*/
          ctx2[20]
        ) },
        dirty[0] & /*theme*/
        524288 && { "data-bs-theme": (
          /*theme*/
          ctx2[19]
        ) },
        dirty[0] & /*classes*/
        8388608 && { class: (
          /*classes*/
          ctx2[23]
        ) },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*max*/
        4096 && { max: (
          /*max*/
          ctx2[12]
        ) },
        dirty[0] & /*min*/
        8192 && { min: (
          /*min*/
          ctx2[13]
        ) },
        dirty[0] & /*name*/
        32768 && { name: (
          /*name*/
          ctx2[15]
        ) },
        dirty[0] & /*placeholder*/
        65536 && { placeholder: (
          /*placeholder*/
          ctx2[16]
        ) },
        dirty[0] & /*readonly*/
        131072 && { readOnly: (
          /*readonly*/
          ctx2[17]
        ) }
      ]));
      if (dirty[0] & /*value*/
      64 && input.value !== /*value*/
      ctx2[6]) {
        set_input_value(
          input,
          /*value*/
          ctx2[6]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      ctx[124](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(375:179) ",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let formcheck;
  let updating_checked;
  let updating_inner;
  let updating_group;
  let updating_value;
  let current;
  const formcheck_spread_levels = [
    /*$$restProps*/
    ctx[25],
    { "data-bs-theme": (
      /*theme*/
      ctx[19]
    ) },
    { class: (
      /*className*/
      ctx[7]
    ) },
    { size: (
      /*bsSize*/
      ctx[0]
    ) },
    { type: (
      /*type*/
      ctx[20]
    ) },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { invalid: (
      /*invalid*/
      ctx[10]
    ) },
    { label: (
      /*label*/
      ctx[11]
    ) },
    { name: (
      /*name*/
      ctx[15]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[16]
    ) },
    { reverse: (
      /*reverse*/
      ctx[18]
    ) },
    { readonly: (
      /*readonly*/
      ctx[17]
    ) },
    { valid: (
      /*valid*/
      ctx[21]
    ) }
  ];
  function formcheck_checked_binding(value) {
    ctx[110](value);
  }
  function formcheck_inner_binding(value) {
    ctx[111](value);
  }
  function formcheck_group_binding(value) {
    ctx[112](value);
  }
  function formcheck_value_binding(value) {
    ctx[113](value);
  }
  let formcheck_props = {};
  for (let i = 0; i < formcheck_spread_levels.length; i += 1) {
    formcheck_props = assign(formcheck_props, formcheck_spread_levels[i]);
  }
  if (
    /*checked*/
    ctx[2] !== void 0
  ) {
    formcheck_props.checked = /*checked*/
    ctx[2];
  }
  if (
    /*inner*/
    ctx[5] !== void 0
  ) {
    formcheck_props.inner = /*inner*/
    ctx[5];
  }
  if (
    /*group*/
    ctx[4] !== void 0
  ) {
    formcheck_props.group = /*group*/
    ctx[4];
  }
  if (
    /*value*/
    ctx[6] !== void 0
  ) {
    formcheck_props.value = /*value*/
    ctx[6];
  }
  formcheck = new FormCheck_default({ props: formcheck_props, $$inline: true });
  binding_callbacks.push(() => bind(formcheck, "checked", formcheck_checked_binding));
  binding_callbacks.push(() => bind(formcheck, "inner", formcheck_inner_binding));
  binding_callbacks.push(() => bind(formcheck, "group", formcheck_group_binding));
  binding_callbacks.push(() => bind(formcheck, "value", formcheck_value_binding));
  formcheck.$on(
    "blur",
    /*blur_handler_4*/
    ctx[114]
  );
  formcheck.$on(
    "change",
    /*change_handler_4*/
    ctx[115]
  );
  formcheck.$on(
    "focus",
    /*focus_handler_4*/
    ctx[116]
  );
  formcheck.$on(
    "input",
    /*input_handler_4*/
    ctx[117]
  );
  formcheck.$on(
    "keydown",
    /*keydown_handler_4*/
    ctx[118]
  );
  formcheck.$on(
    "keypress",
    /*keypress_handler_4*/
    ctx[119]
  );
  formcheck.$on(
    "keyup",
    /*keyup_handler_4*/
    ctx[120]
  );
  formcheck.$on(
    "mousedown",
    /*mousedown_handler_4*/
    ctx[121]
  );
  formcheck.$on(
    "mouseup",
    /*mouseup_handler_4*/
    ctx[122]
  );
  const block = {
    c: function create() {
      create_component(formcheck.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(formcheck, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const formcheck_changes = dirty[0] & /*$$restProps, theme, className, bsSize, type, disabled, invalid, label, name, placeholder, reverse, readonly, valid*/
      37719425 ? get_spread_update(formcheck_spread_levels, [
        dirty[0] & /*$$restProps*/
        33554432 && get_spread_object(
          /*$$restProps*/
          ctx2[25]
        ),
        dirty[0] & /*theme*/
        524288 && { "data-bs-theme": (
          /*theme*/
          ctx2[19]
        ) },
        dirty[0] & /*className*/
        128 && { class: (
          /*className*/
          ctx2[7]
        ) },
        dirty[0] & /*bsSize*/
        1 && { size: (
          /*bsSize*/
          ctx2[0]
        ) },
        dirty[0] & /*type*/
        1048576 && { type: (
          /*type*/
          ctx2[20]
        ) },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*invalid*/
        1024 && { invalid: (
          /*invalid*/
          ctx2[10]
        ) },
        dirty[0] & /*label*/
        2048 && { label: (
          /*label*/
          ctx2[11]
        ) },
        dirty[0] & /*name*/
        32768 && { name: (
          /*name*/
          ctx2[15]
        ) },
        dirty[0] & /*placeholder*/
        65536 && { placeholder: (
          /*placeholder*/
          ctx2[16]
        ) },
        dirty[0] & /*reverse*/
        262144 && { reverse: (
          /*reverse*/
          ctx2[18]
        ) },
        dirty[0] & /*readonly*/
        131072 && { readonly: (
          /*readonly*/
          ctx2[17]
        ) },
        dirty[0] & /*valid*/
        2097152 && { valid: (
          /*valid*/
          ctx2[21]
        ) }
      ]) : {};
      if (!updating_checked && dirty[0] & /*checked*/
      4) {
        updating_checked = true;
        formcheck_changes.checked = /*checked*/
        ctx2[2];
        add_flush_callback(() => updating_checked = false);
      }
      if (!updating_inner && dirty[0] & /*inner*/
      32) {
        updating_inner = true;
        formcheck_changes.inner = /*inner*/
        ctx2[5];
        add_flush_callback(() => updating_inner = false);
      }
      if (!updating_group && dirty[0] & /*group*/
      16) {
        updating_group = true;
        formcheck_changes.group = /*group*/
        ctx2[4];
        add_flush_callback(() => updating_group = false);
      }
      if (!updating_value && dirty[0] & /*value*/
      64) {
        updating_value = true;
        formcheck_changes.value = /*value*/
        ctx2[6];
        add_flush_callback(() => updating_value = false);
      }
      formcheck.$set(formcheck_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(formcheck.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(formcheck.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(formcheck, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(346:73) ",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[25],
    { "data-bs-theme": (
      /*theme*/
      ctx[19]
    ) },
    { class: (
      /*classes*/
      ctx[23]
    ) },
    { type: "file" },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { invalid: (
      /*invalid*/
      ctx[10]
    ) },
    { multiple: (
      /*multiple*/
      ctx[14]
    ) },
    { name: (
      /*name*/
      ctx[15]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[16]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[17]
    ) },
    { valid: (
      /*valid*/
      ctx[21]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file47, 319, 4, 6844);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      ctx[109](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[108]
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler_3*/
            ctx[59],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_3*/
            ctx[60],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "click",
            /*click_handler_3*/
            ctx[61],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_3*/
            ctx[62],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_3*/
            ctx[63],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_3*/
            ctx[64],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler_3*/
            ctx[65],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_3*/
            ctx[66],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "mousedown",
            /*mousedown_handler_3*/
            ctx[67],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "mouseup",
            /*mouseup_handler_3*/
            ctx[68],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        33554432 && /*$$restProps*/
        ctx2[25],
        dirty[0] & /*theme*/
        524288 && { "data-bs-theme": (
          /*theme*/
          ctx2[19]
        ) },
        dirty[0] & /*classes*/
        8388608 && { class: (
          /*classes*/
          ctx2[23]
        ) },
        { type: "file" },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*invalid*/
        1024 && { invalid: (
          /*invalid*/
          ctx2[10]
        ) },
        dirty[0] & /*multiple*/
        16384 && { multiple: (
          /*multiple*/
          ctx2[14]
        ) },
        dirty[0] & /*name*/
        32768 && { name: (
          /*name*/
          ctx2[15]
        ) },
        dirty[0] & /*placeholder*/
        65536 && { placeholder: (
          /*placeholder*/
          ctx2[16]
        ) },
        dirty[0] & /*readonly*/
        131072 && { readOnly: (
          /*readonly*/
          ctx2[17]
        ) },
        dirty[0] & /*valid*/
        2097152 && { valid: (
          /*valid*/
          ctx2[21]
        ) }
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      ctx[109](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(319:28) ",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[25],
    { "data-bs-theme": (
      /*theme*/
      ctx[19]
    ) },
    { class: (
      /*classes*/
      ctx[23]
    ) },
    { type: "email" },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { multiple: (
      /*multiple*/
      ctx[14]
    ) },
    { name: (
      /*name*/
      ctx[15]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[16]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[17]
    ) },
    { size: (
      /*size*/
      ctx[1]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file47, 294, 4, 6406);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[6]
      );
      ctx[107](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler_2*/
            ctx[106]
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler_2*/
            ctx[49],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_2*/
            ctx[50],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "click",
            /*click_handler_2*/
            ctx[51],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_2*/
            ctx[52],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_2*/
            ctx[53],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_2*/
            ctx[54],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler_2*/
            ctx[55],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_2*/
            ctx[56],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "mousedown",
            /*mousedown_handler_2*/
            ctx[57],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "mouseup",
            /*mouseup_handler_2*/
            ctx[58],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        33554432 && /*$$restProps*/
        ctx2[25],
        dirty[0] & /*theme*/
        524288 && { "data-bs-theme": (
          /*theme*/
          ctx2[19]
        ) },
        dirty[0] & /*classes*/
        8388608 && { class: (
          /*classes*/
          ctx2[23]
        ) },
        { type: "email" },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*multiple*/
        16384 && { multiple: (
          /*multiple*/
          ctx2[14]
        ) },
        dirty[0] & /*name*/
        32768 && { name: (
          /*name*/
          ctx2[15]
        ) },
        dirty[0] & /*placeholder*/
        65536 && { placeholder: (
          /*placeholder*/
          ctx2[16]
        ) },
        dirty[0] & /*readonly*/
        131072 && { readOnly: (
          /*readonly*/
          ctx2[17]
        ) },
        dirty[0] & /*size*/
        2 && { size: (
          /*size*/
          ctx2[1]
        ) }
      ]));
      if (dirty[0] & /*value*/
      64 && input.value !== /*value*/
      ctx2[6]) {
        set_input_value(
          input,
          /*value*/
          ctx2[6]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      ctx[107](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(294:29) ",
    ctx
  });
  return block;
}
function create_if_block_43(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[25],
    { "data-bs-theme": (
      /*theme*/
      ctx[19]
    ) },
    { class: (
      /*classes*/
      ctx[23]
    ) },
    { type: "color" },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { name: (
      /*name*/
      ctx[15]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[16]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[17]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file47, 271, 4, 5997);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[6]
      );
      ctx[105](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler_1*/
            ctx[104]
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler_1*/
            ctx[39],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_1*/
            ctx[40],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "click",
            /*click_handler_1*/
            ctx[41],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler_1*/
            ctx[42],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler_1*/
            ctx[43],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler_1*/
            ctx[44],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler_1*/
            ctx[45],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_1*/
            ctx[46],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "mousedown",
            /*mousedown_handler_1*/
            ctx[47],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "mouseup",
            /*mouseup_handler_1*/
            ctx[48],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        33554432 && /*$$restProps*/
        ctx2[25],
        dirty[0] & /*theme*/
        524288 && { "data-bs-theme": (
          /*theme*/
          ctx2[19]
        ) },
        dirty[0] & /*classes*/
        8388608 && { class: (
          /*classes*/
          ctx2[23]
        ) },
        { type: "color" },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*name*/
        32768 && { name: (
          /*name*/
          ctx2[15]
        ) },
        dirty[0] & /*placeholder*/
        65536 && { placeholder: (
          /*placeholder*/
          ctx2[16]
        ) },
        dirty[0] & /*readonly*/
        131072 && { readOnly: (
          /*readonly*/
          ctx2[17]
        ) }
      ]));
      if (dirty[0] & /*value*/
      64) {
        set_input_value(
          input,
          /*value*/
          ctx2[6]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      ctx[105](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_43.name,
    type: "if",
    source: "(271:29) ",
    ctx
  });
  return block;
}
function create_if_block_34(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    /*$$restProps*/
    ctx[25],
    { type: (
      /*type*/
      ctx[20]
    ) },
    { "data-bs-theme": (
      /*theme*/
      ctx[19]
    ) },
    { class: (
      /*classes*/
      ctx[23]
    ) },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { name: (
      /*name*/
      ctx[15]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[16]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[17]
    ) },
    { size: (
      /*size*/
      ctx[1]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file47, 247, 4, 5574);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[6]
      );
      ctx[103](input);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[102]
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[29],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[30],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "click",
            /*click_handler*/
            ctx[31],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[32],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[33],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler*/
            ctx[34],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler*/
            ctx[35],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler*/
            ctx[36],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "mousedown",
            /*mousedown_handler*/
            ctx[37],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "mouseup",
            /*mouseup_handler*/
            ctx[38],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*$$restProps*/
        33554432 && /*$$restProps*/
        ctx2[25],
        dirty[0] & /*type*/
        1048576 && { type: (
          /*type*/
          ctx2[20]
        ) },
        dirty[0] & /*theme*/
        524288 && { "data-bs-theme": (
          /*theme*/
          ctx2[19]
        ) },
        dirty[0] & /*classes*/
        8388608 && { class: (
          /*classes*/
          ctx2[23]
        ) },
        dirty[0] & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        dirty[0] & /*name*/
        32768 && { name: (
          /*name*/
          ctx2[15]
        ) },
        dirty[0] & /*placeholder*/
        65536 && { placeholder: (
          /*placeholder*/
          ctx2[16]
        ) },
        dirty[0] & /*readonly*/
        131072 && { readOnly: (
          /*readonly*/
          ctx2[17]
        ) },
        dirty[0] & /*size*/
        2 && { size: (
          /*size*/
          ctx2[1]
        ) }
      ]));
      if (dirty[0] & /*value*/
      64 && input.value !== /*value*/
      ctx2[6]) {
        set_input_value(
          input,
          /*value*/
          ctx2[6]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      ctx[103](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_34.name,
    type: "if",
    source: "(247:2) {#if type === 'text' || type === 'password' || type === 'search' || type === 'tel' || type === 'url'}",
    ctx
  });
  return block;
}
function create_if_block17(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_110, create_else_block13];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (dirty[0] & /*feedback*/
    512)
      show_if = null;
    if (show_if == null)
      show_if = !!Array.isArray(
        /*feedback*/
        ctx2[9]
      );
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, [-1, -1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block17.name,
    type: "if",
    source: "(465:0) {#if feedback}",
    ctx
  });
  return block;
}
function create_else_block13(ctx) {
  let formfeedback;
  let current;
  formfeedback = new FormFeedback_default({
    props: {
      valid: (
        /*valid*/
        ctx[21]
      ),
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(formfeedback.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(formfeedback, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const formfeedback_changes = {};
      if (dirty[0] & /*valid*/
      2097152)
        formfeedback_changes.valid = /*valid*/
        ctx2[21];
      if (dirty[0] & /*feedback*/
      512 | dirty[4] & /*$$scope*/
      32) {
        formfeedback_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formfeedback.$set(formfeedback_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(formfeedback.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(formfeedback.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(formfeedback, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block13.name,
    type: "else",
    source: "(470:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_110(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*feedback*/
    ctx[9]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*valid, feedback*/
      2097664) {
        each_value = ensure_array_like_dev(
          /*feedback*/
          ctx2[9]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_110.name,
    type: "if",
    source: "(466:2) {#if Array.isArray(feedback)}",
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*feedback*/
        ctx[9]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*feedback*/
      512)
        set_data_dev(
          t,
          /*feedback*/
          ctx2[9]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: "(471:4) <FormFeedback {valid}>",
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let t_value = (
    /*msg*/
    ctx[130] + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*feedback*/
      512 && t_value !== (t_value = /*msg*/
      ctx2[130] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(468:6) <FormFeedback {valid}>",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let formfeedback;
  let current;
  formfeedback = new FormFeedback_default({
    props: {
      valid: (
        /*valid*/
        ctx[21]
      ),
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(formfeedback.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(formfeedback, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const formfeedback_changes = {};
      if (dirty[0] & /*valid*/
      2097152)
        formfeedback_changes.valid = /*valid*/
        ctx2[21];
      if (dirty[0] & /*feedback*/
      512 | dirty[4] & /*$$scope*/
      32) {
        formfeedback_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formfeedback.$set(formfeedback_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(formfeedback.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(formfeedback.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(formfeedback, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(467:4) {#each feedback as msg}",
    ctx
  });
  return block;
}
function create_fragment48(ctx) {
  let current_block_type_index;
  let if_block0;
  let t;
  let if_block1_anchor;
  let current;
  const if_block_creators = [create_if_block_29, create_if_block_9, create_if_block_10];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*tag*/
      ctx2[22] === "input"
    )
      return 0;
    if (
      /*tag*/
      ctx2[22] === "textarea"
    )
      return 1;
    if (
      /*tag*/
      ctx2[22] === "select" && !/*multiple*/
      ctx2[14]
    )
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, [-1, -1, -1, -1, -1]))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = (
    /*feedback*/
    ctx[9] && create_if_block17(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        } else {
          if_block0 = null;
        }
      }
      if (
        /*feedback*/
        ctx2[9]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*feedback*/
          512) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block17(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(if_block1_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (if_block1)
        if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment48.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance48($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "class",
    "bsSize",
    "checked",
    "color",
    "disabled",
    "feedback",
    "files",
    "group",
    "inner",
    "invalid",
    "label",
    "max",
    "min",
    "multiple",
    "name",
    "placeholder",
    "plaintext",
    "readonly",
    "reverse",
    "size",
    "theme",
    "type",
    "valid",
    "value"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Input", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { bsSize = void 0 } = $$props;
  let { checked = false } = $$props;
  let { color = void 0 } = $$props;
  let { disabled = void 0 } = $$props;
  let { feedback = void 0 } = $$props;
  let { files = void 0 } = $$props;
  let { group = void 0 } = $$props;
  let { inner = void 0 } = $$props;
  let { invalid = false } = $$props;
  let { label = void 0 } = $$props;
  let { max: max2 = void 0 } = $$props;
  let { min: min2 = void 0 } = $$props;
  let { multiple = void 0 } = $$props;
  let { name = "" } = $$props;
  let { placeholder = "" } = $$props;
  let { plaintext = false } = $$props;
  let { readonly = void 0 } = $$props;
  let { reverse = false } = $$props;
  let { size = void 0 } = $$props;
  let { theme = void 0 } = $$props;
  let { type = "text" } = $$props;
  let { valid = false } = $$props;
  let { value = void 0 } = $$props;
  let classes;
  let tag;
  const handleInput = (event) => {
    $$invalidate(6, value = event.target.value);
  };
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function mouseup_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function mouseup_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function mouseup_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function mouseup_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function mouseup_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_7(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_7(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_7(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_7(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_7(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_7(event) {
    bubble.call(this, $$self, event);
  }
  function mouseup_handler_7(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_8(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_7(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_7(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_8(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_7(event) {
    bubble.call(this, $$self, event);
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_1() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_2() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_change_handler() {
    files = this.files;
    value = this.value;
    $$invalidate(3, files);
    $$invalidate(6, value);
  }
  function input_binding_3($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function formcheck_checked_binding(value2) {
    checked = value2;
    $$invalidate(2, checked);
  }
  function formcheck_inner_binding(value2) {
    inner = value2;
    $$invalidate(5, inner);
  }
  function formcheck_group_binding(value2) {
    group = value2;
    $$invalidate(4, group);
  }
  function formcheck_value_binding(value$1) {
    value = value$1;
    $$invalidate(6, value);
  }
  function blur_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function mouseup_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function input_input_handler_3() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_4($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function textarea_input_handler() {
    value = this.value;
    $$invalidate(6, value);
  }
  function textarea_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function select_change_handler() {
    value = select_value(this);
    $$invalidate(6, value);
  }
  function select_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(25, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(7, className = $$new_props.class);
    if ("bsSize" in $$new_props)
      $$invalidate(0, bsSize = $$new_props.bsSize);
    if ("checked" in $$new_props)
      $$invalidate(2, checked = $$new_props.checked);
    if ("color" in $$new_props)
      $$invalidate(26, color = $$new_props.color);
    if ("disabled" in $$new_props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("feedback" in $$new_props)
      $$invalidate(9, feedback = $$new_props.feedback);
    if ("files" in $$new_props)
      $$invalidate(3, files = $$new_props.files);
    if ("group" in $$new_props)
      $$invalidate(4, group = $$new_props.group);
    if ("inner" in $$new_props)
      $$invalidate(5, inner = $$new_props.inner);
    if ("invalid" in $$new_props)
      $$invalidate(10, invalid = $$new_props.invalid);
    if ("label" in $$new_props)
      $$invalidate(11, label = $$new_props.label);
    if ("max" in $$new_props)
      $$invalidate(12, max2 = $$new_props.max);
    if ("min" in $$new_props)
      $$invalidate(13, min2 = $$new_props.min);
    if ("multiple" in $$new_props)
      $$invalidate(14, multiple = $$new_props.multiple);
    if ("name" in $$new_props)
      $$invalidate(15, name = $$new_props.name);
    if ("placeholder" in $$new_props)
      $$invalidate(16, placeholder = $$new_props.placeholder);
    if ("plaintext" in $$new_props)
      $$invalidate(27, plaintext = $$new_props.plaintext);
    if ("readonly" in $$new_props)
      $$invalidate(17, readonly = $$new_props.readonly);
    if ("reverse" in $$new_props)
      $$invalidate(18, reverse = $$new_props.reverse);
    if ("size" in $$new_props)
      $$invalidate(1, size = $$new_props.size);
    if ("theme" in $$new_props)
      $$invalidate(19, theme = $$new_props.theme);
    if ("type" in $$new_props)
      $$invalidate(20, type = $$new_props.type);
    if ("valid" in $$new_props)
      $$invalidate(21, valid = $$new_props.valid);
    if ("value" in $$new_props)
      $$invalidate(6, value = $$new_props.value);
    if ("$$scope" in $$new_props)
      $$invalidate(129, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    FormCheck: FormCheck_default,
    FormFeedback: FormFeedback_default,
    classnames,
    className,
    bsSize,
    checked,
    color,
    disabled,
    feedback,
    files,
    group,
    inner,
    invalid,
    label,
    max: max2,
    min: min2,
    multiple,
    name,
    placeholder,
    plaintext,
    readonly,
    reverse,
    size,
    theme,
    type,
    valid,
    value,
    classes,
    tag,
    handleInput
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(7, className = $$new_props.className);
    if ("bsSize" in $$props)
      $$invalidate(0, bsSize = $$new_props.bsSize);
    if ("checked" in $$props)
      $$invalidate(2, checked = $$new_props.checked);
    if ("color" in $$props)
      $$invalidate(26, color = $$new_props.color);
    if ("disabled" in $$props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("feedback" in $$props)
      $$invalidate(9, feedback = $$new_props.feedback);
    if ("files" in $$props)
      $$invalidate(3, files = $$new_props.files);
    if ("group" in $$props)
      $$invalidate(4, group = $$new_props.group);
    if ("inner" in $$props)
      $$invalidate(5, inner = $$new_props.inner);
    if ("invalid" in $$props)
      $$invalidate(10, invalid = $$new_props.invalid);
    if ("label" in $$props)
      $$invalidate(11, label = $$new_props.label);
    if ("max" in $$props)
      $$invalidate(12, max2 = $$new_props.max);
    if ("min" in $$props)
      $$invalidate(13, min2 = $$new_props.min);
    if ("multiple" in $$props)
      $$invalidate(14, multiple = $$new_props.multiple);
    if ("name" in $$props)
      $$invalidate(15, name = $$new_props.name);
    if ("placeholder" in $$props)
      $$invalidate(16, placeholder = $$new_props.placeholder);
    if ("plaintext" in $$props)
      $$invalidate(27, plaintext = $$new_props.plaintext);
    if ("readonly" in $$props)
      $$invalidate(17, readonly = $$new_props.readonly);
    if ("reverse" in $$props)
      $$invalidate(18, reverse = $$new_props.reverse);
    if ("size" in $$props)
      $$invalidate(1, size = $$new_props.size);
    if ("theme" in $$props)
      $$invalidate(19, theme = $$new_props.theme);
    if ("type" in $$props)
      $$invalidate(20, type = $$new_props.type);
    if ("valid" in $$props)
      $$invalidate(21, valid = $$new_props.valid);
    if ("value" in $$props)
      $$invalidate(6, value = $$new_props.value);
    if ("classes" in $$props)
      $$invalidate(23, classes = $$new_props.classes);
    if ("tag" in $$props)
      $$invalidate(22, tag = $$new_props.tag);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*type, color, plaintext, size, className, invalid, valid, bsSize, tag*/
    208667779) {
      $: {
        const isNotaNumber = new RegExp("\\D", "g");
        let isBtn = false;
        let formControlClass = "form-control";
        $$invalidate(22, tag = "input");
        switch (type) {
          case "color":
            formControlClass = `form-control form-control-color`;
            break;
          case "range":
            formControlClass = "form-range";
            break;
          case "select":
            formControlClass = `form-select`;
            $$invalidate(22, tag = "select");
            break;
          case "textarea":
            $$invalidate(22, tag = "textarea");
            break;
          case "button":
          case "reset":
          case "submit":
            formControlClass = `btn btn-${color || "secondary"}`;
            isBtn = true;
            break;
          case "hidden":
          case "image":
            formControlClass = void 0;
            break;
          default:
            formControlClass = "form-control";
            $$invalidate(22, tag = "input");
        }
        if (plaintext) {
          formControlClass = `${formControlClass}-plaintext`;
          $$invalidate(22, tag = "input");
        }
        if (size && isNotaNumber.test(size)) {
          console.warn(`Please use the prop "bsSize" instead of the "size" to bootstrap's input sizing.`);
          $$invalidate(0, bsSize = size);
          $$invalidate(1, size = void 0);
        }
        $$invalidate(23, classes = classnames(className, formControlClass, {
          "is-invalid": invalid,
          "is-valid": valid,
          [`form-control-${bsSize}`]: bsSize && !isBtn && tag !== "select",
          [`form-select-${bsSize}`]: bsSize && tag === "select",
          [`btn-${bsSize}`]: bsSize && isBtn
        }));
      }
    }
  };
  return [
    bsSize,
    size,
    checked,
    files,
    group,
    inner,
    value,
    className,
    disabled,
    feedback,
    invalid,
    label,
    max2,
    min2,
    multiple,
    name,
    placeholder,
    readonly,
    reverse,
    theme,
    type,
    valid,
    tag,
    classes,
    handleInput,
    $$restProps,
    color,
    plaintext,
    slots,
    blur_handler,
    change_handler,
    click_handler,
    focus_handler,
    input_handler,
    keydown_handler,
    keypress_handler,
    keyup_handler,
    mousedown_handler,
    mouseup_handler,
    blur_handler_1,
    change_handler_1,
    click_handler_1,
    focus_handler_1,
    input_handler_1,
    keydown_handler_1,
    keypress_handler_1,
    keyup_handler_1,
    mousedown_handler_1,
    mouseup_handler_1,
    blur_handler_2,
    change_handler_2,
    click_handler_2,
    focus_handler_2,
    input_handler_2,
    keydown_handler_2,
    keypress_handler_2,
    keyup_handler_2,
    mousedown_handler_2,
    mouseup_handler_2,
    blur_handler_3,
    change_handler_3,
    click_handler_3,
    focus_handler_3,
    input_handler_3,
    keydown_handler_3,
    keypress_handler_3,
    keyup_handler_3,
    mousedown_handler_3,
    mouseup_handler_3,
    blur_handler_5,
    change_handler_5,
    click_handler_4,
    focus_handler_5,
    input_handler_5,
    keydown_handler_5,
    keypress_handler_5,
    keyup_handler_5,
    mousedown_handler_5,
    mouseup_handler_5,
    blur_handler_6,
    click_handler_5,
    focus_handler_6,
    keydown_handler_6,
    keypress_handler_6,
    keyup_handler_6,
    mousedown_handler_6,
    mouseup_handler_6,
    blur_handler_7,
    change_handler_6,
    click_handler_6,
    focus_handler_7,
    input_handler_6,
    keydown_handler_7,
    keypress_handler_7,
    keyup_handler_7,
    mousedown_handler_7,
    mouseup_handler_7,
    blur_handler_8,
    click_handler_7,
    change_handler_7,
    focus_handler_8,
    input_handler_7,
    input_input_handler,
    input_binding,
    input_input_handler_1,
    input_binding_1,
    input_input_handler_2,
    input_binding_2,
    input_change_handler,
    input_binding_3,
    formcheck_checked_binding,
    formcheck_inner_binding,
    formcheck_group_binding,
    formcheck_value_binding,
    blur_handler_4,
    change_handler_4,
    focus_handler_4,
    input_handler_4,
    keydown_handler_4,
    keypress_handler_4,
    keyup_handler_4,
    mousedown_handler_4,
    mouseup_handler_4,
    input_input_handler_3,
    input_binding_4,
    textarea_input_handler,
    textarea_binding,
    select_change_handler,
    select_binding,
    $$scope
  ];
}
var Input = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance48,
      create_fragment48,
      safe_not_equal,
      {
        class: 7,
        bsSize: 0,
        checked: 2,
        color: 26,
        disabled: 8,
        feedback: 9,
        files: 3,
        group: 4,
        inner: 5,
        invalid: 10,
        label: 11,
        max: 12,
        min: 13,
        multiple: 14,
        name: 15,
        placeholder: 16,
        plaintext: 27,
        readonly: 17,
        reverse: 18,
        size: 1,
        theme: 19,
        type: 20,
        valid: 21,
        value: 6
      },
      null,
      [-1, -1, -1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Input",
      options,
      id: create_fragment48.name
    });
  }
  get class() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bsSize() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bsSize(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get feedback() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set feedback(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get files() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set files(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get group() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inner() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inner(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get plaintext() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set plaintext(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readonly() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readonly(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reverse() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set reverse(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valid() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valid(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Input_default = Input;

// node_modules/@sveltestrap/sveltestrap/dist/InputGroup/InputGroup.svelte
var file48 = "node_modules/@sveltestrap/sveltestrap/dist/InputGroup/InputGroup.svelte";
function create_fragment49(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[2],
    { class: (
      /*classes*/
      ctx[1]
    ) },
    { "data-bs-theme": (
      /*theme*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file48, 27, 0, 541);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) },
        (!current || dirty & /*theme*/
        1) && { "data-bs-theme": (
          /*theme*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment49.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance49($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "size", "theme"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InputGroup", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { size = "" } = $$props;
  let { theme = null } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("size" in $$new_props)
      $$invalidate(4, size = $$new_props.size);
    if ("theme" in $$new_props)
      $$invalidate(0, theme = $$new_props.theme);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    size,
    theme,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("size" in $$props)
      $$invalidate(4, size = $$new_props.size);
    if ("theme" in $$props)
      $$invalidate(0, theme = $$new_props.theme);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, size*/
    24) {
      $:
        $$invalidate(1, classes = classnames(className, "input-group", size ? `input-group-${size}` : null));
    }
  };
  return [theme, classes, $$restProps, className, size, $$scope, slots];
}
var InputGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance49, create_fragment49, safe_not_equal, { class: 3, size: 4, theme: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputGroup",
      options,
      id: create_fragment49.name
    });
  }
  get class() {
    throw new Error("<InputGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<InputGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<InputGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<InputGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<InputGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<InputGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputGroup_default = InputGroup;

// node_modules/@sveltestrap/sveltestrap/dist/InputGroupText/InputGroupText.svelte
var file49 = "node_modules/@sveltestrap/sveltestrap/dist/InputGroupText/InputGroupText.svelte";
function create_fragment50(ctx) {
  let span;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let span_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      set_attributes(span, span_data);
      add_location(span, file49, 14, 0, 274);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment50.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance50($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InputGroupText", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "input-group-text"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var InputGroupText = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance50, create_fragment50, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputGroupText",
      options,
      id: create_fragment50.name
    });
  }
  get class() {
    throw new Error("<InputGroupText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<InputGroupText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputGroupText_default = InputGroupText;

// node_modules/@sveltestrap/sveltestrap/dist/Jumbotron/Jumbotron.svelte
var file50 = "node_modules/@sveltestrap/sveltestrap/dist/Jumbotron/Jumbotron.svelte";
function create_fragment51(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(
        div,
        "class",
        /*classes*/
        ctx[0]
      );
      add_location(div, file50, 14, 0, 285);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classes*/
      1) {
        attr_dev(
          div,
          "class",
          /*classes*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment51.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance51($$self, $$props, $$invalidate) {
  let classes;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Jumbotron", slots, ["default"]);
  let { class: className = "" } = $$props;
  const writable_props = ["class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Jumbotron> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(1, className = $$props2.class);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$props2) => {
    if ("className" in $$props2)
      $$invalidate(1, className = $$props2.className);
    if ("classes" in $$props2)
      $$invalidate(0, classes = $$props2.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    2) {
      $:
        $$invalidate(0, classes = classnames(className, "p-5 mb-4 bg-light rounded-3"));
    }
  };
  return [classes, className, $$scope, slots];
}
var Jumbotron = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance51, create_fragment51, safe_not_equal, { class: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Jumbotron",
      options,
      id: create_fragment51.name
    });
  }
  get class() {
    throw new Error("<Jumbotron>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Jumbotron>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Jumbotron_default = Jumbotron;

// node_modules/@sveltestrap/sveltestrap/dist/Label/Label.svelte
var file51 = "node_modules/@sveltestrap/sveltestrap/dist/Label/Label.svelte";
function create_fragment52(ctx) {
  let label;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  let label_levels = [
    /*$$restProps*/
    ctx[2],
    { class: (
      /*classes*/
      ctx[1]
    ) },
    { for: (
      /*fore*/
      ctx[0]
    ) }
  ];
  let label_data = {};
  for (let i = 0; i < label_levels.length; i += 1) {
    label_data = assign(label_data, label_levels[i]);
  }
  const block = {
    c: function create() {
      label = element("label");
      if (default_slot)
        default_slot.c();
      set_attributes(label, label_data);
      add_location(label, file51, 67, 0, 1624);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) },
        (!current || dirty & /*fore*/
        1) && { for: (
          /*fore*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment52.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance52($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "hidden", "check", "size", "for", "xs", "sm", "md", "lg", "xl", "xxl", "widths"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Label", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { hidden = false } = $$props;
  let { check = false } = $$props;
  let { size = "" } = $$props;
  let { for: fore = null } = $$props;
  let { xs = "" } = $$props;
  let { sm = "" } = $$props;
  let { md = "" } = $$props;
  let { lg = "" } = $$props;
  let { xl = "" } = $$props;
  let { xxl = "" } = $$props;
  const colWidths = { xs, sm, md, lg, xl, xxl };
  let { widths = Object.keys(colWidths) } = $$props;
  const colClasses = [];
  widths.forEach((colWidth) => {
    let columnProp = $$props[colWidth];
    if (!columnProp && columnProp !== "") {
      return;
    }
    const isXs = colWidth === "xs";
    let colClass;
    if (isObject(columnProp)) {
      const colSizeInterfix = isXs ? "-" : `-${colWidth}-`;
      colClass = getColumnSizeClass(isXs, colWidth, columnProp.size);
      colClasses.push(classnames({
        [colClass]: columnProp.size || columnProp.size === "",
        [`order${colSizeInterfix}${columnProp.order}`]: columnProp.order || columnProp.order === 0,
        [`offset${colSizeInterfix}${columnProp.offset}`]: columnProp.offset || columnProp.offset === 0
      }));
    } else {
      colClass = getColumnSizeClass(isXs, colWidth, columnProp);
      colClasses.push(colClass);
    }
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("hidden" in $$new_props)
      $$invalidate(4, hidden = $$new_props.hidden);
    if ("check" in $$new_props)
      $$invalidate(5, check = $$new_props.check);
    if ("size" in $$new_props)
      $$invalidate(6, size = $$new_props.size);
    if ("for" in $$new_props)
      $$invalidate(0, fore = $$new_props.for);
    if ("xs" in $$new_props)
      $$invalidate(7, xs = $$new_props.xs);
    if ("sm" in $$new_props)
      $$invalidate(8, sm = $$new_props.sm);
    if ("md" in $$new_props)
      $$invalidate(9, md = $$new_props.md);
    if ("lg" in $$new_props)
      $$invalidate(10, lg = $$new_props.lg);
    if ("xl" in $$new_props)
      $$invalidate(11, xl = $$new_props.xl);
    if ("xxl" in $$new_props)
      $$invalidate(12, xxl = $$new_props.xxl);
    if ("widths" in $$new_props)
      $$invalidate(13, widths = $$new_props.widths);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    getColumnSizeClass,
    isObject,
    className,
    hidden,
    check,
    size,
    fore,
    xs,
    sm,
    md,
    lg,
    xl,
    xxl,
    colWidths,
    widths,
    colClasses,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("hidden" in $$props)
      $$invalidate(4, hidden = $$new_props.hidden);
    if ("check" in $$props)
      $$invalidate(5, check = $$new_props.check);
    if ("size" in $$props)
      $$invalidate(6, size = $$new_props.size);
    if ("fore" in $$props)
      $$invalidate(0, fore = $$new_props.fore);
    if ("xs" in $$props)
      $$invalidate(7, xs = $$new_props.xs);
    if ("sm" in $$props)
      $$invalidate(8, sm = $$new_props.sm);
    if ("md" in $$props)
      $$invalidate(9, md = $$new_props.md);
    if ("lg" in $$props)
      $$invalidate(10, lg = $$new_props.lg);
    if ("xl" in $$props)
      $$invalidate(11, xl = $$new_props.xl);
    if ("xxl" in $$props)
      $$invalidate(12, xxl = $$new_props.xxl);
    if ("widths" in $$props)
      $$invalidate(13, widths = $$new_props.widths);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, hidden, check, size*/
    120) {
      $:
        $$invalidate(1, classes = classnames(className, hidden ? "visually-hidden" : false, check ? "form-check-label" : false, size ? `col-form-label-${size}` : false, colClasses, colClasses.length ? "col-form-label" : "form-label"));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    fore,
    classes,
    $$restProps,
    className,
    hidden,
    check,
    size,
    xs,
    sm,
    md,
    lg,
    xl,
    xxl,
    widths,
    $$scope,
    slots
  ];
}
var Label = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance52, create_fragment52, safe_not_equal, {
      class: 3,
      hidden: 4,
      check: 5,
      size: 6,
      for: 0,
      xs: 7,
      sm: 8,
      md: 9,
      lg: 10,
      xl: 11,
      xxl: 12,
      widths: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Label",
      options,
      id: create_fragment52.name
    });
  }
  get class() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hidden() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hidden(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get check() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set check(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get for() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set for(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xs() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xs(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sm() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sm(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get md() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set md(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lg() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lg(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xl() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xl(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xxl() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xxl(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get widths() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set widths(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Label_default = Label;

// node_modules/@sveltestrap/sveltestrap/dist/ListGroup/ListGroup.svelte
var file52 = "node_modules/@sveltestrap/sveltestrap/dist/ListGroup/ListGroup.svelte";
function create_else_block14(ctx) {
  let ul;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let ul_levels = [
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) },
    { "data-bs-theme": (
      /*theme*/
      ctx[1]
    ) }
  ];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      set_attributes(ul, ul_data);
      add_location(ul, file52, 48, 2, 1213);
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) },
        (!current || dirty & /*theme*/
        2) && { "data-bs-theme": (
          /*theme*/
          ctx2[1]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block14.name,
    type: "else",
    source: "(48:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block18(ctx) {
  let ol;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let ol_levels = [
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) },
    { "data-bs-theme": (
      /*theme*/
      ctx[1]
    ) }
  ];
  let ol_data = {};
  for (let i = 0; i < ol_levels.length; i += 1) {
    ol_data = assign(ol_data, ol_levels[i]);
  }
  const block = {
    c: function create() {
      ol = element("ol");
      if (default_slot)
        default_slot.c();
      set_attributes(ol, ol_data);
      add_location(ol, file52, 44, 2, 1122);
    },
    m: function mount(target, anchor) {
      insert_dev(target, ol, anchor);
      if (default_slot) {
        default_slot.m(ol, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(ol, ol_data = get_spread_update(ol_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) },
        (!current || dirty & /*theme*/
        2) && { "data-bs-theme": (
          /*theme*/
          ctx2[1]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ol);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block18.name,
    type: "if",
    source: "(44:0) {#if numbered}",
    ctx
  });
  return block;
}
function create_fragment53(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block18, create_else_block14];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*numbered*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment53.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance53($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "flush", "horizontal", "numbered", "theme"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListGroup", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { flush = false } = $$props;
  let { horizontal = false } = $$props;
  let { numbered = false } = $$props;
  let { theme = null } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("flush" in $$new_props)
      $$invalidate(5, flush = $$new_props.flush);
    if ("horizontal" in $$new_props)
      $$invalidate(6, horizontal = $$new_props.horizontal);
    if ("numbered" in $$new_props)
      $$invalidate(0, numbered = $$new_props.numbered);
    if ("theme" in $$new_props)
      $$invalidate(1, theme = $$new_props.theme);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    flush,
    horizontal,
    numbered,
    theme,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("flush" in $$props)
      $$invalidate(5, flush = $$new_props.flush);
    if ("horizontal" in $$props)
      $$invalidate(6, horizontal = $$new_props.horizontal);
    if ("numbered" in $$props)
      $$invalidate(0, numbered = $$new_props.numbered);
    if ("theme" in $$props)
      $$invalidate(1, theme = $$new_props.theme);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, flush, horizontal, numbered*/
    113) {
      $:
        $$invalidate(2, classes = classnames(className, "list-group", {
          "list-group-flush": flush,
          "list-group-horizontal": horizontal,
          "list-group-numbered": numbered
        }));
    }
  };
  return [
    numbered,
    theme,
    classes,
    $$restProps,
    className,
    flush,
    horizontal,
    $$scope,
    slots
  ];
}
var ListGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance53, create_fragment53, safe_not_equal, {
      class: 4,
      flush: 5,
      horizontal: 6,
      numbered: 0,
      theme: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListGroup",
      options,
      id: create_fragment53.name
    });
  }
  get class() {
    throw new Error("<ListGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ListGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flush() {
    throw new Error("<ListGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flush(value) {
    throw new Error("<ListGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get horizontal() {
    throw new Error("<ListGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set horizontal(value) {
    throw new Error("<ListGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get numbered() {
    throw new Error("<ListGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set numbered(value) {
    throw new Error("<ListGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<ListGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<ListGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListGroup_default = ListGroup;

// node_modules/@sveltestrap/sveltestrap/dist/ListGroupItem/ListGroupItem.svelte
var file53 = "node_modules/@sveltestrap/sveltestrap/dist/ListGroupItem/ListGroupItem.svelte";
function create_else_block15(ctx) {
  let li;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let li_levels = [
    /*$$restProps*/
    ctx[5],
    { class: (
      /*classes*/
      ctx[4]
    ) },
    { disabled: (
      /*disabled*/
      ctx[1]
    ) },
    { active: (
      /*active*/
      ctx[0]
    ) }
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if (default_slot)
        default_slot.c();
      set_attributes(li, li_data);
      add_location(li, file53, 31, 2, 855);
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          li,
          "click",
          /*click_handler_2*/
          ctx[13],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        (!current || dirty & /*disabled*/
        2) && { disabled: (
          /*disabled*/
          ctx2[1]
        ) },
        (!current || dirty & /*active*/
        1) && { active: (
          /*active*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block15.name,
    type: "else",
    source: "(29:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_111(ctx) {
  let button;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let button_levels = [
    /*$$restProps*/
    ctx[5],
    { class: (
      /*classes*/
      ctx[4]
    ) },
    { type: "button" },
    { disabled: (
      /*disabled*/
      ctx[1]
    ) },
    { active: (
      /*active*/
      ctx[0]
    ) }
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      set_attributes(button, button_data);
      add_location(button, file53, 25, 2, 607);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler_1*/
          ctx[12],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        { type: "button" },
        (!current || dirty & /*disabled*/
        2) && { disabled: (
          /*disabled*/
          ctx2[1]
        ) },
        (!current || dirty & /*active*/
        1) && { active: (
          /*active*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_111.name,
    type: "if",
    source: "(25:27) ",
    ctx
  });
  return block;
}
function create_if_block19(ctx) {
  let a;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let a_levels = [
    /*$$restProps*/
    ctx[5],
    { class: (
      /*classes*/
      ctx[4]
    ) },
    { href: (
      /*href*/
      ctx[2]
    ) },
    { disabled: (
      /*disabled*/
      ctx[1]
    ) },
    { active: (
      /*active*/
      ctx[0]
    ) }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
      add_location(a, file53, 21, 2, 484);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*click_handler*/
          ctx[11],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) },
        (!current || dirty & /*href*/
        4) && { href: (
          /*href*/
          ctx2[2]
        ) },
        (!current || dirty & /*disabled*/
        2) && { disabled: (
          /*disabled*/
          ctx2[1]
        ) },
        (!current || dirty & /*active*/
        1) && { active: (
          /*active*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block19.name,
    type: "if",
    source: "(21:0) {#if href}",
    ctx
  });
  return block;
}
function create_fragment54(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block19, create_if_block_111, create_else_block15];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*href*/
      ctx2[2]
    )
      return 0;
    if (
      /*tag*/
      ctx2[3] === "button"
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment54.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance54($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "active", "disabled", "color", "action", "href", "tag"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListGroupItem", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  let { disabled = false } = $$props;
  let { color = "" } = $$props;
  let { action = false } = $$props;
  let { href = null } = $$props;
  let { tag = null } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(6, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(0, active = $$new_props.active);
    if ("disabled" in $$new_props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("color" in $$new_props)
      $$invalidate(7, color = $$new_props.color);
    if ("action" in $$new_props)
      $$invalidate(8, action = $$new_props.action);
    if ("href" in $$new_props)
      $$invalidate(2, href = $$new_props.href);
    if ("tag" in $$new_props)
      $$invalidate(3, tag = $$new_props.tag);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    active,
    disabled,
    color,
    action,
    href,
    tag,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(6, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(0, active = $$new_props.active);
    if ("disabled" in $$props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("color" in $$props)
      $$invalidate(7, color = $$new_props.color);
    if ("action" in $$props)
      $$invalidate(8, action = $$new_props.action);
    if ("href" in $$props)
      $$invalidate(2, href = $$new_props.href);
    if ("tag" in $$props)
      $$invalidate(3, tag = $$new_props.tag);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, active, disabled, action, tag, color*/
    459) {
      $:
        $$invalidate(4, classes = classnames(className, "list-group-item", {
          active,
          disabled,
          "list-group-item-action": action || tag === "button",
          [`list-group-item-${color}`]: color
        }));
    }
  };
  return [
    active,
    disabled,
    href,
    tag,
    classes,
    $$restProps,
    className,
    color,
    action,
    $$scope,
    slots,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
var ListGroupItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance54, create_fragment54, safe_not_equal, {
      class: 6,
      active: 0,
      disabled: 1,
      color: 7,
      action: 8,
      href: 2,
      tag: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListGroupItem",
      options,
      id: create_fragment54.name
    });
  }
  get class() {
    throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get action() {
    throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set action(value) {
    throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListGroupItem_default = ListGroupItem;

// node_modules/@sveltestrap/sveltestrap/dist/ModalBackdrop/ModalBackdrop.svelte
var file54 = "node_modules/@sveltestrap/sveltestrap/dist/ModalBackdrop/ModalBackdrop.svelte";
function create_if_block20(ctx) {
  let div;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  let div_levels = [
    { role: "presentation" },
    /*$$restProps*/
    ctx[4],
    { class: (
      /*classes*/
      ctx[3]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      set_attributes(div, div_data);
      toggle_class(
        div,
        "fade",
        /*fade*/
        ctx[1]
      );
      add_location(div, file54, 21, 2, 421);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*click_handler*/
          ctx[6],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { role: "presentation" },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) }
      ]));
      toggle_class(
        div,
        "fade",
        /*fade*/
        ctx2[1]
      );
    },
    i: function intro(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div_outro)
            div_outro.end(1);
          div_intro = create_in_transition(div, backdropIn, {});
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (div_intro)
        div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(div, backdropOut, {});
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (detaching && div_outro)
        div_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block20.name,
    type: "if",
    source: "(21:0) {#if isOpen && loaded}",
    ctx
  });
  return block;
}
function create_fragment55(ctx) {
  let if_block_anchor;
  let if_block = (
    /*isOpen*/
    ctx[0] && /*loaded*/
    ctx[2] && create_if_block20(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isOpen*/
        ctx2[0] && /*loaded*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isOpen, loaded*/
          5) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block20(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      transition_in(if_block);
    },
    o: function outro(local) {
      transition_out(if_block);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment55.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance55($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "isOpen", "fade"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ModalBackdrop", slots, []);
  let { class: className = "" } = $$props;
  let { isOpen = false } = $$props;
  let { fade: fade2 = true } = $$props;
  let loaded = false;
  onMount(() => {
    $$invalidate(2, loaded = true);
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("fade" in $$new_props)
      $$invalidate(1, fade2 = $$new_props.fade);
  };
  $$self.$capture_state = () => ({
    onMount,
    classnames,
    backdropIn,
    backdropOut,
    className,
    isOpen,
    fade: fade2,
    loaded,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("fade" in $$props)
      $$invalidate(1, fade2 = $$new_props.fade);
    if ("loaded" in $$props)
      $$invalidate(2, loaded = $$new_props.loaded);
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    32) {
      $:
        $$invalidate(3, classes = classnames(className, "modal-backdrop"));
    }
  };
  return [isOpen, fade2, loaded, classes, $$restProps, className, click_handler];
}
var ModalBackdrop = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance55, create_fragment55, safe_not_equal, { class: 5, isOpen: 0, fade: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ModalBackdrop",
      options,
      id: create_fragment55.name
    });
  }
  get class() {
    throw new Error("<ModalBackdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ModalBackdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<ModalBackdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<ModalBackdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fade() {
    throw new Error("<ModalBackdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fade(value) {
    throw new Error("<ModalBackdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ModalBackdrop_default = ModalBackdrop;

// node_modules/@sveltestrap/sveltestrap/dist/ModalBody/ModalBody.svelte
var file55 = "node_modules/@sveltestrap/sveltestrap/dist/ModalBody/ModalBody.svelte";
function create_fragment56(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file55, 13, 0, 243);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment56.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance56($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ModalBody", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "modal-body"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var ModalBody = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance56, create_fragment56, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ModalBody",
      options,
      id: create_fragment56.name
    });
  }
  get class() {
    throw new Error("<ModalBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ModalBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ModalBody_default = ModalBody;

// node_modules/@sveltestrap/sveltestrap/dist/ModalHeader/ModalHeader.svelte
var file56 = "node_modules/@sveltestrap/sveltestrap/dist/ModalHeader/ModalHeader.svelte";
var get_close_slot_changes = (dirty) => ({});
var get_close_slot_context = (ctx) => ({});
function create_else_block16(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block16.name,
    type: "else",
    source: "(38:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_112(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*children*/
        ctx[3]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*children*/
      8)
        set_data_dev(
          t,
          /*children*/
          ctx2[3]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_112.name,
    type: "if",
    source: "(36:4) {#if children}",
    ctx
  });
  return block;
}
function create_if_block21(ctx) {
  let button;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "btn-close");
      attr_dev(
        button,
        "aria-label",
        /*closeAriaLabel*/
        ctx[1]
      );
      add_location(button, file56, 43, 6, 861);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          function() {
            if (is_function(
              /*toggle*/
              ctx[0]
            ))
              ctx[0].apply(this, arguments);
          },
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*closeAriaLabel*/
      2) {
        attr_dev(
          button,
          "aria-label",
          /*closeAriaLabel*/
          ctx[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block21.name,
    type: "if",
    source: "(43:4) {#if typeof toggle === 'function'}",
    ctx
  });
  return block;
}
function fallback_block4(ctx) {
  let if_block_anchor;
  let if_block = typeof /*toggle*/
  ctx[0] === "function" && create_if_block21(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (typeof /*toggle*/
      ctx2[0] === "function") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block21(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block4.name,
    type: "fallback",
    source: "(42:21)      ",
    ctx
  });
  return block;
}
function create_fragment57(ctx) {
  let div;
  let h5;
  let current_block_type_index;
  let if_block;
  let t;
  let current;
  const if_block_creators = [create_if_block_112, create_else_block16];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*children*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const close_slot_template = (
    /*#slots*/
    ctx[8].close
  );
  const close_slot = create_slot(
    close_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_close_slot_context
  );
  const close_slot_or_fallback = close_slot || fallback_block4(ctx);
  let div_levels = [
    /*$$restProps*/
    ctx[5],
    { class: (
      /*classes*/
      ctx[4]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      h5 = element("h5");
      if_block.c();
      t = space();
      if (close_slot_or_fallback)
        close_slot_or_fallback.c();
      attr_dev(h5, "class", "modal-title");
      attr_dev(
        h5,
        "id",
        /*id*/
        ctx[2]
      );
      add_location(h5, file56, 34, 2, 683);
      set_attributes(div, div_data);
      add_location(div, file56, 33, 0, 642);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, h5);
      if_blocks[current_block_type_index].m(h5, null);
      append_dev(div, t);
      if (close_slot_or_fallback) {
        close_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(h5, null);
      }
      if (!current || dirty & /*id*/
      4) {
        attr_dev(
          h5,
          "id",
          /*id*/
          ctx2[2]
        );
      }
      if (close_slot) {
        if (close_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            close_slot,
            close_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              close_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_close_slot_changes
            ),
            get_close_slot_context
          );
        }
      } else {
        if (close_slot_or_fallback && close_slot_or_fallback.p && (!current || dirty & /*closeAriaLabel, toggle*/
        3)) {
          close_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(close_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(close_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if_blocks[current_block_type_index].d();
      if (close_slot_or_fallback)
        close_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment57.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance57($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "toggle", "closeAriaLabel", "id", "children"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ModalHeader", slots, ["default", "close"]);
  let { class: className = "" } = $$props;
  let { toggle = void 0 } = $$props;
  let { closeAriaLabel = "Close" } = $$props;
  let { id = void 0 } = $$props;
  let { children = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(6, className = $$new_props.class);
    if ("toggle" in $$new_props)
      $$invalidate(0, toggle = $$new_props.toggle);
    if ("closeAriaLabel" in $$new_props)
      $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
    if ("id" in $$new_props)
      $$invalidate(2, id = $$new_props.id);
    if ("children" in $$new_props)
      $$invalidate(3, children = $$new_props.children);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    toggle,
    closeAriaLabel,
    id,
    children,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(6, className = $$new_props.className);
    if ("toggle" in $$props)
      $$invalidate(0, toggle = $$new_props.toggle);
    if ("closeAriaLabel" in $$props)
      $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
    if ("id" in $$props)
      $$invalidate(2, id = $$new_props.id);
    if ("children" in $$props)
      $$invalidate(3, children = $$new_props.children);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    64) {
      $:
        $$invalidate(4, classes = classnames(className, "modal-header"));
    }
  };
  return [
    toggle,
    closeAriaLabel,
    id,
    children,
    classes,
    $$restProps,
    className,
    $$scope,
    slots
  ];
}
var ModalHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance57, create_fragment57, safe_not_equal, {
      class: 6,
      toggle: 0,
      closeAriaLabel: 1,
      id: 2,
      children: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ModalHeader",
      options,
      id: create_fragment57.name
    });
  }
  get class() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeAriaLabel() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeAriaLabel(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ModalHeader_default = ModalHeader;

// node_modules/@sveltestrap/sveltestrap/dist/Portal/Portal.svelte
var file57 = "node_modules/@sveltestrap/sveltestrap/dist/Portal/Portal.svelte";
function create_fragment58(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file57, 18, 0, 321);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[4](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      2 && /*$$restProps*/
      ctx2[1]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[4](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment58.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance58($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Portal", slots, ["default"]);
  let ref;
  let portal;
  onMount(() => {
    portal = document.createElement("div");
    document.body.appendChild(portal);
    portal.appendChild(ref);
  });
  onDestroy(() => {
    if (portal) {
      document.body.removeChild(portal);
    }
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ onMount, onDestroy, ref, portal });
  $$self.$inject_state = ($$new_props) => {
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("portal" in $$props)
      portal = $$new_props.portal;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ref, $$restProps, $$scope, slots, div_binding];
}
var Portal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance58, create_fragment58, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Portal",
      options,
      id: create_fragment58.name
    });
  }
};
var Portal_default = Portal;

// node_modules/@sveltestrap/sveltestrap/dist/Modal/Modal.svelte
var file58 = "node_modules/@sveltestrap/sveltestrap/dist/Modal/Modal.svelte";
function add_css(target) {
  append_styles(target, "svelte-d87gpn", ".modal-open{overflow:hidden;padding-right:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTW9kYWwuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXVYVSxXQUFhLENBQ25CLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLGFBQWEsQ0FBRSxDQUNqQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJNb2RhbC5zdmVsdGUiXX0= */");
}
var get_external_slot_changes = (dirty) => ({});
var get_external_slot_context = (ctx) => ({});
function create_if_block_113(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*outer*/
    ctx[15]
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        $$slots: { default: [create_default_slot_13] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*outer*/
      32768 && switch_value !== (switch_value = /*outer*/
      ctx2[15])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty[0] & /*wrapClassName, $$restProps, theme, modalStyle, labelledBy, modalClassName, fade, staticModal, classes, _dialog, contentClassName, body, toggle, header, isOpen*/
        8478703 | dirty[1] & /*$$scope*/
        64) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_113.name,
    type: "if",
    source: "(323:0) {#if _isMounted}",
    ctx
  });
  return block;
}
function create_if_block_210(ctx) {
  let div2;
  let t0;
  let div1;
  let div0;
  let t1;
  let current_block_type_index;
  let if_block1;
  let div0_class_value;
  let div2_class_value;
  let div2_intro;
  let div2_outro;
  let current;
  let mounted;
  let dispose;
  const external_slot_template = (
    /*#slots*/
    ctx[34].external
  );
  const external_slot = create_slot(
    external_slot_template,
    ctx,
    /*$$scope*/
    ctx[37],
    get_external_slot_context
  );
  let if_block0 = (
    /*header*/
    ctx[2] && create_if_block_44(ctx)
  );
  const if_block_creators = [create_if_block_35, create_else_block17];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*body*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div2 = element("div");
      if (external_slot)
        external_slot.c();
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t1 = space();
      if_block1.c();
      attr_dev(div0, "class", div0_class_value = classnames(
        "modal-content",
        /*contentClassName*/
        ctx[5]
      ));
      add_location(div0, file58, 347, 12, 8142);
      attr_dev(
        div1,
        "class",
        /*classes*/
        ctx[16]
      );
      attr_dev(div1, "role", "document");
      add_location(div1, file58, 346, 10, 8072);
      attr_dev(
        div2,
        "style",
        /*modalStyle*/
        ctx[9]
      );
      attr_dev(
        div2,
        "aria-labelledby",
        /*labelledBy*/
        ctx[7]
      );
      attr_dev(div2, "class", div2_class_value = classnames(
        "modal",
        /*modalClassName*/
        ctx[8],
        {
          fade: (
            /*fade*/
            ctx[6]
          ),
          "position-static": (
            /*staticModal*/
            ctx[0]
          )
        }
      ));
      attr_dev(div2, "role", "dialog");
      add_location(div2, file58, 328, 8, 7473);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      if (external_slot) {
        external_slot.m(div2, null);
      }
      append_dev(div2, t0);
      append_dev(div2, div1);
      append_dev(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append_dev(div0, t1);
      if_blocks[current_block_type_index].m(div0, null);
      ctx[35](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div2,
            "introstart",
            /*introstart_handler*/
            ctx[36],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "introend",
            /*onModalOpened*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "outrostart",
            /*onModalClosing*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "outroend",
            /*onModalClosed*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "click",
            /*handleBackdropClick*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "mousedown",
            /*handleBackdropMouseDown*/
            ctx[22],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (external_slot) {
        if (external_slot.p && (!current || dirty[1] & /*$$scope*/
        64)) {
          update_slot_base(
            external_slot,
            external_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[37],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[37]
            ) : get_slot_changes(
              external_slot_template,
              /*$$scope*/
              ctx2[37],
              dirty,
              get_external_slot_changes
            ),
            get_external_slot_context
          );
        }
      }
      if (
        /*header*/
        ctx2[2]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*header*/
          4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_44(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div0, null);
      }
      if (!current || dirty[0] & /*contentClassName*/
      32 && div0_class_value !== (div0_class_value = classnames(
        "modal-content",
        /*contentClassName*/
        ctx2[5]
      ))) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty[0] & /*classes*/
      65536) {
        attr_dev(
          div1,
          "class",
          /*classes*/
          ctx2[16]
        );
      }
      if (!current || dirty[0] & /*modalStyle*/
      512) {
        attr_dev(
          div2,
          "style",
          /*modalStyle*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*labelledBy*/
      128) {
        attr_dev(
          div2,
          "aria-labelledby",
          /*labelledBy*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*modalClassName, fade, staticModal*/
      321 && div2_class_value !== (div2_class_value = classnames(
        "modal",
        /*modalClassName*/
        ctx2[8],
        {
          fade: (
            /*fade*/
            ctx2[6]
          ),
          "position-static": (
            /*staticModal*/
            ctx2[0]
          )
        }
      ))) {
        attr_dev(div2, "class", div2_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(external_slot, local);
      transition_in(if_block0);
      transition_in(if_block1);
      add_render_callback(() => {
        if (!current)
          return;
        if (div2_outro)
          div2_outro.end(1);
        div2_intro = create_in_transition(div2, modalIn, {});
        div2_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(external_slot, local);
      transition_out(if_block0);
      transition_out(if_block1);
      if (div2_intro)
        div2_intro.invalidate();
      div2_outro = create_out_transition(div2, modalOut, {});
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (external_slot)
        external_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      ctx[35](null);
      if (detaching && div2_outro)
        div2_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_210.name,
    type: "if",
    source: "(327:6) {#if isOpen}",
    ctx
  });
  return block;
}
function create_if_block_44(ctx) {
  let modalheader;
  let current;
  modalheader = new ModalHeader_default({
    props: {
      toggle: (
        /*toggle*/
        ctx[11]
      ),
      id: (
        /*labelledBy*/
        ctx[7]
      ),
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(modalheader.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(modalheader, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const modalheader_changes = {};
      if (dirty[0] & /*toggle*/
      2048)
        modalheader_changes.toggle = /*toggle*/
        ctx2[11];
      if (dirty[0] & /*labelledBy*/
      128)
        modalheader_changes.id = /*labelledBy*/
        ctx2[7];
      if (dirty[0] & /*header*/
      4 | dirty[1] & /*$$scope*/
      64) {
        modalheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalheader.$set(modalheader_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(modalheader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(modalheader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(modalheader, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_44.name,
    type: "if",
    source: "(349:14) {#if header}",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*header*/
        ctx[2]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*header*/
      4)
        set_data_dev(
          t,
          /*header*/
          ctx2[2]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(350:16) <ModalHeader {toggle} id={labelledBy}>",
    ctx
  });
  return block;
}
function create_else_block17(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[34].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[37],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[37],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[37]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[37],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block17.name,
    type: "else",
    source: "(358:14) {:else}",
    ctx
  });
  return block;
}
function create_if_block_35(ctx) {
  let modalbody;
  let current;
  modalbody = new ModalBody_default({
    props: {
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(modalbody.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(modalbody, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const modalbody_changes = {};
      if (dirty[1] & /*$$scope*/
      64) {
        modalbody_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbody.$set(modalbody_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(modalbody.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(modalbody.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(modalbody, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_35.name,
    type: "if",
    source: "(354:14) {#if body}",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[34].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[37],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[37],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[37]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[37],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(355:16) <ModalBody>",
    ctx
  });
  return block;
}
function create_default_slot_13(ctx) {
  let div;
  let current;
  let if_block = (
    /*isOpen*/
    ctx[3] && create_if_block_210(ctx)
  );
  let div_levels = [
    { class: (
      /*wrapClassName*/
      ctx[12]
    ) },
    { tabindex: "-1" },
    /*$$restProps*/
    ctx[23],
    { "data-bs-theme": (
      /*theme*/
      ctx[10]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      set_attributes(div, div_data);
      add_location(div, file58, 325, 4, 7290);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*isOpen*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*isOpen*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_210(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*wrapClassName*/
        4096) && { class: (
          /*wrapClassName*/
          ctx2[12]
        ) },
        { tabindex: "-1" },
        dirty[0] & /*$$restProps*/
        8388608 && /*$$restProps*/
        ctx2[23],
        (!current || dirty[0] & /*theme*/
        1024) && { "data-bs-theme": (
          /*theme*/
          ctx2[10]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_13.name,
    type: "slot",
    source: "(324:2) <svelte:component this={outer}>",
    ctx
  });
  return block;
}
function create_if_block22(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*outer*/
    ctx[15]
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        $$slots: { default: [create_default_slot4] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*outer*/
      32768 && switch_value !== (switch_value = /*outer*/
      ctx2[15])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty[0] & /*fade, isOpen*/
        72 | dirty[1] & /*$$scope*/
        64) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block22.name,
    type: "if",
    source: "(369:0) {#if backdrop && !staticModal}",
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let modalbackdrop;
  let current;
  modalbackdrop = new ModalBackdrop_default({
    props: {
      fade: (
        /*fade*/
        ctx[6]
      ),
      isOpen: (
        /*isOpen*/
        ctx[3]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(modalbackdrop.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(modalbackdrop, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const modalbackdrop_changes = {};
      if (dirty[0] & /*fade*/
      64)
        modalbackdrop_changes.fade = /*fade*/
        ctx2[6];
      if (dirty[0] & /*isOpen*/
      8)
        modalbackdrop_changes.isOpen = /*isOpen*/
        ctx2[3];
      modalbackdrop.$set(modalbackdrop_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(modalbackdrop.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(modalbackdrop.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(modalbackdrop, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: "(370:2) <svelte:component this={outer}>",
    ctx
  });
  return block;
}
function create_fragment59(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*_isMounted*/
    ctx[13] && create_if_block_113(ctx)
  );
  let if_block1 = (
    /*backdrop*/
    ctx[4] && !/*staticModal*/
    ctx[0] && create_if_block22(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*_isMounted*/
        ctx2[13]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*_isMounted*/
          8192) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_113(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*backdrop*/
        ctx2[4] && !/*staticModal*/
        ctx2[0]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*backdrop, staticModal*/
          17) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block22(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment59.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var openCount = 0;
var dialogBaseClass = "modal-dialog";
function instance59($$self, $$props, $$invalidate) {
  let classes;
  let outer;
  const omit_props_names = [
    "class",
    "static",
    "autoFocus",
    "body",
    "centered",
    "container",
    "fullscreen",
    "header",
    "isOpen",
    "keyboard",
    "backdrop",
    "contentClassName",
    "fade",
    "labelledBy",
    "modalClassName",
    "modalStyle",
    "returnFocusAfterClose",
    "scrollable",
    "size",
    "theme",
    "toggle",
    "unmountOnClose",
    "wrapClassName"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Modal", slots, ["external", "default"]);
  const dispatch = createEventDispatcher();
  let { class: className = "" } = $$props;
  let { static: staticModal = false } = $$props;
  let { autoFocus = true } = $$props;
  let { body = false } = $$props;
  let { centered = false } = $$props;
  let { container = void 0 } = $$props;
  let { fullscreen = false } = $$props;
  let { header = void 0 } = $$props;
  let { isOpen = false } = $$props;
  let { keyboard = true } = $$props;
  let { backdrop = true } = $$props;
  let { contentClassName = "" } = $$props;
  let { fade: fade2 = true } = $$props;
  let { labelledBy = header ? `modal-${uuid()}` : void 0 } = $$props;
  let { modalClassName = "" } = $$props;
  let { modalStyle = null } = $$props;
  let { returnFocusAfterClose = true } = $$props;
  let { scrollable = false } = $$props;
  let { size = "" } = $$props;
  let { theme = null } = $$props;
  let { toggle = void 0 } = $$props;
  let { unmountOnClose = true } = $$props;
  let { wrapClassName = "" } = $$props;
  let hasOpened = false;
  let _isMounted = false;
  let _triggeringElement;
  let _originalBodyPadding;
  let _lastIsOpen = isOpen;
  let _lastHasOpened = hasOpened;
  let _dialog;
  let _mouseDownElement;
  let _removeEscListener;
  onMount(() => {
    if (isOpen) {
      init2();
      hasOpened = true;
    }
    if (hasOpened && autoFocus) {
      setFocus();
    }
  });
  onDestroy(() => {
    destroy();
    if (hasOpened) {
      close();
    }
  });
  afterUpdate(() => {
    if (isOpen && !_lastIsOpen) {
      init2();
      hasOpened = true;
    }
    if (autoFocus && hasOpened && !_lastHasOpened) {
      setFocus();
    }
    _lastIsOpen = isOpen;
    _lastHasOpened = hasOpened;
  });
  function setFocus() {
    if (_dialog && _dialog.parentNode && typeof _dialog.parentNode.focus === "function") {
      _dialog.parentNode.focus();
    }
  }
  function init2() {
    try {
      _triggeringElement = document.activeElement;
    } catch (err) {
      _triggeringElement = null;
    }
    if (!staticModal) {
      _originalBodyPadding = getOriginalBodyPadding();
      conditionallyUpdateScrollbar();
      if (openCount === 0) {
        document.body.className = classnames(document.body.className, "modal-open");
      }
      ++openCount;
    }
    $$invalidate(13, _isMounted = true);
  }
  function manageFocusAfterClose() {
    if (_triggeringElement) {
      if (typeof _triggeringElement.focus === "function" && returnFocusAfterClose) {
        _triggeringElement.focus();
      }
      _triggeringElement = null;
    }
  }
  function destroy() {
    manageFocusAfterClose();
  }
  function close() {
    if (openCount <= 1) {
      document.body.classList.remove("modal-open");
    }
    manageFocusAfterClose();
    openCount = Math.max(0, openCount - 1);
    setScrollbarWidth(_originalBodyPadding);
  }
  function handleBackdropClick(e) {
    if (e.target === _mouseDownElement) {
      if (!isOpen || !backdrop) {
        return;
      }
      const backdropElem = _dialog ? _dialog.parentNode : null;
      if (backdrop === true && backdropElem && e.target === backdropElem && toggle) {
        e.stopPropagation();
        toggle(e);
      }
    }
  }
  function onModalOpened() {
    dispatch("open");
    _removeEscListener = browserEvent(document, "keydown", (event) => {
      if (event.key && event.key === "Escape" && keyboard) {
        if (toggle && backdrop === true) {
          if (_removeEscListener)
            _removeEscListener();
          toggle(event);
        }
      }
    });
  }
  function onModalClosing() {
    dispatch("closing");
    if (_removeEscListener) {
      _removeEscListener();
    }
  }
  function onModalClosed() {
    dispatch("close");
    if (unmountOnClose) {
      destroy();
    }
    close();
    if (_isMounted) {
      hasOpened = false;
    }
    $$invalidate(13, _isMounted = false);
  }
  function handleBackdropMouseDown(e) {
    _mouseDownElement = e.target;
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      _dialog = $$value;
      $$invalidate(14, _dialog);
    });
  }
  const introstart_handler = () => dispatch("opening");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(23, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(24, className = $$new_props.class);
    if ("static" in $$new_props)
      $$invalidate(0, staticModal = $$new_props.static);
    if ("autoFocus" in $$new_props)
      $$invalidate(25, autoFocus = $$new_props.autoFocus);
    if ("body" in $$new_props)
      $$invalidate(1, body = $$new_props.body);
    if ("centered" in $$new_props)
      $$invalidate(26, centered = $$new_props.centered);
    if ("container" in $$new_props)
      $$invalidate(27, container = $$new_props.container);
    if ("fullscreen" in $$new_props)
      $$invalidate(28, fullscreen = $$new_props.fullscreen);
    if ("header" in $$new_props)
      $$invalidate(2, header = $$new_props.header);
    if ("isOpen" in $$new_props)
      $$invalidate(3, isOpen = $$new_props.isOpen);
    if ("keyboard" in $$new_props)
      $$invalidate(29, keyboard = $$new_props.keyboard);
    if ("backdrop" in $$new_props)
      $$invalidate(4, backdrop = $$new_props.backdrop);
    if ("contentClassName" in $$new_props)
      $$invalidate(5, contentClassName = $$new_props.contentClassName);
    if ("fade" in $$new_props)
      $$invalidate(6, fade2 = $$new_props.fade);
    if ("labelledBy" in $$new_props)
      $$invalidate(7, labelledBy = $$new_props.labelledBy);
    if ("modalClassName" in $$new_props)
      $$invalidate(8, modalClassName = $$new_props.modalClassName);
    if ("modalStyle" in $$new_props)
      $$invalidate(9, modalStyle = $$new_props.modalStyle);
    if ("returnFocusAfterClose" in $$new_props)
      $$invalidate(30, returnFocusAfterClose = $$new_props.returnFocusAfterClose);
    if ("scrollable" in $$new_props)
      $$invalidate(31, scrollable = $$new_props.scrollable);
    if ("size" in $$new_props)
      $$invalidate(32, size = $$new_props.size);
    if ("theme" in $$new_props)
      $$invalidate(10, theme = $$new_props.theme);
    if ("toggle" in $$new_props)
      $$invalidate(11, toggle = $$new_props.toggle);
    if ("unmountOnClose" in $$new_props)
      $$invalidate(33, unmountOnClose = $$new_props.unmountOnClose);
    if ("wrapClassName" in $$new_props)
      $$invalidate(12, wrapClassName = $$new_props.wrapClassName);
    if ("$$scope" in $$new_props)
      $$invalidate(37, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    openCount,
    createEventDispatcher,
    onDestroy,
    onMount,
    afterUpdate,
    modalIn,
    modalOut,
    InlineContainer: InlineContainer_default,
    ModalBackdrop: ModalBackdrop_default,
    ModalBody: ModalBody_default,
    ModalHeader: ModalHeader_default,
    Portal: Portal_default,
    browserEvent,
    classnames,
    conditionallyUpdateScrollbar,
    getOriginalBodyPadding,
    setScrollbarWidth,
    uuid,
    dispatch,
    className,
    staticModal,
    autoFocus,
    body,
    centered,
    container,
    fullscreen,
    header,
    isOpen,
    keyboard,
    backdrop,
    contentClassName,
    fade: fade2,
    labelledBy,
    modalClassName,
    modalStyle,
    returnFocusAfterClose,
    scrollable,
    size,
    theme,
    toggle,
    unmountOnClose,
    wrapClassName,
    hasOpened,
    _isMounted,
    _triggeringElement,
    _originalBodyPadding,
    _lastIsOpen,
    _lastHasOpened,
    _dialog,
    _mouseDownElement,
    _removeEscListener,
    setFocus,
    init: init2,
    manageFocusAfterClose,
    destroy,
    close,
    handleBackdropClick,
    onModalOpened,
    onModalClosing,
    onModalClosed,
    handleBackdropMouseDown,
    dialogBaseClass,
    outer,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(24, className = $$new_props.className);
    if ("staticModal" in $$props)
      $$invalidate(0, staticModal = $$new_props.staticModal);
    if ("autoFocus" in $$props)
      $$invalidate(25, autoFocus = $$new_props.autoFocus);
    if ("body" in $$props)
      $$invalidate(1, body = $$new_props.body);
    if ("centered" in $$props)
      $$invalidate(26, centered = $$new_props.centered);
    if ("container" in $$props)
      $$invalidate(27, container = $$new_props.container);
    if ("fullscreen" in $$props)
      $$invalidate(28, fullscreen = $$new_props.fullscreen);
    if ("header" in $$props)
      $$invalidate(2, header = $$new_props.header);
    if ("isOpen" in $$props)
      $$invalidate(3, isOpen = $$new_props.isOpen);
    if ("keyboard" in $$props)
      $$invalidate(29, keyboard = $$new_props.keyboard);
    if ("backdrop" in $$props)
      $$invalidate(4, backdrop = $$new_props.backdrop);
    if ("contentClassName" in $$props)
      $$invalidate(5, contentClassName = $$new_props.contentClassName);
    if ("fade" in $$props)
      $$invalidate(6, fade2 = $$new_props.fade);
    if ("labelledBy" in $$props)
      $$invalidate(7, labelledBy = $$new_props.labelledBy);
    if ("modalClassName" in $$props)
      $$invalidate(8, modalClassName = $$new_props.modalClassName);
    if ("modalStyle" in $$props)
      $$invalidate(9, modalStyle = $$new_props.modalStyle);
    if ("returnFocusAfterClose" in $$props)
      $$invalidate(30, returnFocusAfterClose = $$new_props.returnFocusAfterClose);
    if ("scrollable" in $$props)
      $$invalidate(31, scrollable = $$new_props.scrollable);
    if ("size" in $$props)
      $$invalidate(32, size = $$new_props.size);
    if ("theme" in $$props)
      $$invalidate(10, theme = $$new_props.theme);
    if ("toggle" in $$props)
      $$invalidate(11, toggle = $$new_props.toggle);
    if ("unmountOnClose" in $$props)
      $$invalidate(33, unmountOnClose = $$new_props.unmountOnClose);
    if ("wrapClassName" in $$props)
      $$invalidate(12, wrapClassName = $$new_props.wrapClassName);
    if ("hasOpened" in $$props)
      hasOpened = $$new_props.hasOpened;
    if ("_isMounted" in $$props)
      $$invalidate(13, _isMounted = $$new_props._isMounted);
    if ("_triggeringElement" in $$props)
      _triggeringElement = $$new_props._triggeringElement;
    if ("_originalBodyPadding" in $$props)
      _originalBodyPadding = $$new_props._originalBodyPadding;
    if ("_lastIsOpen" in $$props)
      _lastIsOpen = $$new_props._lastIsOpen;
    if ("_lastHasOpened" in $$props)
      _lastHasOpened = $$new_props._lastHasOpened;
    if ("_dialog" in $$props)
      $$invalidate(14, _dialog = $$new_props._dialog);
    if ("_mouseDownElement" in $$props)
      _mouseDownElement = $$new_props._mouseDownElement;
    if ("_removeEscListener" in $$props)
      _removeEscListener = $$new_props._removeEscListener;
    if ("outer" in $$props)
      $$invalidate(15, outer = $$new_props.outer);
    if ("classes" in $$props)
      $$invalidate(16, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*className, fullscreen, centered*/
    352321536 | $$self.$$.dirty[1] & /*size, scrollable*/
    3) {
      $:
        $$invalidate(16, classes = classnames(dialogBaseClass, className, {
          [`modal-${size}`]: size,
          "modal-fullscreen": fullscreen === true,
          [`modal-fullscreen-${fullscreen}-down`]: fullscreen && typeof fullscreen === "string",
          [`${dialogBaseClass}-centered`]: centered,
          [`${dialogBaseClass}-scrollable`]: scrollable
        }));
    }
    if ($$self.$$.dirty[0] & /*container, staticModal*/
    134217729) {
      $:
        $$invalidate(15, outer = container === "inline" || staticModal ? InlineContainer_default : Portal_default);
    }
  };
  return [
    staticModal,
    body,
    header,
    isOpen,
    backdrop,
    contentClassName,
    fade2,
    labelledBy,
    modalClassName,
    modalStyle,
    theme,
    toggle,
    wrapClassName,
    _isMounted,
    _dialog,
    outer,
    classes,
    dispatch,
    handleBackdropClick,
    onModalOpened,
    onModalClosing,
    onModalClosed,
    handleBackdropMouseDown,
    $$restProps,
    className,
    autoFocus,
    centered,
    container,
    fullscreen,
    keyboard,
    returnFocusAfterClose,
    scrollable,
    size,
    unmountOnClose,
    slots,
    div1_binding,
    introstart_handler,
    $$scope
  ];
}
var Modal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance59,
      create_fragment59,
      safe_not_equal,
      {
        class: 24,
        static: 0,
        autoFocus: 25,
        body: 1,
        centered: 26,
        container: 27,
        fullscreen: 28,
        header: 2,
        isOpen: 3,
        keyboard: 29,
        backdrop: 4,
        contentClassName: 5,
        fade: 6,
        labelledBy: 7,
        modalClassName: 8,
        modalStyle: 9,
        returnFocusAfterClose: 30,
        scrollable: 31,
        size: 32,
        theme: 10,
        toggle: 11,
        unmountOnClose: 33,
        wrapClassName: 12
      },
      add_css,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Modal",
      options,
      id: create_fragment59.name
    });
  }
  get class() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get static() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set static(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoFocus() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoFocus(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get body() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set body(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get centered() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set centered(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get container() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fullscreen() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fullscreen(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keyboard() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keyboard(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdrop() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdrop(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contentClassName() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contentClassName(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fade() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fade(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledBy() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledBy(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get modalClassName() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set modalClassName(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get modalStyle() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set modalStyle(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get returnFocusAfterClose() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set returnFocusAfterClose(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollable() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollable(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get unmountOnClose() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set unmountOnClose(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrapClassName() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrapClassName(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Modal_default = Modal;

// node_modules/@sveltestrap/sveltestrap/dist/ModalFooter/ModalFooter.svelte
var file59 = "node_modules/@sveltestrap/sveltestrap/dist/ModalFooter/ModalFooter.svelte";
function create_fragment60(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file59, 13, 0, 245);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment60.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance60($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ModalFooter", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "modal-footer"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var ModalFooter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance60, create_fragment60, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ModalFooter",
      options,
      id: create_fragment60.name
    });
  }
  get class() {
    throw new Error("<ModalFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ModalFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ModalFooter_default = ModalFooter;

// node_modules/@sveltestrap/sveltestrap/dist/Nav/Nav.svelte
var file60 = "node_modules/@sveltestrap/sveltestrap/dist/Nav/Nav.svelte";
function create_fragment61(ctx) {
  let ul;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    null
  );
  let ul_levels = [
    /*$$restProps*/
    ctx[2],
    { class: (
      /*classes*/
      ctx[1]
    ) },
    { "data-bs-theme": (
      /*theme*/
      ctx[0]
    ) }
  ];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      set_attributes(ul, ul_data);
      add_location(ul, file60, 108, 0, 2395);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) },
        (!current || dirty & /*theme*/
        1) && { "data-bs-theme": (
          /*theme*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment61.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function getVerticalClass(vertical) {
  if (!vertical) {
    return false;
  }
  if (vertical === true || vertical === "xs") {
    return "flex-column";
  }
  return `flex-${vertical}-column`;
}
function instance61($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "class",
    "tabs",
    "pills",
    "vertical",
    "horizontal",
    "justified",
    "fill",
    "navbar",
    "card",
    "theme",
    "underline"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Nav", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { tabs = false } = $$props;
  let { pills = false } = $$props;
  let { vertical = "" } = $$props;
  let { horizontal = "" } = $$props;
  let { justified = false } = $$props;
  let { fill = false } = $$props;
  let { navbar = false } = $$props;
  let { card = false } = $$props;
  let { theme = null } = $$props;
  let { underline = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("tabs" in $$new_props)
      $$invalidate(4, tabs = $$new_props.tabs);
    if ("pills" in $$new_props)
      $$invalidate(5, pills = $$new_props.pills);
    if ("vertical" in $$new_props)
      $$invalidate(6, vertical = $$new_props.vertical);
    if ("horizontal" in $$new_props)
      $$invalidate(7, horizontal = $$new_props.horizontal);
    if ("justified" in $$new_props)
      $$invalidate(8, justified = $$new_props.justified);
    if ("fill" in $$new_props)
      $$invalidate(9, fill = $$new_props.fill);
    if ("navbar" in $$new_props)
      $$invalidate(10, navbar = $$new_props.navbar);
    if ("card" in $$new_props)
      $$invalidate(11, card = $$new_props.card);
    if ("theme" in $$new_props)
      $$invalidate(0, theme = $$new_props.theme);
    if ("underline" in $$new_props)
      $$invalidate(12, underline = $$new_props.underline);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    tabs,
    pills,
    vertical,
    horizontal,
    justified,
    fill,
    navbar,
    card,
    theme,
    underline,
    getVerticalClass,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("tabs" in $$props)
      $$invalidate(4, tabs = $$new_props.tabs);
    if ("pills" in $$props)
      $$invalidate(5, pills = $$new_props.pills);
    if ("vertical" in $$props)
      $$invalidate(6, vertical = $$new_props.vertical);
    if ("horizontal" in $$props)
      $$invalidate(7, horizontal = $$new_props.horizontal);
    if ("justified" in $$props)
      $$invalidate(8, justified = $$new_props.justified);
    if ("fill" in $$props)
      $$invalidate(9, fill = $$new_props.fill);
    if ("navbar" in $$props)
      $$invalidate(10, navbar = $$new_props.navbar);
    if ("card" in $$props)
      $$invalidate(11, card = $$new_props.card);
    if ("theme" in $$props)
      $$invalidate(0, theme = $$new_props.theme);
    if ("underline" in $$props)
      $$invalidate(12, underline = $$new_props.underline);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, navbar, horizontal, vertical, tabs, card, pills, justified, fill, underline*/
    8184) {
      $:
        $$invalidate(1, classes = classnames(className, navbar ? "navbar-nav" : "nav", horizontal ? `justify-content-${horizontal}` : false, getVerticalClass(vertical), {
          "nav-tabs": tabs,
          "card-header-tabs": card && tabs,
          "nav-pills": pills,
          "card-header-pills": card && pills,
          "nav-justified": justified,
          "nav-fill": fill,
          "nav-underline": underline
        }));
    }
  };
  return [
    theme,
    classes,
    $$restProps,
    className,
    tabs,
    pills,
    vertical,
    horizontal,
    justified,
    fill,
    navbar,
    card,
    underline,
    $$scope,
    slots
  ];
}
var Nav = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance61, create_fragment61, safe_not_equal, {
      class: 3,
      tabs: 4,
      pills: 5,
      vertical: 6,
      horizontal: 7,
      justified: 8,
      fill: 9,
      navbar: 10,
      card: 11,
      theme: 0,
      underline: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Nav",
      options,
      id: create_fragment61.name
    });
  }
  get class() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabs() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabs(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pills() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pills(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vertical() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vertical(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get horizontal() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set horizontal(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get justified() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set justified(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navbar() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navbar(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get card() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set card(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get underline() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set underline(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Nav_default = Nav;

// node_modules/@sveltestrap/sveltestrap/dist/Navbar/Navbar.svelte
var file61 = "node_modules/@sveltestrap/sveltestrap/dist/Navbar/Navbar.svelte";
function create_else_block18(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block18.name,
    type: "else",
    source: "(105:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block23(ctx) {
  let container_1;
  let current;
  const container_1_spread_levels = [
    /*containerProps*/
    ctx[3]
  ];
  let container_1_props = {
    $$slots: { default: [create_default_slot5] },
    $$scope: { ctx }
  };
  for (let i = 0; i < container_1_spread_levels.length; i += 1) {
    container_1_props = assign(container_1_props, container_1_spread_levels[i]);
  }
  container_1 = new Container_default({ props: container_1_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(container_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(container_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const container_1_changes = dirty & /*containerProps*/
      8 ? get_spread_update(container_1_spread_levels, [get_spread_object(
        /*containerProps*/
        ctx2[3]
      )]) : {};
      if (dirty & /*$$scope*/
      8192) {
        container_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container_1.$set(container_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(container_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(container_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(container_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block23.name,
    type: "if",
    source: "(101:2) {#if container}",
    ctx
  });
  return block;
}
function create_default_slot5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: "(102:4) <Container {...containerProps}>",
    ctx
  });
  return block;
}
function create_fragment62(ctx) {
  let nav;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block23, create_else_block18];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*container*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let nav_levels = [
    /*$$restProps*/
    ctx[4],
    { class: (
      /*classes*/
      ctx[2]
    ) },
    { "data-bs-theme": (
      /*theme*/
      ctx[0]
    ) }
  ];
  let nav_data = {};
  for (let i = 0; i < nav_levels.length; i += 1) {
    nav_data = assign(nav_data, nav_levels[i]);
  }
  const block = {
    c: function create() {
      nav = element("nav");
      if_block.c();
      set_attributes(nav, nav_data);
      add_location(nav, file61, 99, 0, 2162);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, nav, anchor);
      if_blocks[current_block_type_index].m(nav, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(nav, null);
      }
      set_attributes(nav, nav_data = get_spread_update(nav_levels, [
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) },
        (!current || dirty & /*theme*/
        1) && { "data-bs-theme": (
          /*theme*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(nav);
      }
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment62.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function getExpandClass(expand) {
  if (expand === false) {
    return false;
  }
  if (expand === true || expand === "xs") {
    return "navbar-expand";
  }
  return `navbar-expand-${expand}`;
}
function instance62($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "container", "color", "dark", "expand", "fixed", "light", "sticky", "theme"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Navbar", slots, ["default"]);
  setContext("navbar", { inNavbar: true });
  let { class: className = "" } = $$props;
  let { container = "fluid" } = $$props;
  let { color = "" } = $$props;
  let { dark = false } = $$props;
  let { expand = "" } = $$props;
  let { fixed = "" } = $$props;
  let { light = false } = $$props;
  let { sticky = "" } = $$props;
  let { theme = null } = $$props;
  let containerProps = {
    sm: container === "sm",
    md: container === "md",
    lg: container === "lg",
    xl: container === "xl",
    xxl: container === "xxl",
    fluid: container === "fluid"
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("container" in $$new_props)
      $$invalidate(1, container = $$new_props.container);
    if ("color" in $$new_props)
      $$invalidate(6, color = $$new_props.color);
    if ("dark" in $$new_props)
      $$invalidate(7, dark = $$new_props.dark);
    if ("expand" in $$new_props)
      $$invalidate(8, expand = $$new_props.expand);
    if ("fixed" in $$new_props)
      $$invalidate(9, fixed = $$new_props.fixed);
    if ("light" in $$new_props)
      $$invalidate(10, light = $$new_props.light);
    if ("sticky" in $$new_props)
      $$invalidate(11, sticky = $$new_props.sticky);
    if ("theme" in $$new_props)
      $$invalidate(0, theme = $$new_props.theme);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    classnames,
    Container: Container_default,
    className,
    container,
    color,
    dark,
    expand,
    fixed,
    light,
    sticky,
    theme,
    containerProps,
    getExpandClass,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("container" in $$props)
      $$invalidate(1, container = $$new_props.container);
    if ("color" in $$props)
      $$invalidate(6, color = $$new_props.color);
    if ("dark" in $$props)
      $$invalidate(7, dark = $$new_props.dark);
    if ("expand" in $$props)
      $$invalidate(8, expand = $$new_props.expand);
    if ("fixed" in $$props)
      $$invalidate(9, fixed = $$new_props.fixed);
    if ("light" in $$props)
      $$invalidate(10, light = $$new_props.light);
    if ("sticky" in $$props)
      $$invalidate(11, sticky = $$new_props.sticky);
    if ("theme" in $$props)
      $$invalidate(0, theme = $$new_props.theme);
    if ("containerProps" in $$props)
      $$invalidate(3, containerProps = $$new_props.containerProps);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*dark, light, theme*/
    1153) {
      $:
        $$invalidate(0, theme = dark ? "dark" : light ? "light" : theme);
    }
    if ($$self.$$.dirty & /*className, expand, color, fixed, sticky*/
    2912) {
      $:
        $$invalidate(2, classes = classnames(className, "navbar", getExpandClass(expand), {
          [`bg-${color}`]: color,
          [`fixed-${fixed}`]: fixed,
          [`sticky-${sticky}`]: sticky
        }));
    }
  };
  return [
    theme,
    container,
    classes,
    containerProps,
    $$restProps,
    className,
    color,
    dark,
    expand,
    fixed,
    light,
    sticky,
    slots,
    $$scope
  ];
}
var Navbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance62, create_fragment62, safe_not_equal, {
      class: 5,
      container: 1,
      color: 6,
      dark: 7,
      expand: 8,
      fixed: 9,
      light: 10,
      sticky: 11,
      theme: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Navbar",
      options,
      id: create_fragment62.name
    });
  }
  get class() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get container() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dark() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dark(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expand() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expand(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fixed() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fixed(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sticky() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sticky(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Navbar_default = Navbar;

// node_modules/@sveltestrap/sveltestrap/dist/NavItem/NavItem.svelte
var file62 = "node_modules/@sveltestrap/sveltestrap/dist/NavItem/NavItem.svelte";
function create_fragment63(ctx) {
  let li;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let li_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if (default_slot)
        default_slot.c();
      set_attributes(li, li_data);
      add_location(li, file62, 19, 0, 387);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment63.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance63($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "active"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavItem", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(3, active = $$new_props.active);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, active, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(3, active = $$new_props.active);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, active*/
    12) {
      $:
        $$invalidate(0, classes = classnames(className, "nav-item", active ? "active" : false));
    }
  };
  return [classes, $$restProps, className, active, $$scope, slots];
}
var NavItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance63, create_fragment63, safe_not_equal, { class: 2, active: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavItem",
      options,
      id: create_fragment63.name
    });
  }
  get class() {
    throw new Error("<NavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<NavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<NavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<NavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavItem_default = NavItem;

// node_modules/@sveltestrap/sveltestrap/dist/NavLink/NavLink.svelte
var file63 = "node_modules/@sveltestrap/sveltestrap/dist/NavLink/NavLink.svelte";
function create_fragment64(ctx) {
  let a;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let a_levels = [
    /*$$restProps*/
    ctx[3],
    { href: (
      /*href*/
      ctx[0]
    ) },
    { class: (
      /*classes*/
      ctx[1]
    ) }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
      add_location(a, file63, 46, 0, 810);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            a,
            "click",
            /*click_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "click",
            /*handleClick*/
            ctx[2],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*href*/
        1) && { href: (
          /*href*/
          ctx2[0]
        ) },
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment64.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance64($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "disabled", "active", "href"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavLink", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { disabled = false } = $$props;
  let { active = false } = $$props;
  let { href = "#" } = $$props;
  function handleClick(e) {
    if (disabled) {
      e.preventDefault();
      e.stopImmediatePropagation();
      return;
    }
    if (href === "#") {
      e.preventDefault();
    }
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("disabled" in $$new_props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("active" in $$new_props)
      $$invalidate(6, active = $$new_props.active);
    if ("href" in $$new_props)
      $$invalidate(0, href = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    disabled,
    active,
    href,
    handleClick,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("disabled" in $$props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("active" in $$props)
      $$invalidate(6, active = $$new_props.active);
    if ("href" in $$props)
      $$invalidate(0, href = $$new_props.href);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, disabled, active*/
    112) {
      $:
        $$invalidate(1, classes = classnames(className, "nav-link", { disabled, active }));
    }
  };
  return [
    href,
    classes,
    handleClick,
    $$restProps,
    className,
    disabled,
    active,
    $$scope,
    slots,
    click_handler
  ];
}
var NavLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance64, create_fragment64, safe_not_equal, {
      class: 4,
      disabled: 5,
      active: 6,
      href: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavLink",
      options,
      id: create_fragment64.name
    });
  }
  get class() {
    throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavLink_default = NavLink;

// node_modules/@sveltestrap/sveltestrap/dist/NavbarBrand/NavbarBrand.svelte
var file64 = "node_modules/@sveltestrap/sveltestrap/dist/NavbarBrand/NavbarBrand.svelte";
function create_fragment65(ctx) {
  let a;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let a_levels = [
    /*$$restProps*/
    ctx[2],
    { class: (
      /*classes*/
      ctx[1]
    ) },
    { href: (
      /*href*/
      ctx[0]
    ) }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
      add_location(a, file64, 19, 0, 374);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*click_handler*/
          ctx[6],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) },
        (!current || dirty & /*href*/
        1) && { href: (
          /*href*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment65.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance65($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "href"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavbarBrand", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { href = "/" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("href" in $$new_props)
      $$invalidate(0, href = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, href, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("href" in $$props)
      $$invalidate(0, href = $$new_props.href);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    8) {
      $:
        $$invalidate(1, classes = classnames(className, "navbar-brand"));
    }
  };
  return [href, classes, $$restProps, className, $$scope, slots, click_handler];
}
var NavbarBrand = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance65, create_fragment65, safe_not_equal, { class: 3, href: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavbarBrand",
      options,
      id: create_fragment65.name
    });
  }
  get class() {
    throw new Error("<NavbarBrand>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<NavbarBrand>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<NavbarBrand>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<NavbarBrand>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavbarBrand_default = NavbarBrand;

// node_modules/@sveltestrap/sveltestrap/dist/NavbarToggler/NavbarToggler.svelte
var file65 = "node_modules/@sveltestrap/sveltestrap/dist/NavbarToggler/NavbarToggler.svelte";
function fallback_block5(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      attr_dev(span, "class", "navbar-toggler-icon");
      add_location(span, file65, 15, 4, 319);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block5.name,
    type: "fallback",
    source: "(15:8)      ",
    ctx
  });
  return block;
}
function create_fragment66(ctx) {
  let button;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block5(ctx);
  let button_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      set_attributes(button, button_data);
      add_location(button, file65, 13, 0, 255);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[5],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment66.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance66($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavbarToggler", slots, ["default"]);
  let { class: className = "" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "navbar-toggler"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots, click_handler];
}
var NavbarToggler = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance66, create_fragment66, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavbarToggler",
      options,
      id: create_fragment66.name
    });
  }
  get class() {
    throw new Error("<NavbarToggler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<NavbarToggler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavbarToggler_default = NavbarToggler;

// node_modules/@sveltestrap/sveltestrap/dist/OffcanvasBackdrop/OffcanvasBackdrop.svelte
var file66 = "node_modules/@sveltestrap/sveltestrap/dist/OffcanvasBackdrop/OffcanvasBackdrop.svelte";
function create_if_block24(ctx) {
  let div;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  let div_levels = [
    { role: "presentation" },
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      set_attributes(div, div_data);
      toggle_class(
        div,
        "fade",
        /*fade*/
        ctx[1]
      );
      add_location(div, file66, 12, 2, 360);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*click_handler*/
          ctx[5],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { role: "presentation" },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) }
      ]));
      toggle_class(
        div,
        "fade",
        /*fade*/
        ctx2[1]
      );
    },
    i: function intro(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div_outro)
            div_outro.end(1);
          div_intro = create_in_transition(div, backdropIn, {});
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (div_intro)
        div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(div, backdropOut, {});
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (detaching && div_outro)
        div_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block24.name,
    type: "if",
    source: "(12:0) {#if isOpen}",
    ctx
  });
  return block;
}
function create_fragment67(ctx) {
  let if_block_anchor;
  let if_block = (
    /*isOpen*/
    ctx[0] && create_if_block24(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isOpen*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isOpen*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block24(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      transition_in(if_block);
    },
    o: function outro(local) {
      transition_out(if_block);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment67.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance67($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "isOpen", "fade"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OffcanvasBackdrop", slots, []);
  let { class: className = "" } = $$props;
  let { isOpen = false } = $$props;
  let { fade: fade2 = true } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("fade" in $$new_props)
      $$invalidate(1, fade2 = $$new_props.fade);
  };
  $$self.$capture_state = () => ({
    classnames,
    backdropIn,
    backdropOut,
    className,
    isOpen,
    fade: fade2,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("fade" in $$props)
      $$invalidate(1, fade2 = $$new_props.fade);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    16) {
      $:
        $$invalidate(2, classes = classnames(className, "offcanvas-backdrop"));
    }
  };
  return [isOpen, fade2, classes, $$restProps, className, click_handler];
}
var OffcanvasBackdrop = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance67, create_fragment67, safe_not_equal, { class: 4, isOpen: 0, fade: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OffcanvasBackdrop",
      options,
      id: create_fragment67.name
    });
  }
  get class() {
    throw new Error("<OffcanvasBackdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<OffcanvasBackdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<OffcanvasBackdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<OffcanvasBackdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fade() {
    throw new Error("<OffcanvasBackdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fade(value) {
    throw new Error("<OffcanvasBackdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OffcanvasBackdrop_default = OffcanvasBackdrop;

// node_modules/@sveltestrap/sveltestrap/dist/OffcanvasBody/OffcanvasBody.svelte
var file67 = "node_modules/@sveltestrap/sveltestrap/dist/OffcanvasBody/OffcanvasBody.svelte";
function create_fragment68(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file67, 9, 0, 174);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment68.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance68($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OffcanvasBody", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "offcanvas-body"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var OffcanvasBody = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance68, create_fragment68, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OffcanvasBody",
      options,
      id: create_fragment68.name
    });
  }
  get class() {
    throw new Error("<OffcanvasBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<OffcanvasBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OffcanvasBody_default = OffcanvasBody;

// node_modules/@sveltestrap/sveltestrap/dist/OffcanvasHeader/OffcanvasHeader.svelte
var file68 = "node_modules/@sveltestrap/sveltestrap/dist/OffcanvasHeader/OffcanvasHeader.svelte";
var get_close_slot_changes2 = (dirty) => ({});
var get_close_slot_context2 = (ctx) => ({});
function create_else_block19(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block19.name,
    type: "else",
    source: "(17:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_114(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*children*/
        ctx[0]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*children*/
      1)
        set_data_dev(
          t,
          /*children*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_114.name,
    type: "if",
    source: "(15:4) {#if children}",
    ctx
  });
  return block;
}
function create_if_block25(ctx) {
  let button;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      attr_dev(
        button,
        "aria-label",
        /*closeAriaLabel*/
        ctx[1]
      );
      attr_dev(button, "class", "btn-close");
      attr_dev(button, "type", "button");
      add_location(button, file68, 22, 6, 501);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          function() {
            if (is_function(
              /*toggle*/
              ctx[2]
            ))
              ctx[2].apply(this, arguments);
          },
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*closeAriaLabel*/
      2) {
        attr_dev(
          button,
          "aria-label",
          /*closeAriaLabel*/
          ctx[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block25.name,
    type: "if",
    source: "(22:4) {#if typeof toggle === 'function'}",
    ctx
  });
  return block;
}
function fallback_block6(ctx) {
  let if_block_anchor;
  let if_block = typeof /*toggle*/
  ctx[2] === "function" && create_if_block25(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (typeof /*toggle*/
      ctx2[2] === "function") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block25(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block6.name,
    type: "fallback",
    source: "(21:21)      ",
    ctx
  });
  return block;
}
function create_fragment69(ctx) {
  let div;
  let h5;
  let current_block_type_index;
  let if_block;
  let t;
  let current;
  const if_block_creators = [create_if_block_114, create_else_block19];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*children*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const close_slot_template = (
    /*#slots*/
    ctx[7].close
  );
  const close_slot = create_slot(
    close_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_close_slot_context2
  );
  const close_slot_or_fallback = close_slot || fallback_block6(ctx);
  let div_levels = [
    /*$$restProps*/
    ctx[4],
    { class: (
      /*classes*/
      ctx[3]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      h5 = element("h5");
      if_block.c();
      t = space();
      if (close_slot_or_fallback)
        close_slot_or_fallback.c();
      attr_dev(h5, "class", "offcanvas-title");
      add_location(h5, file68, 13, 2, 324);
      set_attributes(div, div_data);
      add_location(div, file68, 12, 0, 283);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, h5);
      if_blocks[current_block_type_index].m(h5, null);
      append_dev(div, t);
      if (close_slot_or_fallback) {
        close_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(h5, null);
      }
      if (close_slot) {
        if (close_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            close_slot,
            close_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              close_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_close_slot_changes2
            ),
            get_close_slot_context2
          );
        }
      } else {
        if (close_slot_or_fallback && close_slot_or_fallback.p && (!current || dirty & /*closeAriaLabel, toggle*/
        6)) {
          close_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(close_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(close_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if_blocks[current_block_type_index].d();
      if (close_slot_or_fallback)
        close_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment69.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance69($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "children", "closeAriaLabel", "toggle"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OffcanvasHeader", slots, ["default", "close"]);
  let { class: className = "" } = $$props;
  let { children = void 0 } = $$props;
  let { closeAriaLabel = "Close" } = $$props;
  let { toggle = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("children" in $$new_props)
      $$invalidate(0, children = $$new_props.children);
    if ("closeAriaLabel" in $$new_props)
      $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
    if ("toggle" in $$new_props)
      $$invalidate(2, toggle = $$new_props.toggle);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    children,
    closeAriaLabel,
    toggle,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("children" in $$props)
      $$invalidate(0, children = $$new_props.children);
    if ("closeAriaLabel" in $$props)
      $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
    if ("toggle" in $$props)
      $$invalidate(2, toggle = $$new_props.toggle);
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    32) {
      $:
        $$invalidate(3, classes = classnames(className, "offcanvas-header"));
    }
  };
  return [
    children,
    closeAriaLabel,
    toggle,
    classes,
    $$restProps,
    className,
    $$scope,
    slots
  ];
}
var OffcanvasHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance69, create_fragment69, safe_not_equal, {
      class: 5,
      children: 0,
      closeAriaLabel: 1,
      toggle: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OffcanvasHeader",
      options,
      id: create_fragment69.name
    });
  }
  get class() {
    throw new Error("<OffcanvasHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<OffcanvasHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<OffcanvasHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<OffcanvasHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeAriaLabel() {
    throw new Error("<OffcanvasHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeAriaLabel(value) {
    throw new Error("<OffcanvasHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<OffcanvasHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<OffcanvasHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OffcanvasHeader_default = OffcanvasHeader;

// node_modules/@sveltestrap/sveltestrap/dist/Offcanvas/Offcanvas.svelte
var { document: document_1 } = globals;
var file69 = "node_modules/@sveltestrap/sveltestrap/dist/Offcanvas/Offcanvas.svelte";
function add_css2(target) {
  append_styles(target, "svelte-xe7n9u", ".overflow-noscroll{overflow:hidden;padding-right:0px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiT2ZmY2FudmFzLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFpT1Usa0JBQW9CLENBQzFCLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLGFBQWEsQ0FBRSxHQUNqQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJPZmZjYW52YXMuc3ZlbHRlIl19 */");
}
var get_header_slot_changes3 = (dirty) => ({});
var get_header_slot_context3 = (ctx) => ({});
function create_if_block_211(ctx) {
  let offcanvasheader;
  let current;
  offcanvasheader = new OffcanvasHeader_default({
    props: {
      toggle: (
        /*toggle*/
        ctx[7]
      ),
      $$slots: { default: [create_default_slot_22] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(offcanvasheader.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(offcanvasheader, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const offcanvasheader_changes = {};
      if (dirty & /*toggle*/
      128)
        offcanvasheader_changes.toggle = /*toggle*/
        ctx2[7];
      if (dirty & /*$$scope, header*/
      536870928) {
        offcanvasheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      offcanvasheader.$set(offcanvasheader_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(offcanvasheader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(offcanvasheader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(offcanvasheader, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_211.name,
    type: "if",
    source: "(204:4) {#if toggle || header || $$slots.header}",
    ctx
  });
  return block;
}
function create_if_block_36(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*header*/
        ctx[4]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*header*/
      16)
        set_data_dev(
          t,
          /*header*/
          ctx2[4]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_36.name,
    type: "if",
    source: "(206:8) {#if header}",
    ctx
  });
  return block;
}
function create_default_slot_22(ctx) {
  let t;
  let current;
  let if_block = (
    /*header*/
    ctx[4] && create_if_block_36(ctx)
  );
  const header_slot_template = (
    /*#slots*/
    ctx[27].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[29],
    get_header_slot_context3
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      if (header_slot)
        header_slot.c();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, t, anchor);
      if (header_slot) {
        header_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*header*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_36(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/
        536870912)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[29],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[29]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[29],
              dirty,
              get_header_slot_changes3
            ),
            get_header_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      if (if_block)
        if_block.d(detaching);
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_22.name,
    type: "slot",
    source: "(205:6) <OffcanvasHeader {toggle}>",
    ctx
  });
  return block;
}
function create_else_block20(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[27].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[29],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        536870912)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[29],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[29]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[29],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block20.name,
    type: "else",
    source: "(216:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_115(ctx) {
  let offcanvasbody;
  let current;
  offcanvasbody = new OffcanvasBody_default({
    props: {
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(offcanvasbody.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(offcanvasbody, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const offcanvasbody_changes = {};
      if (dirty & /*$$scope*/
      536870912) {
        offcanvasbody_changes.$$scope = { dirty, ctx: ctx2 };
      }
      offcanvasbody.$set(offcanvasbody_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(offcanvasbody.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(offcanvasbody.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(offcanvasbody, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_115.name,
    type: "if",
    source: "(212:4) {#if body}",
    ctx
  });
  return block;
}
function create_default_slot_14(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[27].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[29],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        536870912)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[29],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[29]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[29],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_14.name,
    type: "slot",
    source: "(213:6) <OffcanvasBody>",
    ctx
  });
  return block;
}
function create_if_block26(ctx) {
  let offcanvasbackdrop;
  let current;
  offcanvasbackdrop = new OffcanvasBackdrop_default({
    props: {
      fade: (
        /*fade*/
        ctx[3]
      ),
      isOpen: (
        /*isOpen*/
        ctx[0]
      )
    },
    $$inline: true
  });
  offcanvasbackdrop.$on("click", function() {
    if (is_function(
      /*toggle*/
      ctx[7] || void 0
    ))
      /*toggle*/
      (ctx[7] || void 0).apply(this, arguments);
  });
  const block = {
    c: function create() {
      create_component(offcanvasbackdrop.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(offcanvasbackdrop, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const offcanvasbackdrop_changes = {};
      if (dirty & /*fade*/
      8)
        offcanvasbackdrop_changes.fade = /*fade*/
        ctx[3];
      if (dirty & /*isOpen*/
      1)
        offcanvasbackdrop_changes.isOpen = /*isOpen*/
        ctx[0];
      offcanvasbackdrop.$set(offcanvasbackdrop_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(offcanvasbackdrop.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(offcanvasbackdrop.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(offcanvasbackdrop, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block26.name,
    type: "if",
    source: "(220:2) {#if backdrop}",
    ctx
  });
  return block;
}
function create_default_slot6(ctx) {
  let div;
  let t0;
  let current_block_type_index;
  let if_block1;
  let div_aria_hidden_value;
  let div_aria_modal_value;
  let div_role_value;
  let div_style_value;
  let t1;
  let if_block2_anchor;
  let current;
  let if_block0 = (
    /*toggle*/
    (ctx[7] || /*header*/
    ctx[4] || /*$$slots*/
    ctx[14].header) && create_if_block_211(ctx)
  );
  const if_block_creators = [create_if_block_115, create_else_block20];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*body*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div_levels = [
    /*$$restProps*/
    ctx[13],
    {
      "aria-hidden": div_aria_hidden_value = !/*isOpen*/
      ctx[0] ? true : void 0
    },
    {
      "aria-modal": div_aria_modal_value = /*isOpen*/
      ctx[0] ? true : void 0
    },
    { class: (
      /*classes*/
      ctx[11]
    ) },
    {
      role: div_role_value = /*isOpen*/
      ctx[0] ? "dialog" : void 0
    },
    { "data-bs-theme": (
      /*theme*/
      ctx[6]
    ) },
    {
      style: div_style_value = `visibility: ${/*isOpen*/
      ctx[0] || /*isTransitioning*/
      ctx[8] ? "visible" : "hidden"};${/*style*/
      ctx[5]}`
    },
    { tabindex: "-1" }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  let if_block2 = (
    /*backdrop*/
    ctx[1] && create_if_block26(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      set_attributes(div, div_data);
      add_location(div, file69, 192, 2, 4302);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      if_blocks[current_block_type_index].m(div, null);
      ctx[28](div);
      insert_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*toggle*/
        ctx2[7] || /*header*/
        ctx2[4] || /*$$slots*/
        ctx2[14].header
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*toggle, header, $$slots*/
          16528) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_211(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, null);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        8192 && /*$$restProps*/
        ctx2[13],
        (!current || dirty & /*isOpen*/
        1 && div_aria_hidden_value !== (div_aria_hidden_value = !/*isOpen*/
        ctx2[0] ? true : void 0)) && { "aria-hidden": div_aria_hidden_value },
        (!current || dirty & /*isOpen*/
        1 && div_aria_modal_value !== (div_aria_modal_value = /*isOpen*/
        ctx2[0] ? true : void 0)) && { "aria-modal": div_aria_modal_value },
        (!current || dirty & /*classes*/
        2048) && { class: (
          /*classes*/
          ctx2[11]
        ) },
        (!current || dirty & /*isOpen*/
        1 && div_role_value !== (div_role_value = /*isOpen*/
        ctx2[0] ? "dialog" : void 0)) && { role: div_role_value },
        (!current || dirty & /*theme*/
        64) && { "data-bs-theme": (
          /*theme*/
          ctx2[6]
        ) },
        (!current || dirty & /*isOpen, isTransitioning, style*/
        289 && div_style_value !== (div_style_value = `visibility: ${/*isOpen*/
        ctx2[0] || /*isTransitioning*/
        ctx2[8] ? "visible" : "hidden"};${/*style*/
        ctx2[5]}`)) && { style: div_style_value },
        { tabindex: "-1" }
      ]));
      if (
        /*backdrop*/
        ctx2[1]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*backdrop*/
          2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block26(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
        detach_dev(t1);
        detach_dev(if_block2_anchor);
      }
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      ctx[28](null);
      if (if_block2)
        if_block2.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: "(192:0) <svelte:component this={outer}>",
    ctx
  });
  return block;
}
function create_fragment70(ctx) {
  let t;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  let mounted;
  let dispose;
  var switch_value = (
    /*outer*/
    ctx[10]
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        $$slots: { default: [create_default_slot6] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      t = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          document_1.body,
          "mousedown",
          function() {
            if (is_function(
              /*handleMouseDown*/
              ctx[12]
            ))
              ctx[12].apply(this, arguments);
          },
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*outer*/
      1024 && switch_value !== (switch_value = /*outer*/
      ctx[10])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*$$scope, fade, isOpen, toggle, backdrop, $$restProps, classes, theme, isTransitioning, style, element, body, header, $$slots*/
        536898559) {
          switch_instance_changes.$$scope = { dirty, ctx };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment70.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance70($$self, $$props, $$invalidate) {
  let handleMouseDown;
  let classes;
  let outer;
  const omit_props_names = [
    "class",
    "backdrop",
    "body",
    "container",
    "fade",
    "header",
    "isOpen",
    "keyboard",
    "placement",
    "scroll",
    "sm",
    "md",
    "lg",
    "xl",
    "xxl",
    "style",
    "theme",
    "toggle"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Offcanvas", slots, ["header", "default"]);
  const $$slots = compute_slots(slots);
  const dispatch = createEventDispatcher();
  let { class: className = "" } = $$props;
  let { backdrop = true } = $$props;
  let { body = true } = $$props;
  let { container = "body" } = $$props;
  let { fade: fade2 = true } = $$props;
  let { header = "" } = $$props;
  let { isOpen = false } = $$props;
  let { keyboard = true } = $$props;
  let { placement = "start" } = $$props;
  let { scroll = false } = $$props;
  let { sm = false } = $$props;
  let { md = false } = $$props;
  let { lg = false } = $$props;
  let { xl = false } = $$props;
  let { xxl = false } = $$props;
  let { style = "" } = $$props;
  let { theme = null } = $$props;
  let { toggle = void 0 } = $$props;
  let bodyElement;
  let isTransitioning = false;
  let element2;
  let removeEscListener;
  onMount(() => $$invalidate(25, bodyElement = document.body));
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(9, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(15, className = $$new_props.class);
    if ("backdrop" in $$new_props)
      $$invalidate(1, backdrop = $$new_props.backdrop);
    if ("body" in $$new_props)
      $$invalidate(2, body = $$new_props.body);
    if ("container" in $$new_props)
      $$invalidate(16, container = $$new_props.container);
    if ("fade" in $$new_props)
      $$invalidate(3, fade2 = $$new_props.fade);
    if ("header" in $$new_props)
      $$invalidate(4, header = $$new_props.header);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("keyboard" in $$new_props)
      $$invalidate(17, keyboard = $$new_props.keyboard);
    if ("placement" in $$new_props)
      $$invalidate(18, placement = $$new_props.placement);
    if ("scroll" in $$new_props)
      $$invalidate(19, scroll = $$new_props.scroll);
    if ("sm" in $$new_props)
      $$invalidate(20, sm = $$new_props.sm);
    if ("md" in $$new_props)
      $$invalidate(21, md = $$new_props.md);
    if ("lg" in $$new_props)
      $$invalidate(22, lg = $$new_props.lg);
    if ("xl" in $$new_props)
      $$invalidate(23, xl = $$new_props.xl);
    if ("xxl" in $$new_props)
      $$invalidate(24, xxl = $$new_props.xxl);
    if ("style" in $$new_props)
      $$invalidate(5, style = $$new_props.style);
    if ("theme" in $$new_props)
      $$invalidate(6, theme = $$new_props.theme);
    if ("toggle" in $$new_props)
      $$invalidate(7, toggle = $$new_props.toggle);
    if ("$$scope" in $$new_props)
      $$invalidate(29, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    InlineContainer: InlineContainer_default,
    OffcanvasBackdrop: OffcanvasBackdrop_default,
    OffcanvasBody: OffcanvasBody_default,
    OffcanvasHeader: OffcanvasHeader_default,
    Portal: Portal_default,
    classnames,
    browserEvent,
    getTransitionDuration,
    dispatch,
    className,
    backdrop,
    body,
    container,
    fade: fade2,
    header,
    isOpen,
    keyboard,
    placement,
    scroll,
    sm,
    md,
    lg,
    xl,
    xxl,
    style,
    theme,
    toggle,
    bodyElement,
    isTransitioning,
    element: element2,
    removeEscListener,
    outer,
    classes,
    handleMouseDown
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(15, className = $$new_props.className);
    if ("backdrop" in $$props)
      $$invalidate(1, backdrop = $$new_props.backdrop);
    if ("body" in $$props)
      $$invalidate(2, body = $$new_props.body);
    if ("container" in $$props)
      $$invalidate(16, container = $$new_props.container);
    if ("fade" in $$props)
      $$invalidate(3, fade2 = $$new_props.fade);
    if ("header" in $$props)
      $$invalidate(4, header = $$new_props.header);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("keyboard" in $$props)
      $$invalidate(17, keyboard = $$new_props.keyboard);
    if ("placement" in $$props)
      $$invalidate(18, placement = $$new_props.placement);
    if ("scroll" in $$props)
      $$invalidate(19, scroll = $$new_props.scroll);
    if ("sm" in $$props)
      $$invalidate(20, sm = $$new_props.sm);
    if ("md" in $$props)
      $$invalidate(21, md = $$new_props.md);
    if ("lg" in $$props)
      $$invalidate(22, lg = $$new_props.lg);
    if ("xl" in $$props)
      $$invalidate(23, xl = $$new_props.xl);
    if ("xxl" in $$props)
      $$invalidate(24, xxl = $$new_props.xxl);
    if ("style" in $$props)
      $$invalidate(5, style = $$new_props.style);
    if ("theme" in $$props)
      $$invalidate(6, theme = $$new_props.theme);
    if ("toggle" in $$props)
      $$invalidate(7, toggle = $$new_props.toggle);
    if ("bodyElement" in $$props)
      $$invalidate(25, bodyElement = $$new_props.bodyElement);
    if ("isTransitioning" in $$props)
      $$invalidate(8, isTransitioning = $$new_props.isTransitioning);
    if ("element" in $$props)
      $$invalidate(9, element2 = $$new_props.element);
    if ("removeEscListener" in $$props)
      $$invalidate(26, removeEscListener = $$new_props.removeEscListener);
    if ("outer" in $$props)
      $$invalidate(10, outer = $$new_props.outer);
    if ("classes" in $$props)
      $$invalidate(11, classes = $$new_props.classes);
    if ("handleMouseDown" in $$props)
      $$invalidate(12, handleMouseDown = $$new_props.handleMouseDown);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*element, isOpen*/
    513) {
      $:
        if (element2) {
          $$invalidate(0, isOpen), $$invalidate(9, element2);
          $$invalidate(8, isTransitioning = true);
          dispatch(isOpen ? "opening" : "closing");
          setTimeout(
            () => {
              $$invalidate(8, isTransitioning = false);
              dispatch(isOpen ? "open" : "close");
            },
            getTransitionDuration(element2)
          );
        }
    }
    if ($$self.$$.dirty & /*bodyElement, scroll, isOpen, isTransitioning*/
    34078977) {
      $:
        if (bodyElement && !scroll) {
          bodyElement.classList.toggle("overflow-noscroll", isOpen || isTransitioning);
        }
    }
    if ($$self.$$.dirty & /*isOpen, toggle, keyboard*/
    131201) {
      $:
        if (isOpen && toggle && typeof window !== "undefined") {
          $$invalidate(26, removeEscListener = browserEvent(document, "keydown", (event) => {
            if (event.key && event.key === "Escape" && keyboard) {
              toggle();
            }
          }));
        }
    }
    if ($$self.$$.dirty & /*isOpen, removeEscListener*/
    67108865) {
      $:
        if (!isOpen && removeEscListener) {
          removeEscListener();
        }
    }
    if ($$self.$$.dirty & /*backdrop, toggle, bodyElement, isOpen*/
    33554563) {
      $:
        $$invalidate(12, handleMouseDown = backdrop && toggle && bodyElement && isOpen ? (e) => {
          if (e.target === bodyElement) {
            toggle();
          }
        } : void 0);
    }
    if ($$self.$$.dirty & /*sm, md, lg, xl, xxl, isOpen, placement, className*/
    32800769) {
      $:
        $$invalidate(11, classes = classnames(
          {
            offcanvas: !sm && !md && !lg && !xl && !xxl,
            "offcanvas-sm": sm,
            "offcanvas-md": md,
            "offcanvas-lg": lg,
            "offcanvas-xl": xl,
            "offcanvas-xxl": xxl,
            show: isOpen
          },
          `offcanvas-${placement}`,
          className
        ));
    }
    if ($$self.$$.dirty & /*container*/
    65536) {
      $:
        $$invalidate(10, outer = container === "inline" ? InlineContainer_default : Portal_default);
    }
  };
  return [
    isOpen,
    backdrop,
    body,
    fade2,
    header,
    style,
    theme,
    toggle,
    isTransitioning,
    element2,
    outer,
    classes,
    handleMouseDown,
    $$restProps,
    $$slots,
    className,
    container,
    keyboard,
    placement,
    scroll,
    sm,
    md,
    lg,
    xl,
    xxl,
    bodyElement,
    removeEscListener,
    slots,
    div_binding,
    $$scope
  ];
}
var Offcanvas = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance70,
      create_fragment70,
      safe_not_equal,
      {
        class: 15,
        backdrop: 1,
        body: 2,
        container: 16,
        fade: 3,
        header: 4,
        isOpen: 0,
        keyboard: 17,
        placement: 18,
        scroll: 19,
        sm: 20,
        md: 21,
        lg: 22,
        xl: 23,
        xxl: 24,
        style: 5,
        theme: 6,
        toggle: 7
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Offcanvas",
      options,
      id: create_fragment70.name
    });
  }
  get class() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdrop() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdrop(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get body() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set body(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get container() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fade() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fade(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keyboard() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keyboard(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placement() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placement(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scroll() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scroll(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sm() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sm(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get md() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set md(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lg() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lg(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xl() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xl(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xxl() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xxl(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Offcanvas_default = Offcanvas;

// node_modules/@sveltestrap/sveltestrap/dist/Pagination/Pagination.svelte
var file70 = "node_modules/@sveltestrap/sveltestrap/dist/Pagination/Pagination.svelte";
function create_fragment71(ctx) {
  let nav;
  let ul;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let nav_levels = [
    /*$$restProps*/
    ctx[4],
    { class: (
      /*classes*/
      ctx[3]
    ) },
    { "aria-label": (
      /*ariaLabel*/
      ctx[0]
    ) },
    { "data-bs-theme": (
      /*theme*/
      ctx[1]
    ) }
  ];
  let nav_data = {};
  for (let i = 0; i < nav_levels.length; i += 1) {
    nav_data = assign(nav_data, nav_levels[i]);
  }
  const block = {
    c: function create() {
      nav = element("nav");
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      attr_dev(
        ul,
        "class",
        /*listClasses*/
        ctx[2]
      );
      add_location(ul, file70, 45, 2, 933);
      set_attributes(nav, nav_data);
      add_location(nav, file70, 44, 0, 847);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, nav, anchor);
      append_dev(nav, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*listClasses*/
      4) {
        attr_dev(
          ul,
          "class",
          /*listClasses*/
          ctx2[2]
        );
      }
      set_attributes(nav, nav_data = get_spread_update(nav_levels, [
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4],
        (!current || dirty & /*classes*/
        8) && { class: (
          /*classes*/
          ctx2[3]
        ) },
        (!current || dirty & /*ariaLabel*/
        1) && { "aria-label": (
          /*ariaLabel*/
          ctx2[0]
        ) },
        (!current || dirty & /*theme*/
        2) && { "data-bs-theme": (
          /*theme*/
          ctx2[1]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(nav);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment71.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance71($$self, $$props, $$invalidate) {
  let classes;
  let listClasses;
  const omit_props_names = ["ariaLabel", "class", "listClassName", "size", "theme"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Pagination", slots, ["default"]);
  let { ariaLabel = "pagination" } = $$props;
  let { class: className = "" } = $$props;
  let { listClassName = "" } = $$props;
  let { size = "" } = $$props;
  let { theme = null } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ariaLabel" in $$new_props)
      $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("listClassName" in $$new_props)
      $$invalidate(6, listClassName = $$new_props.listClassName);
    if ("size" in $$new_props)
      $$invalidate(7, size = $$new_props.size);
    if ("theme" in $$new_props)
      $$invalidate(1, theme = $$new_props.theme);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    ariaLabel,
    className,
    listClassName,
    size,
    theme,
    listClasses,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("ariaLabel" in $$props)
      $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("listClassName" in $$props)
      $$invalidate(6, listClassName = $$new_props.listClassName);
    if ("size" in $$props)
      $$invalidate(7, size = $$new_props.size);
    if ("theme" in $$props)
      $$invalidate(1, theme = $$new_props.theme);
    if ("listClasses" in $$props)
      $$invalidate(2, listClasses = $$new_props.listClasses);
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    32) {
      $:
        $$invalidate(3, classes = classnames(className));
    }
    if ($$self.$$.dirty & /*listClassName, size*/
    192) {
      $:
        $$invalidate(2, listClasses = classnames(listClassName, "pagination", { [`pagination-${size}`]: !!size }));
    }
  };
  return [
    ariaLabel,
    theme,
    listClasses,
    classes,
    $$restProps,
    className,
    listClassName,
    size,
    $$scope,
    slots
  ];
}
var Pagination = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance71, create_fragment71, safe_not_equal, {
      ariaLabel: 0,
      class: 5,
      listClassName: 6,
      size: 7,
      theme: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pagination",
      options,
      id: create_fragment71.name
    });
  }
  get ariaLabel() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listClassName() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listClassName(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Pagination_default = Pagination;

// node_modules/@sveltestrap/sveltestrap/dist/PaginationItem/PaginationItem.svelte
var file71 = "node_modules/@sveltestrap/sveltestrap/dist/PaginationItem/PaginationItem.svelte";
function create_fragment72(ctx) {
  let li;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let li_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if (default_slot)
        default_slot.c();
      set_attributes(li, li_data);
      add_location(li, file71, 14, 0, 261);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment72.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance72($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "active", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PaginationItem", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  let { disabled = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(3, active = $$new_props.active);
    if ("disabled" in $$new_props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    active,
    disabled,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(3, active = $$new_props.active);
    if ("disabled" in $$props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, active, disabled*/
    28) {
      $:
        $$invalidate(0, classes = classnames(className, "page-item", { active, disabled }));
    }
  };
  return [classes, $$restProps, className, active, disabled, $$scope, slots];
}
var PaginationItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance72, create_fragment72, safe_not_equal, { class: 2, active: 3, disabled: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PaginationItem",
      options,
      id: create_fragment72.name
    });
  }
  get class() {
    throw new Error("<PaginationItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PaginationItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<PaginationItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<PaginationItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<PaginationItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<PaginationItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PaginationItem_default = PaginationItem;

// node_modules/@sveltestrap/sveltestrap/dist/PaginationLink/PaginationLink.svelte
var file72 = "node_modules/@sveltestrap/sveltestrap/dist/PaginationLink/PaginationLink.svelte";
function create_else_block21(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block21.name,
    type: "else",
    source: "(47:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block27(ctx) {
  let span0;
  let t0;
  let span1;
  let t1;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block7(ctx);
  const block = {
    c: function create() {
      span0 = element("span");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t0 = space();
      span1 = element("span");
      t1 = text(
        /*realLabel*/
        ctx[6]
      );
      attr_dev(span0, "aria-hidden", "true");
      add_location(span0, file72, 42, 4, 953);
      attr_dev(span1, "class", "visually-hidden");
      add_location(span1, file72, 45, 4, 1029);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span0, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(span0, null);
      }
      insert_dev(target, t0, anchor);
      insert_dev(target, span1, anchor);
      append_dev(span1, t1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*defaultCaret*/
        32)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*realLabel*/
      64)
        set_data_dev(
          t1,
          /*realLabel*/
          ctx2[6]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span0);
        detach_dev(t0);
        detach_dev(span1);
      }
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block27.name,
    type: "if",
    source: "(42:2) {#if previous || next || first || last}",
    ctx
  });
  return block;
}
function fallback_block7(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*defaultCaret*/
        ctx[5]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*defaultCaret*/
      32)
        set_data_dev(
          t,
          /*defaultCaret*/
          ctx2[5]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block7.name,
    type: "fallback",
    source: "(44:12) {defaultCaret}",
    ctx
  });
  return block;
}
function create_fragment73(ctx) {
  let a;
  let current_block_type_index;
  let if_block;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block27, create_else_block21];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*previous*/
      ctx2[1] || /*next*/
      ctx2[0] || /*first*/
      ctx2[2] || /*last*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let a_levels = [
    /*$$restProps*/
    ctx[8],
    { class: (
      /*classes*/
      ctx[7]
    ) },
    { href: (
      /*href*/
      ctx[4]
    ) }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if_block.c();
      set_attributes(a, a_data);
      add_location(a, file72, 40, 0, 854);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if_blocks[current_block_type_index].m(a, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          /*click_handler*/
          ctx[14],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(a, null);
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*$$restProps*/
        256 && /*$$restProps*/
        ctx2[8],
        (!current || dirty & /*classes*/
        128) && { class: (
          /*classes*/
          ctx2[7]
        ) },
        (!current || dirty & /*href*/
        16) && { href: (
          /*href*/
          ctx2[4]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment73.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance73($$self, $$props, $$invalidate) {
  let classes;
  let realLabel;
  const omit_props_names = ["class", "next", "previous", "first", "last", "ariaLabel", "href"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PaginationLink", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { next = false } = $$props;
  let { previous = false } = $$props;
  let { first = false } = $$props;
  let { last = false } = $$props;
  let { ariaLabel = "" } = $$props;
  let { href = "" } = $$props;
  let defaultAriaLabel;
  let defaultCaret;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(9, className = $$new_props.class);
    if ("next" in $$new_props)
      $$invalidate(0, next = $$new_props.next);
    if ("previous" in $$new_props)
      $$invalidate(1, previous = $$new_props.previous);
    if ("first" in $$new_props)
      $$invalidate(2, first = $$new_props.first);
    if ("last" in $$new_props)
      $$invalidate(3, last = $$new_props.last);
    if ("ariaLabel" in $$new_props)
      $$invalidate(10, ariaLabel = $$new_props.ariaLabel);
    if ("href" in $$new_props)
      $$invalidate(4, href = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    next,
    previous,
    first,
    last,
    ariaLabel,
    href,
    defaultAriaLabel,
    defaultCaret,
    realLabel,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(9, className = $$new_props.className);
    if ("next" in $$props)
      $$invalidate(0, next = $$new_props.next);
    if ("previous" in $$props)
      $$invalidate(1, previous = $$new_props.previous);
    if ("first" in $$props)
      $$invalidate(2, first = $$new_props.first);
    if ("last" in $$props)
      $$invalidate(3, last = $$new_props.last);
    if ("ariaLabel" in $$props)
      $$invalidate(10, ariaLabel = $$new_props.ariaLabel);
    if ("href" in $$props)
      $$invalidate(4, href = $$new_props.href);
    if ("defaultAriaLabel" in $$props)
      $$invalidate(11, defaultAriaLabel = $$new_props.defaultAriaLabel);
    if ("defaultCaret" in $$props)
      $$invalidate(5, defaultCaret = $$new_props.defaultCaret);
    if ("realLabel" in $$props)
      $$invalidate(6, realLabel = $$new_props.realLabel);
    if ("classes" in $$props)
      $$invalidate(7, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    512) {
      $:
        $$invalidate(7, classes = classnames(className, "page-link"));
    }
    if ($$self.$$.dirty & /*previous, next, first, last*/
    15) {
      $:
        if (previous) {
          $$invalidate(11, defaultAriaLabel = "Previous");
        } else if (next) {
          $$invalidate(11, defaultAriaLabel = "Next");
        } else if (first) {
          $$invalidate(11, defaultAriaLabel = "First");
        } else if (last) {
          $$invalidate(11, defaultAriaLabel = "Last");
        }
    }
    if ($$self.$$.dirty & /*ariaLabel, defaultAriaLabel*/
    3072) {
      $:
        $$invalidate(6, realLabel = ariaLabel || defaultAriaLabel);
    }
    if ($$self.$$.dirty & /*previous, next, first, last*/
    15) {
      $:
        if (previous) {
          $$invalidate(5, defaultCaret = "");
        } else if (next) {
          $$invalidate(5, defaultCaret = "");
        } else if (first) {
          $$invalidate(5, defaultCaret = "");
        } else if (last) {
          $$invalidate(5, defaultCaret = "");
        }
    }
  };
  return [
    next,
    previous,
    first,
    last,
    href,
    defaultCaret,
    realLabel,
    classes,
    $$restProps,
    className,
    ariaLabel,
    defaultAriaLabel,
    $$scope,
    slots,
    click_handler
  ];
}
var PaginationLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance73, create_fragment73, safe_not_equal, {
      class: 9,
      next: 0,
      previous: 1,
      first: 2,
      last: 3,
      ariaLabel: 10,
      href: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PaginationLink",
      options,
      id: create_fragment73.name
    });
  }
  get class() {
    throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get next() {
    throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set next(value) {
    throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get previous() {
    throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set previous(value) {
    throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get first() {
    throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set first(value) {
    throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get last() {
    throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set last(value) {
    throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabel() {
    throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PaginationLink_default = PaginationLink;

// node_modules/@sveltestrap/sveltestrap/dist/Popover/Popover.svelte
var { Error: Error_12 } = globals;
var file73 = "node_modules/@sveltestrap/sveltestrap/dist/Popover/Popover.svelte";
var get_title_slot_changes = (dirty) => ({});
var get_title_slot_context = (ctx) => ({});
function create_if_block28(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*outer*/
    ctx[6]
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        $$slots: { default: [create_default_slot7] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*outer*/
      64 && switch_value !== (switch_value = /*outer*/
      ctx2[6])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*$$scope, $$restProps, classes, theme, popperPlacement, popoverEl, children, title*/
        8389310) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block28.name,
    type: "if",
    source: "(198:0) {#if isOpen}",
    ctx
  });
  return block;
}
function fallback_block8(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*title*/
        ctx[3]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      8)
        set_data_dev(
          t,
          /*title*/
          ctx2[3]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block8.name,
    type: "fallback",
    source: "(210:27) {title}",
    ctx
  });
  return block;
}
function create_else_block22(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8388608)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block22.name,
    type: "else",
    source: "(215:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_116(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*children*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*children*/
      2)
        set_data_dev(
          t,
          /*children*/
          ctx2[1]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_116.name,
    type: "if",
    source: "(213:8) {#if children}",
    ctx
  });
  return block;
}
function create_default_slot7(ctx) {
  let div2;
  let div0;
  let t0;
  let h3;
  let t1;
  let div1;
  let current_block_type_index;
  let if_block;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[21].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[23],
    get_title_slot_context
  );
  const title_slot_or_fallback = title_slot || fallback_block8(ctx);
  const if_block_creators = [create_if_block_116, create_else_block22];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*children*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div2_levels = [
    /*$$restProps*/
    ctx[9],
    { class: (
      /*classes*/
      ctx[7]
    ) },
    { role: "tooltip" },
    { "data-bs-theme": (
      /*theme*/
      ctx[2]
    ) },
    {
      "x-placement": (
        /*popperPlacement*/
        ctx[5]
      )
    }
  ];
  let div_data_2 = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div_data_2 = assign(div_data_2, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      h3 = element("h3");
      if (title_slot_or_fallback)
        title_slot_or_fallback.c();
      t1 = space();
      div1 = element("div");
      if_block.c();
      attr_dev(div0, "class", "popover-arrow");
      attr_dev(div0, "data-popper-arrow", "");
      add_location(div0, file73, 207, 6, 4585);
      attr_dev(h3, "class", "popover-header");
      add_location(h3, file73, 208, 6, 4639);
      attr_dev(div1, "class", "popover-body");
      add_location(div1, file73, 211, 6, 4727);
      set_attributes(div2, div_data_2);
      add_location(div2, file73, 199, 4, 4410);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div0);
      append_dev(div2, t0);
      append_dev(div2, h3);
      if (title_slot_or_fallback) {
        title_slot_or_fallback.m(h3, null);
      }
      append_dev(div2, t1);
      append_dev(div2, div1);
      if_blocks[current_block_type_index].m(div1, null);
      ctx[22](div2);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        8388608)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[23]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[23],
              dirty,
              get_title_slot_changes
            ),
            get_title_slot_context
          );
        }
      } else {
        if (title_slot_or_fallback && title_slot_or_fallback.p && (!current || dirty & /*title*/
        8)) {
          title_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div1, null);
      }
      set_attributes(div2, div_data_2 = get_spread_update(div2_levels, [
        dirty & /*$$restProps*/
        512 && /*$$restProps*/
        ctx2[9],
        (!current || dirty & /*classes*/
        128) && { class: (
          /*classes*/
          ctx2[7]
        ) },
        { role: "tooltip" },
        (!current || dirty & /*theme*/
        4) && { "data-bs-theme": (
          /*theme*/
          ctx2[2]
        ) },
        (!current || dirty & /*popperPlacement*/
        32) && {
          "x-placement": (
            /*popperPlacement*/
            ctx2[5]
          )
        }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot_or_fallback, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot_or_fallback, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (title_slot_or_fallback)
        title_slot_or_fallback.d(detaching);
      if_blocks[current_block_type_index].d();
      ctx[22](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: "(199:2) <svelte:component this={outer}>",
    ctx
  });
  return block;
}
function create_fragment74(ctx) {
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*isOpen*/
    ctx[0] && create_if_block28(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error_12("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window,
          "mousedown",
          /*handleOutsideClick*/
          ctx[8],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isOpen*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isOpen*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block28(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment74.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance74($$self, $$props, $$invalidate) {
  let classes;
  let outer;
  const omit_props_names = [
    "class",
    "animation",
    "children",
    "container",
    "dismissible",
    "hideOnOutsideClick",
    "isOpen",
    "placement",
    "target",
    "theme",
    "title",
    "trigger"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Popover", slots, ["title", "default"]);
  let { class: className = "" } = $$props;
  let { animation = true } = $$props;
  let { children = "" } = $$props;
  let { container = void 0 } = $$props;
  let { dismissible = false } = $$props;
  let { hideOnOutsideClick = false } = $$props;
  let { isOpen = false } = $$props;
  let { placement = "top" } = $$props;
  let { target = "" } = $$props;
  let { theme = null } = $$props;
  let { title = "" } = $$props;
  let { trigger = "click" } = $$props;
  let targetEl;
  let popoverEl;
  let popperInstance;
  let bsPlacement;
  let popperPlacement = placement;
  const checkPopperPlacement = {
    name: "checkPopperPlacement",
    enabled: true,
    phase: "main",
    fn({ state }) {
      $$invalidate(5, popperPlacement = state.placement);
    }
  };
  const open = () => $$invalidate(0, isOpen = true);
  const close = () => $$invalidate(0, isOpen = false);
  const toggle = () => $$invalidate(0, isOpen = !isOpen);
  onMount(() => {
    $$invalidate(18, targetEl = document.querySelector(`#${target}`));
    switch (trigger) {
      case "hover":
        targetEl.addEventListener("mouseover", open);
        targetEl.addEventListener("mouseleave", close);
        break;
      case "focus":
        targetEl.addEventListener("focus", open);
        targetEl.addEventListener("blur", close);
        break;
      default:
        targetEl.addEventListener("click", toggle);
        if (dismissible) {
          targetEl.addEventListener("blur", close);
        }
        break;
    }
    return () => {
      switch (trigger) {
        case "hover":
          targetEl.removeEventListener("mouseover", open);
          targetEl.removeEventListener("mouseleave", close);
          break;
        case "focus":
          targetEl.removeEventListener("focus", open);
          targetEl.removeEventListener("blur", close);
          break;
        default:
          targetEl.removeEventListener("click", toggle);
          if (dismissible) {
            targetEl.removeEventListener("blur", close);
          }
          break;
      }
    };
  });
  const handleOutsideClick = (event) => {
    if (isOpen && hideOnOutsideClick && !popoverEl.contains(event.target)) {
      $$invalidate(0, isOpen = false);
    }
  };
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      popoverEl = $$value;
      $$invalidate(4, popoverEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(10, className = $$new_props.class);
    if ("animation" in $$new_props)
      $$invalidate(11, animation = $$new_props.animation);
    if ("children" in $$new_props)
      $$invalidate(1, children = $$new_props.children);
    if ("container" in $$new_props)
      $$invalidate(12, container = $$new_props.container);
    if ("dismissible" in $$new_props)
      $$invalidate(13, dismissible = $$new_props.dismissible);
    if ("hideOnOutsideClick" in $$new_props)
      $$invalidate(14, hideOnOutsideClick = $$new_props.hideOnOutsideClick);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("placement" in $$new_props)
      $$invalidate(15, placement = $$new_props.placement);
    if ("target" in $$new_props)
      $$invalidate(16, target = $$new_props.target);
    if ("theme" in $$new_props)
      $$invalidate(2, theme = $$new_props.theme);
    if ("title" in $$new_props)
      $$invalidate(3, title = $$new_props.title);
    if ("trigger" in $$new_props)
      $$invalidate(17, trigger = $$new_props.trigger);
    if ("$$scope" in $$new_props)
      $$invalidate(23, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    createPopper: createPopper3,
    classnames,
    InlineContainer: InlineContainer_default,
    Portal: Portal_default,
    className,
    animation,
    children,
    container,
    dismissible,
    hideOnOutsideClick,
    isOpen,
    placement,
    target,
    theme,
    title,
    trigger,
    targetEl,
    popoverEl,
    popperInstance,
    bsPlacement,
    popperPlacement,
    checkPopperPlacement,
    open,
    close,
    toggle,
    handleOutsideClick,
    outer,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(10, className = $$new_props.className);
    if ("animation" in $$props)
      $$invalidate(11, animation = $$new_props.animation);
    if ("children" in $$props)
      $$invalidate(1, children = $$new_props.children);
    if ("container" in $$props)
      $$invalidate(12, container = $$new_props.container);
    if ("dismissible" in $$props)
      $$invalidate(13, dismissible = $$new_props.dismissible);
    if ("hideOnOutsideClick" in $$props)
      $$invalidate(14, hideOnOutsideClick = $$new_props.hideOnOutsideClick);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("placement" in $$props)
      $$invalidate(15, placement = $$new_props.placement);
    if ("target" in $$props)
      $$invalidate(16, target = $$new_props.target);
    if ("theme" in $$props)
      $$invalidate(2, theme = $$new_props.theme);
    if ("title" in $$props)
      $$invalidate(3, title = $$new_props.title);
    if ("trigger" in $$props)
      $$invalidate(17, trigger = $$new_props.trigger);
    if ("targetEl" in $$props)
      $$invalidate(18, targetEl = $$new_props.targetEl);
    if ("popoverEl" in $$props)
      $$invalidate(4, popoverEl = $$new_props.popoverEl);
    if ("popperInstance" in $$props)
      $$invalidate(19, popperInstance = $$new_props.popperInstance);
    if ("bsPlacement" in $$props)
      $$invalidate(20, bsPlacement = $$new_props.bsPlacement);
    if ("popperPlacement" in $$props)
      $$invalidate(5, popperPlacement = $$new_props.popperPlacement);
    if ("outer" in $$props)
      $$invalidate(6, outer = $$new_props.outer);
    if ("classes" in $$props)
      $$invalidate(7, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*isOpen, popoverEl, targetEl, placement, popperInstance*/
    819217) {
      $: {
        if (isOpen && popoverEl) {
          $$invalidate(19, popperInstance = createPopper3(targetEl, popoverEl, {
            placement,
            modifiers: [
              checkPopperPlacement,
              {
                name: "offset",
                options: {
                  offset: () => {
                    return [0, 8];
                  }
                }
              }
            ]
          }));
        } else if (popperInstance) {
          popperInstance.destroy();
          $$invalidate(19, popperInstance = void 0);
        }
      }
    }
    if ($$self.$$.dirty & /*target*/
    65536) {
      $:
        if (!target) {
          throw new Error("Need target!");
        }
    }
    if ($$self.$$.dirty & /*popperPlacement*/
    32) {
      $: {
        if (popperPlacement === "left") {
          $$invalidate(20, bsPlacement = "start");
        } else if (popperPlacement === "right") {
          $$invalidate(20, bsPlacement = "end");
        } else {
          $$invalidate(20, bsPlacement = popperPlacement);
        }
      }
    }
    if ($$self.$$.dirty & /*className, animation, bsPlacement, isOpen*/
    1051649) {
      $:
        $$invalidate(7, classes = classnames(className, "popover", animation ? "fade" : false, `bs-popover-${bsPlacement}`, isOpen ? "show" : false));
    }
    if ($$self.$$.dirty & /*container*/
    4096) {
      $:
        $$invalidate(6, outer = container === "inline" ? InlineContainer_default : Portal_default);
    }
  };
  return [
    isOpen,
    children,
    theme,
    title,
    popoverEl,
    popperPlacement,
    outer,
    classes,
    handleOutsideClick,
    $$restProps,
    className,
    animation,
    container,
    dismissible,
    hideOnOutsideClick,
    placement,
    target,
    trigger,
    targetEl,
    popperInstance,
    bsPlacement,
    slots,
    div2_binding,
    $$scope
  ];
}
var Popover = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance74, create_fragment74, safe_not_equal, {
      class: 10,
      animation: 11,
      children: 1,
      container: 12,
      dismissible: 13,
      hideOnOutsideClick: 14,
      isOpen: 0,
      placement: 15,
      target: 16,
      theme: 2,
      title: 3,
      trigger: 17
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Popover",
      options,
      id: create_fragment74.name
    });
  }
  get class() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animation() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animation(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get container() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dismissible() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dismissible(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideOnOutsideClick() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideOnOutsideClick(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placement() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placement(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get trigger() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set trigger(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Popover_default = Popover;

// node_modules/@sveltestrap/sveltestrap/dist/Progress/Progress.svelte
var file74 = "node_modules/@sveltestrap/sveltestrap/dist/Progress/Progress.svelte";
function create_else_block_14(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_212, create_else_block_23];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*multi*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div_levels = [
    /*$$restProps*/
    ctx[8],
    { "data-bs-theme": (
      /*theme*/
      ctx[3]
    ) },
    { class: (
      /*classes*/
      ctx[7]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      set_attributes(div, div_data);
      add_location(div, file74, 95, 2, 1816);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        256 && /*$$restProps*/
        ctx2[8],
        (!current || dirty & /*theme*/
        8) && { "data-bs-theme": (
          /*theme*/
          ctx2[3]
        ) },
        (!current || dirty & /*classes*/
        128) && { class: (
          /*classes*/
          ctx2[7]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_14.name,
    type: "else",
    source: "(95:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block29(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_117, create_else_block23];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*multi*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block29.name,
    type: "if",
    source: "(78:0) {#if bar}",
    ctx
  });
  return block;
}
function create_else_block_23(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(
        div,
        "class",
        /*progressBarClasses*/
        ctx[6]
      );
      set_style(
        div,
        "width",
        /*percent*/
        ctx[5] + "%"
      );
      attr_dev(
        div,
        "data-bs-theme",
        /*theme*/
        ctx[3]
      );
      attr_dev(div, "role", "progressbar");
      attr_dev(
        div,
        "aria-valuenow",
        /*value*/
        ctx[4]
      );
      attr_dev(div, "aria-valuemin", "0");
      attr_dev(
        div,
        "aria-valuemax",
        /*max*/
        ctx[1]
      );
      add_location(div, file74, 99, 6, 1926);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*progressBarClasses*/
      64) {
        attr_dev(
          div,
          "class",
          /*progressBarClasses*/
          ctx2[6]
        );
      }
      if (!current || dirty & /*percent*/
      32) {
        set_style(
          div,
          "width",
          /*percent*/
          ctx2[5] + "%"
        );
      }
      if (!current || dirty & /*theme*/
      8) {
        attr_dev(
          div,
          "data-bs-theme",
          /*theme*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*value*/
      16) {
        attr_dev(
          div,
          "aria-valuenow",
          /*value*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*max*/
      2) {
        attr_dev(
          div,
          "aria-valuemax",
          /*max*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_23.name,
    type: "else",
    source: "(99:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_212(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_212.name,
    type: "if",
    source: "(97:4) {#if multi}",
    ctx
  });
  return block;
}
function create_else_block23(ctx) {
  let div;
  let div_style_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[8],
    { class: (
      /*progressBarClasses*/
      ctx[6]
    ) },
    {
      style: div_style_value = "width: " + /*percent*/
      ctx[5] + "%"
    },
    { "data-bs-theme": (
      /*theme*/
      ctx[3]
    ) },
    { role: "progressbar" },
    { "aria-valuenow": (
      /*value*/
      ctx[4]
    ) },
    { "aria-valuemin": "0" },
    { "aria-valuemax": (
      /*max*/
      ctx[1]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file74, 81, 4, 1542);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        256 && /*$$restProps*/
        ctx2[8],
        (!current || dirty & /*progressBarClasses*/
        64) && { class: (
          /*progressBarClasses*/
          ctx2[6]
        ) },
        (!current || dirty & /*percent*/
        32 && div_style_value !== (div_style_value = "width: " + /*percent*/
        ctx2[5] + "%")) && { style: div_style_value },
        (!current || dirty & /*theme*/
        8) && { "data-bs-theme": (
          /*theme*/
          ctx2[3]
        ) },
        { role: "progressbar" },
        (!current || dirty & /*value*/
        16) && { "aria-valuenow": (
          /*value*/
          ctx2[4]
        ) },
        { "aria-valuemin": "0" },
        (!current || dirty & /*max*/
        2) && { "aria-valuemax": (
          /*max*/
          ctx2[1]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block23.name,
    type: "else",
    source: "(81:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_117(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_117.name,
    type: "if",
    source: "(79:2) {#if multi}",
    ctx
  });
  return block;
}
function create_fragment75(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block29, create_else_block_14];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*bar*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment75.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance75($$self, $$props, $$invalidate) {
  let classes;
  let progressBarClasses;
  let percent;
  const omit_props_names = [
    "animated",
    "bar",
    "barClassName",
    "class",
    "color",
    "max",
    "multi",
    "striped",
    "theme",
    "value"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Progress", slots, ["default"]);
  let { animated = false } = $$props;
  let { bar = false } = $$props;
  let { barClassName = "" } = $$props;
  let { class: className = "" } = $$props;
  let { color = "" } = $$props;
  let { max: max2 = 100 } = $$props;
  let { multi = false } = $$props;
  let { striped = false } = $$props;
  let { theme = null } = $$props;
  let { value = 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("animated" in $$new_props)
      $$invalidate(9, animated = $$new_props.animated);
    if ("bar" in $$new_props)
      $$invalidate(0, bar = $$new_props.bar);
    if ("barClassName" in $$new_props)
      $$invalidate(10, barClassName = $$new_props.barClassName);
    if ("class" in $$new_props)
      $$invalidate(11, className = $$new_props.class);
    if ("color" in $$new_props)
      $$invalidate(12, color = $$new_props.color);
    if ("max" in $$new_props)
      $$invalidate(1, max2 = $$new_props.max);
    if ("multi" in $$new_props)
      $$invalidate(2, multi = $$new_props.multi);
    if ("striped" in $$new_props)
      $$invalidate(13, striped = $$new_props.striped);
    if ("theme" in $$new_props)
      $$invalidate(3, theme = $$new_props.theme);
    if ("value" in $$new_props)
      $$invalidate(4, value = $$new_props.value);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    animated,
    bar,
    barClassName,
    className,
    color,
    max: max2,
    multi,
    striped,
    theme,
    value,
    percent,
    progressBarClasses,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("animated" in $$props)
      $$invalidate(9, animated = $$new_props.animated);
    if ("bar" in $$props)
      $$invalidate(0, bar = $$new_props.bar);
    if ("barClassName" in $$props)
      $$invalidate(10, barClassName = $$new_props.barClassName);
    if ("className" in $$props)
      $$invalidate(11, className = $$new_props.className);
    if ("color" in $$props)
      $$invalidate(12, color = $$new_props.color);
    if ("max" in $$props)
      $$invalidate(1, max2 = $$new_props.max);
    if ("multi" in $$props)
      $$invalidate(2, multi = $$new_props.multi);
    if ("striped" in $$props)
      $$invalidate(13, striped = $$new_props.striped);
    if ("theme" in $$props)
      $$invalidate(3, theme = $$new_props.theme);
    if ("value" in $$props)
      $$invalidate(4, value = $$new_props.value);
    if ("percent" in $$props)
      $$invalidate(5, percent = $$new_props.percent);
    if ("progressBarClasses" in $$props)
      $$invalidate(6, progressBarClasses = $$new_props.progressBarClasses);
    if ("classes" in $$props)
      $$invalidate(7, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    2048) {
      $:
        $$invalidate(7, classes = classnames(className, "progress"));
    }
    if ($$self.$$.dirty & /*bar, className, barClassName, animated, color, striped*/
    15873) {
      $:
        $$invalidate(6, progressBarClasses = classnames("progress-bar", bar ? className || barClassName : barClassName, animated ? "progress-bar-animated" : null, color ? `text-bg-${color}` : null, striped || animated ? "progress-bar-striped" : null));
    }
    if ($$self.$$.dirty & /*value, max*/
    18) {
      $:
        $$invalidate(5, percent = parseInt(value, 10) / parseInt(max2, 10) * 100);
    }
  };
  return [
    bar,
    max2,
    multi,
    theme,
    value,
    percent,
    progressBarClasses,
    classes,
    $$restProps,
    animated,
    barClassName,
    className,
    color,
    striped,
    $$scope,
    slots
  ];
}
var Progress = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance75, create_fragment75, safe_not_equal, {
      animated: 9,
      bar: 0,
      barClassName: 10,
      class: 11,
      color: 12,
      max: 1,
      multi: 2,
      striped: 13,
      theme: 3,
      value: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Progress",
      options,
      id: create_fragment75.name
    });
  }
  get animated() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animated(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bar() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bar(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get barClassName() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set barClassName(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multi() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multi(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get striped() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set striped(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Progress_default = Progress;

// node_modules/@sveltestrap/sveltestrap/dist/Row/Row.svelte
var file75 = "node_modules/@sveltestrap/sveltestrap/dist/Row/Row.svelte";
function create_fragment76(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[2],
    { class: (
      /*classes*/
      ctx[1]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file75, 35, 0, 997);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[9](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2],
        (!current || dirty & /*classes*/
        2) && { class: (
          /*classes*/
          ctx2[1]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[9](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment76.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function getCols(cols) {
  const colsValue = parseInt(cols);
  if (!isNaN(colsValue)) {
    if (colsValue > 0) {
      return [`row-cols-${colsValue}`];
    }
  } else if (typeof cols === "object") {
    return ["xs", "sm", "md", "lg", "xl"].map((colWidth) => {
      const isXs = colWidth === "xs";
      const colSizeInterfix = isXs ? "-" : `-${colWidth}-`;
      const value = cols[colWidth];
      if (typeof value === "number" && value > 0) {
        return `row-cols${colSizeInterfix}${value}`;
      }
      return null;
    }).filter((value) => !!value);
  }
  return [];
}
function instance76($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "noGutters", "form", "cols", "inner"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Row", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { noGutters = false } = $$props;
  let { form = false } = $$props;
  let { cols = 0 } = $$props;
  let { inner = void 0 } = $$props;
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(0, inner);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("noGutters" in $$new_props)
      $$invalidate(4, noGutters = $$new_props.noGutters);
    if ("form" in $$new_props)
      $$invalidate(5, form = $$new_props.form);
    if ("cols" in $$new_props)
      $$invalidate(6, cols = $$new_props.cols);
    if ("inner" in $$new_props)
      $$invalidate(0, inner = $$new_props.inner);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    noGutters,
    form,
    cols,
    inner,
    getCols,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("noGutters" in $$props)
      $$invalidate(4, noGutters = $$new_props.noGutters);
    if ("form" in $$props)
      $$invalidate(5, form = $$new_props.form);
    if ("cols" in $$props)
      $$invalidate(6, cols = $$new_props.cols);
    if ("inner" in $$props)
      $$invalidate(0, inner = $$new_props.inner);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, noGutters, form, cols*/
    120) {
      $:
        $$invalidate(1, classes = classnames(className, noGutters ? "gx-0" : null, form ? "form-row" : "row", ...getCols(cols)));
    }
  };
  return [
    inner,
    classes,
    $$restProps,
    className,
    noGutters,
    form,
    cols,
    $$scope,
    slots,
    div_binding
  ];
}
var Row = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance76, create_fragment76, safe_not_equal, {
      class: 3,
      noGutters: 4,
      form: 5,
      cols: 6,
      inner: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Row",
      options,
      id: create_fragment76.name
    });
  }
  get class() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noGutters() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noGutters(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get form() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set form(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cols() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cols(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inner() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inner(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Row_default = Row;

// node_modules/@sveltestrap/sveltestrap/dist/Spinner/Spinner.svelte
var file76 = "node_modules/@sveltestrap/sveltestrap/dist/Spinner/Spinner.svelte";
function fallback_block9(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Loading...");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block9.name,
    type: "fallback",
    source: "(41:10) Loading...",
    ctx
  });
  return block;
}
function create_fragment77(ctx) {
  let div;
  let span;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block9(ctx);
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { role: "status" },
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      span = element("span");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      attr_dev(span, "class", "visually-hidden");
      add_location(span, file76, 39, 2, 716);
      set_attributes(div, div_data);
      add_location(div, file76, 38, 0, 661);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, span);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        { role: "status" },
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment77.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance77($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "type", "size", "color"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Spinner", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { type = "border" } = $$props;
  let { size = "" } = $$props;
  let { color = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("type" in $$new_props)
      $$invalidate(3, type = $$new_props.type);
    if ("size" in $$new_props)
      $$invalidate(4, size = $$new_props.size);
    if ("color" in $$new_props)
      $$invalidate(5, color = $$new_props.color);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    type,
    size,
    color,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("type" in $$props)
      $$invalidate(3, type = $$new_props.type);
    if ("size" in $$props)
      $$invalidate(4, size = $$new_props.size);
    if ("color" in $$props)
      $$invalidate(5, color = $$new_props.color);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, size, type, color*/
    60) {
      $:
        $$invalidate(0, classes = classnames(className, size ? `spinner-${type}-${size}` : false, `spinner-${type}`, color ? `text-${color}` : false));
    }
  };
  return [classes, $$restProps, className, type, size, color, $$scope, slots];
}
var Spinner = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance77, create_fragment77, safe_not_equal, { class: 2, type: 3, size: 4, color: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Spinner",
      options,
      id: create_fragment77.name
    });
  }
  get class() {
    throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Spinner_default = Spinner;

// node_modules/@sveltestrap/sveltestrap/dist/Styles/Styles.svelte
var { document: document_12 } = globals;
var file77 = "node_modules/@sveltestrap/sveltestrap/dist/Styles/Styles.svelte";
function create_if_block30(ctx) {
  let link;
  const block = {
    c: function create() {
      link = element("link");
      attr_dev(link, "rel", "stylesheet");
      attr_dev(link, "href", "https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.2/font/bootstrap-icons.min.css");
      add_location(link, file77, 17, 4, 538);
    },
    m: function mount(target, anchor) {
      insert_dev(target, link, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(link);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block30.name,
    type: "if",
    source: "(17:2) {#if icons}",
    ctx
  });
  return block;
}
function create_fragment78(ctx) {
  let link;
  let if_block_anchor;
  let if_block = (
    /*icons*/
    ctx[0] && create_if_block30(ctx)
  );
  const block = {
    c: function create() {
      link = element("link");
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr_dev(link, "rel", "stylesheet");
      attr_dev(link, "href", "https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css");
      add_location(link, file77, 14, 2, 414);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      append_dev(document_12.head, link);
      if (if_block)
        if_block.m(document_12.head, null);
      append_dev(document_12.head, if_block_anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*icons*/
        ctx2[0]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block30(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      detach_dev(link);
      if (if_block)
        if_block.d(detaching);
      detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment78.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance78($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Styles", slots, []);
  let { icons = true } = $$props;
  let { theme = void 0 } = $$props;
  const writable_props = ["icons", "theme"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Styles> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("icons" in $$props2)
      $$invalidate(0, icons = $$props2.icons);
    if ("theme" in $$props2)
      $$invalidate(1, theme = $$props2.theme);
  };
  $$self.$capture_state = () => ({ icons, theme });
  $$self.$inject_state = ($$props2) => {
    if ("icons" in $$props2)
      $$invalidate(0, icons = $$props2.icons);
    if ("theme" in $$props2)
      $$invalidate(1, theme = $$props2.theme);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*theme*/
    2) {
      $:
        if (typeof document !== "undefined" && theme !== void 0) {
          if (theme === "auto" && window.matchMedia("(prefers-color-scheme: dark)").matches) {
            document.documentElement.setAttribute("data-bs-theme", "dark");
          } else {
            document.documentElement.setAttribute("data-bs-theme", theme);
          }
        }
    }
  };
  return [icons, theme];
}
var Styles = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance78, create_fragment78, safe_not_equal, { icons: 0, theme: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Styles",
      options,
      id: create_fragment78.name
    });
  }
  get icons() {
    throw new Error("<Styles>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icons(value) {
    throw new Error("<Styles>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Styles>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Styles>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Styles_default = Styles;

// node_modules/@sveltestrap/sveltestrap/dist/Colgroup/Colgroup.svelte
var file78 = "node_modules/@sveltestrap/sveltestrap/dist/Colgroup/Colgroup.svelte";
function create_fragment79(ctx) {
  let colgroup;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      colgroup = element("colgroup");
      if (default_slot)
        default_slot.c();
      add_location(colgroup, file78, 6, 0, 92);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, colgroup, anchor);
      if (default_slot) {
        default_slot.m(colgroup, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(colgroup);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment79.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance79($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Colgroup", slots, ["default"]);
  setContext("colgroup", true);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Colgroup> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ setContext });
  return [$$scope, slots];
}
var Colgroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance79, create_fragment79, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Colgroup",
      options,
      id: create_fragment79.name
    });
  }
};
var Colgroup_default = Colgroup;

// node_modules/@sveltestrap/sveltestrap/dist/ResponsiveContainer/ResponsiveContainer.svelte
var file79 = "node_modules/@sveltestrap/sveltestrap/dist/ResponsiveContainer/ResponsiveContainer.svelte";
function create_else_block24(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block24.name,
    type: "else",
    source: "(16:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block31(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(
        div,
        "class",
        /*responsiveClassName*/
        ctx[1]
      );
      add_location(div, file79, 14, 2, 343);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*responsiveClassName*/
      2) {
        attr_dev(
          div,
          "class",
          /*responsiveClassName*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block31.name,
    type: "if",
    source: "(14:0) {#if responsive}",
    ctx
  });
  return block;
}
function create_fragment80(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block31, create_else_block24];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*responsive*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment80.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance80($$self, $$props, $$invalidate) {
  let responsiveClassName;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ResponsiveContainer", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { responsive = false } = $$props;
  const writable_props = ["class", "responsive"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ResponsiveContainer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(2, className = $$props2.class);
    if ("responsive" in $$props2)
      $$invalidate(0, responsive = $$props2.responsive);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    responsive,
    responsiveClassName
  });
  $$self.$inject_state = ($$props2) => {
    if ("className" in $$props2)
      $$invalidate(2, className = $$props2.className);
    if ("responsive" in $$props2)
      $$invalidate(0, responsive = $$props2.responsive);
    if ("responsiveClassName" in $$props2)
      $$invalidate(1, responsiveClassName = $$props2.responsiveClassName);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, responsive*/
    5) {
      $:
        $$invalidate(1, responsiveClassName = classnames(className, {
          "table-responsive": responsive === true,
          [`table-responsive-${responsive}`]: typeof responsive === "string"
        }));
    }
  };
  return [responsive, responsiveClassName, className, $$scope, slots];
}
var ResponsiveContainer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance80, create_fragment80, safe_not_equal, { class: 2, responsive: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ResponsiveContainer",
      options,
      id: create_fragment80.name
    });
  }
  get class() {
    throw new Error("<ResponsiveContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ResponsiveContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get responsive() {
    throw new Error("<ResponsiveContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set responsive(value) {
    throw new Error("<ResponsiveContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ResponsiveContainer_default = ResponsiveContainer;

// node_modules/@sveltestrap/sveltestrap/dist/TableFooter/TableFooter.svelte
var file80 = "node_modules/@sveltestrap/sveltestrap/dist/TableFooter/TableFooter.svelte";
function create_fragment81(ctx) {
  let tfoot;
  let tr;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  let tfoot_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let tfoot_data = {};
  for (let i = 0; i < tfoot_levels.length; i += 1) {
    tfoot_data = assign(tfoot_data, tfoot_levels[i]);
  }
  const block = {
    c: function create() {
      tfoot = element("tfoot");
      tr = element("tr");
      if (default_slot)
        default_slot.c();
      add_location(tr, file80, 7, 2, 117);
      set_attributes(tfoot, tfoot_data);
      add_location(tfoot, file80, 6, 0, 90);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, tfoot, anchor);
      append_dev(tfoot, tr);
      if (default_slot) {
        default_slot.m(tr, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(tfoot, tfoot_data = get_spread_update(tfoot_levels, [dirty & /*$$restProps*/
      1 && /*$$restProps*/
      ctx2[0]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(tfoot);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment81.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance81($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableFooter", slots, ["default"]);
  setContext("footer", true);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ setContext });
  return [$$restProps, $$scope, slots];
}
var TableFooter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance81, create_fragment81, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableFooter",
      options,
      id: create_fragment81.name
    });
  }
};
var TableFooter_default = TableFooter;

// node_modules/@sveltestrap/sveltestrap/dist/TableHeader/TableHeader.svelte
var file81 = "node_modules/@sveltestrap/sveltestrap/dist/TableHeader/TableHeader.svelte";
function create_fragment82(ctx) {
  let thead;
  let tr;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  let thead_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let thead_data = {};
  for (let i = 0; i < thead_levels.length; i += 1) {
    thead_data = assign(thead_data, thead_levels[i]);
  }
  const block = {
    c: function create() {
      thead = element("thead");
      tr = element("tr");
      if (default_slot)
        default_slot.c();
      add_location(tr, file81, 7, 2, 117);
      set_attributes(thead, thead_data);
      add_location(thead, file81, 6, 0, 90);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, thead, anchor);
      append_dev(thead, tr);
      if (default_slot) {
        default_slot.m(tr, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(thead, thead_data = get_spread_update(thead_levels, [dirty & /*$$restProps*/
      1 && /*$$restProps*/
      ctx2[0]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(thead);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment82.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance82($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableHeader", slots, ["default"]);
  setContext("header", true);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ setContext });
  return [$$restProps, $$scope, slots];
}
var TableHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance82, create_fragment82, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableHeader",
      options,
      id: create_fragment82.name
    });
  }
};
var TableHeader_default = TableHeader;

// node_modules/@sveltestrap/sveltestrap/dist/Table/Table.svelte
var file82 = "node_modules/@sveltestrap/sveltestrap/dist/Table/Table.svelte";
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i];
  return child_ctx;
}
var get_default_slot_changes = (dirty) => ({ row: dirty & /*rows*/
2 });
var get_default_slot_context = (ctx) => ({ row: (
  /*row*/
  ctx[12]
) });
function create_else_block25(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block25.name,
    type: "else",
    source: "(88:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block32(ctx) {
  let colgroup;
  let t0;
  let tableheader;
  let t1;
  let tbody;
  let t2;
  let tablefooter;
  let current;
  colgroup = new Colgroup_default({
    props: {
      $$slots: { default: [create_default_slot_32] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tableheader = new TableHeader_default({
    props: {
      $$slots: { default: [create_default_slot_23] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let each_value = ensure_array_like_dev(
    /*rows*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  tablefooter = new TableFooter_default({
    props: {
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(colgroup.$$.fragment);
      t0 = space();
      create_component(tableheader.$$.fragment);
      t1 = space();
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      create_component(tablefooter.$$.fragment);
      add_location(tbody, file82, 77, 6, 1743);
    },
    m: function mount(target, anchor) {
      mount_component(colgroup, target, anchor);
      insert_dev(target, t0, anchor);
      mount_component(tableheader, target, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, tbody, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tbody, null);
        }
      }
      insert_dev(target, t2, anchor);
      mount_component(tablefooter, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const colgroup_changes = {};
      if (dirty & /*$$scope*/
      2048) {
        colgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      colgroup.$set(colgroup_changes);
      const tableheader_changes = {};
      if (dirty & /*$$scope*/
      2048) {
        tableheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tableheader.$set(tableheader_changes);
      if (dirty & /*$$scope, rows*/
      2050) {
        each_value = ensure_array_like_dev(
          /*rows*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(tbody, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      const tablefooter_changes = {};
      if (dirty & /*$$scope*/
      2048) {
        tablefooter_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablefooter.$set(tablefooter_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(colgroup.$$.fragment, local);
      transition_in(tableheader.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(tablefooter.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(colgroup.$$.fragment, local);
      transition_out(tableheader.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(tablefooter.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(tbody);
        detach_dev(t2);
      }
      destroy_component(colgroup, detaching);
      destroy_component(tableheader, detaching);
      destroy_each(each_blocks, detaching);
      destroy_component(tablefooter, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block32.name,
    type: "if",
    source: "(71:4) {#if rows}",
    ctx
  });
  return block;
}
function create_default_slot_32(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_32.name,
    type: "slot",
    source: "(72:6) <Colgroup>",
    ctx
  });
  return block;
}
function create_default_slot_23(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_23.name,
    type: "slot",
    source: "(75:6) <TableHeader>",
    ctx
  });
  return block;
}
function create_each_block3(ctx) {
  let tr;
  let t;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      tr = element("tr");
      if (default_slot)
        default_slot.c();
      t = space();
      add_location(tr, file82, 79, 10, 1789);
    },
    m: function mount(target, anchor) {
      insert_dev(target, tr, anchor);
      if (default_slot) {
        default_slot.m(tr, null);
      }
      append_dev(tr, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, rows*/
        2050)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(tr);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(79:8) {#each rows as row}",
    ctx
  });
  return block;
}
function create_default_slot_15(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_15.name,
    type: "slot",
    source: "(85:6) <TableFooter>",
    ctx
  });
  return block;
}
function create_default_slot8(ctx) {
  let table;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block32, create_else_block25];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*rows*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let table_levels = [
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) }
  ];
  let table_data = {};
  for (let i = 0; i < table_levels.length; i += 1) {
    table_data = assign(table_data, table_levels[i]);
  }
  const block = {
    c: function create() {
      table = element("table");
      if_block.c();
      set_attributes(table, table_data);
      add_location(table, file82, 69, 2, 1571);
    },
    m: function mount(target, anchor) {
      insert_dev(target, table, anchor);
      if_blocks[current_block_type_index].m(table, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(table, null);
      }
      set_attributes(table, table_data = get_spread_update(table_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(table);
      }
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot8.name,
    type: "slot",
    source: "(69:0) <ResponsiveContainer {responsive}>",
    ctx
  });
  return block;
}
function create_fragment83(ctx) {
  let responsivecontainer;
  let current;
  responsivecontainer = new ResponsiveContainer_default({
    props: {
      responsive: (
        /*responsive*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(responsivecontainer.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(responsivecontainer, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const responsivecontainer_changes = {};
      if (dirty & /*responsive*/
      1)
        responsivecontainer_changes.responsive = /*responsive*/
        ctx2[0];
      if (dirty & /*$$scope, $$restProps, classes, rows*/
      2062) {
        responsivecontainer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      responsivecontainer.$set(responsivecontainer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(responsivecontainer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(responsivecontainer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(responsivecontainer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment83.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance83($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "size", "bordered", "borderless", "striped", "hover", "responsive", "rows"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Table", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { size = "" } = $$props;
  let { bordered = false } = $$props;
  let { borderless = false } = $$props;
  let { striped = false } = $$props;
  let { hover = false } = $$props;
  let { responsive = false } = $$props;
  let { rows = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("size" in $$new_props)
      $$invalidate(5, size = $$new_props.size);
    if ("bordered" in $$new_props)
      $$invalidate(6, bordered = $$new_props.bordered);
    if ("borderless" in $$new_props)
      $$invalidate(7, borderless = $$new_props.borderless);
    if ("striped" in $$new_props)
      $$invalidate(8, striped = $$new_props.striped);
    if ("hover" in $$new_props)
      $$invalidate(9, hover = $$new_props.hover);
    if ("responsive" in $$new_props)
      $$invalidate(0, responsive = $$new_props.responsive);
    if ("rows" in $$new_props)
      $$invalidate(1, rows = $$new_props.rows);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    Colgroup: Colgroup_default,
    ResponsiveContainer: ResponsiveContainer_default,
    TableFooter: TableFooter_default,
    TableHeader: TableHeader_default,
    className,
    size,
    bordered,
    borderless,
    striped,
    hover,
    responsive,
    rows,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("size" in $$props)
      $$invalidate(5, size = $$new_props.size);
    if ("bordered" in $$props)
      $$invalidate(6, bordered = $$new_props.bordered);
    if ("borderless" in $$props)
      $$invalidate(7, borderless = $$new_props.borderless);
    if ("striped" in $$props)
      $$invalidate(8, striped = $$new_props.striped);
    if ("hover" in $$props)
      $$invalidate(9, hover = $$new_props.hover);
    if ("responsive" in $$props)
      $$invalidate(0, responsive = $$new_props.responsive);
    if ("rows" in $$props)
      $$invalidate(1, rows = $$new_props.rows);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, size, bordered, borderless, striped, hover*/
    1008) {
      $:
        $$invalidate(2, classes = classnames(className, "table", size ? "table-" + size : false, bordered ? "table-bordered" : false, borderless ? "table-borderless" : false, striped ? "table-striped" : false, hover ? "table-hover" : false));
    }
  };
  return [
    responsive,
    rows,
    classes,
    $$restProps,
    className,
    size,
    bordered,
    borderless,
    striped,
    hover,
    slots,
    $$scope
  ];
}
var Table = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance83, create_fragment83, safe_not_equal, {
      class: 4,
      size: 5,
      bordered: 6,
      borderless: 7,
      striped: 8,
      hover: 9,
      responsive: 0,
      rows: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table",
      options,
      id: create_fragment83.name
    });
  }
  get class() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bordered() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bordered(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderless() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderless(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get striped() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set striped(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get responsive() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set responsive(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rows() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rows(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Table_default = Table;

// node_modules/@sveltestrap/sveltestrap/dist/TabHeader/TabHeader.svelte
function create_default_slot9(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot9.name,
    type: "slot",
    source: "(8:0) <Nav {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment84(ctx) {
  let nav;
  let current;
  const nav_spread_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let nav_props = {
    $$slots: { default: [create_default_slot9] },
    $$scope: { ctx }
  };
  for (let i = 0; i < nav_spread_levels.length; i += 1) {
    nav_props = assign(nav_props, nav_spread_levels[i]);
  }
  nav = new Nav_default({ props: nav_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(nav.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(nav, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const nav_changes = dirty & /*$$restProps*/
      1 ? get_spread_update(nav_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[0]
      )]) : {};
      if (dirty & /*$$scope*/
      4) {
        nav_changes.$$scope = { dirty, ctx: ctx2 };
      }
      nav.$set(nav_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(nav.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(nav.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(nav, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment84.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance84($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabHeader", slots, ["default"]);
  setContext("tabs", true);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ setContext, Nav: Nav_default });
  return [$$restProps, slots, $$scope];
}
var TabHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance84, create_fragment84, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabHeader",
      options,
      id: create_fragment84.name
    });
  }
};
var TabHeader_default = TabHeader;

// node_modules/@sveltestrap/sveltestrap/dist/TabContent/TabContent.svelte
var file83 = "node_modules/@sveltestrap/sveltestrap/dist/TabContent/TabContent.svelte";
function create_default_slot10(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot10.name,
    type: "slot",
    source: "(29:2) <TabHeader class={classnames({ 'me-3': vertical })} {pills} tabs={!pills} {vertical}>",
    ctx
  });
  return block;
}
function create_fragment85(ctx) {
  let div;
  let tabheader;
  let t;
  let current;
  tabheader = new TabHeader_default({
    props: {
      class: classnames({ "me-3": (
        /*vertical*/
        ctx[1]
      ) }),
      pills: (
        /*pills*/
        ctx[0]
      ),
      tabs: !/*pills*/
      ctx[0],
      vertical: (
        /*vertical*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot10] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[3],
    { class: (
      /*classes*/
      ctx[2]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      create_component(tabheader.$$.fragment);
      t = space();
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file83, 27, 0, 656);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(tabheader, div, null);
      append_dev(div, t);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const tabheader_changes = {};
      if (dirty & /*vertical*/
      2)
        tabheader_changes.class = classnames({ "me-3": (
          /*vertical*/
          ctx2[1]
        ) });
      if (dirty & /*pills*/
      1)
        tabheader_changes.pills = /*pills*/
        ctx2[0];
      if (dirty & /*pills*/
      1)
        tabheader_changes.tabs = !/*pills*/
        ctx2[0];
      if (dirty & /*vertical*/
      2)
        tabheader_changes.vertical = /*vertical*/
        ctx2[1];
      if (dirty & /*$$scope*/
      64) {
        tabheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabheader.$set(tabheader_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*classes*/
        4) && { class: (
          /*classes*/
          ctx2[2]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tabheader.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tabheader.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(tabheader);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment85.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance85($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "pills", "vertical"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabContent", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { class: className = "" } = $$props;
  let { pills = false } = $$props;
  let { vertical = false } = $$props;
  const activeTabId = writable();
  setContext("tabContent", {
    activeTabId,
    setActiveTab: (tabId) => {
      activeTabId.set(tabId);
      dispatch("tab", tabId);
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("pills" in $$new_props)
      $$invalidate(0, pills = $$new_props.pills);
    if ("vertical" in $$new_props)
      $$invalidate(1, vertical = $$new_props.vertical);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    setContext,
    writable,
    classnames,
    TabHeader: TabHeader_default,
    dispatch,
    className,
    pills,
    vertical,
    activeTabId,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("pills" in $$props)
      $$invalidate(0, pills = $$new_props.pills);
    if ("vertical" in $$props)
      $$invalidate(1, vertical = $$new_props.vertical);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className, vertical*/
    18) {
      $:
        $$invalidate(2, classes = classnames("tab-content", className, { "d-flex align-items-start": vertical }));
    }
  };
  return [pills, vertical, classes, $$restProps, className, slots, $$scope];
}
var TabContent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance85, create_fragment85, safe_not_equal, { class: 4, pills: 0, vertical: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabContent",
      options,
      id: create_fragment85.name
    });
  }
  get class() {
    throw new Error("<TabContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TabContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pills() {
    throw new Error("<TabContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pills(value) {
    throw new Error("<TabContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vertical() {
    throw new Error("<TabContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vertical(value) {
    throw new Error("<TabContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabContent_default = TabContent;

// node_modules/@sveltestrap/sveltestrap/dist/TabPane/TabPane.svelte
var file84 = "node_modules/@sveltestrap/sveltestrap/dist/TabPane/TabPane.svelte";
var get_tab_slot_changes = (dirty) => ({});
var get_tab_slot_context = (ctx) => ({});
function create_else_block26(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[8],
    { class: (
      /*classes*/
      ctx[4]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file84, 36, 2, 915);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        256 && /*$$restProps*/
        ctx2[8],
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block26.name,
    type: "else",
    source: "(36:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block33(ctx) {
  let navitem;
  let current;
  navitem = new NavItem_default({
    props: {
      $$slots: { default: [create_default_slot11] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(navitem.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(navitem, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const navitem_changes = {};
      if (dirty & /*$$scope, tabOpen, disabled, tabId, tab*/
      16399) {
        navitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navitem.$set(navitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(navitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(navitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(navitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block33.name,
    type: "if",
    source: "(29:0) {#if tabs}",
    ctx
  });
  return block;
}
function create_if_block_118(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*tab*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*tab*/
      2)
        set_data_dev(
          t,
          /*tab*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_118.name,
    type: "if",
    source: "(32:6) {#if tab}",
    ctx
  });
  return block;
}
function create_default_slot_16(ctx) {
  let t;
  let current;
  let if_block = (
    /*tab*/
    ctx[1] && create_if_block_118(ctx)
  );
  const tab_slot_template = (
    /*#slots*/
    ctx[12].tab
  );
  const tab_slot = create_slot(
    tab_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_tab_slot_context
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      if (tab_slot)
        tab_slot.c();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, t, anchor);
      if (tab_slot) {
        tab_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*tab*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_118(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (tab_slot) {
        if (tab_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            tab_slot,
            tab_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              tab_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_tab_slot_changes
            ),
            get_tab_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tab_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tab_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      if (if_block)
        if_block.d(detaching);
      if (tab_slot)
        tab_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_16.name,
    type: "slot",
    source: "(31:4) <NavLink active={tabOpen} {disabled} on:click={() => setActiveTab(tabId)}>",
    ctx
  });
  return block;
}
function create_default_slot11(ctx) {
  let navlink;
  let current;
  navlink = new NavLink_default({
    props: {
      active: (
        /*tabOpen*/
        ctx[3]
      ),
      disabled: (
        /*disabled*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot_16] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  navlink.$on(
    "click",
    /*click_handler*/
    ctx[13]
  );
  const block = {
    c: function create() {
      create_component(navlink.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(navlink, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const navlink_changes = {};
      if (dirty & /*tabOpen*/
      8)
        navlink_changes.active = /*tabOpen*/
        ctx2[3];
      if (dirty & /*disabled*/
      1)
        navlink_changes.disabled = /*disabled*/
        ctx2[0];
      if (dirty & /*$$scope, tab*/
      16386) {
        navlink_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navlink.$set(navlink_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(navlink.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(navlink.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(navlink, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot11.name,
    type: "slot",
    source: "(30:2) <NavItem>",
    ctx
  });
  return block;
}
function create_fragment86(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block33, create_else_block26];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*tabs*/
      ctx2[5]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if_block.p(ctx2, dirty);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment86.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance86($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "active", "disabled", "tab", "tabId"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $activeTabId;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabPane", slots, ["tab", "default"]);
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  let { disabled = false } = $$props;
  let { tab = void 0 } = $$props;
  let { tabId = void 0 } = $$props;
  const tabs = getContext("tabs");
  const { activeTabId, setActiveTab } = getContext("tabContent");
  validate_store(activeTabId, "activeTabId");
  component_subscribe($$self, activeTabId, (value) => $$invalidate(11, $activeTabId = value));
  onMount(() => {
    if (active)
      setActiveTab(tabId);
  });
  let tabOpen = active;
  const click_handler = () => setActiveTab(tabId);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(9, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(10, active = $$new_props.active);
    if ("disabled" in $$new_props)
      $$invalidate(0, disabled = $$new_props.disabled);
    if ("tab" in $$new_props)
      $$invalidate(1, tab = $$new_props.tab);
    if ("tabId" in $$new_props)
      $$invalidate(2, tabId = $$new_props.tabId);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    onMount,
    NavItem: NavItem_default,
    NavLink: NavLink_default,
    classnames,
    className,
    active,
    disabled,
    tab,
    tabId,
    tabs,
    activeTabId,
    setActiveTab,
    tabOpen,
    classes,
    $activeTabId
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(9, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(10, active = $$new_props.active);
    if ("disabled" in $$props)
      $$invalidate(0, disabled = $$new_props.disabled);
    if ("tab" in $$props)
      $$invalidate(1, tab = $$new_props.tab);
    if ("tabId" in $$props)
      $$invalidate(2, tabId = $$new_props.tabId);
    if ("tabOpen" in $$props)
      $$invalidate(3, tabOpen = $$new_props.tabOpen);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$activeTabId, tabId*/
    2052) {
      $:
        if ($activeTabId !== void 0)
          $$invalidate(3, tabOpen = $activeTabId === tabId);
    }
    if ($$self.$$.dirty & /*className, tabOpen*/
    520) {
      $:
        $$invalidate(4, classes = classnames("tab-pane", className, { active: tabOpen, show: tabOpen }));
    }
  };
  return [
    disabled,
    tab,
    tabId,
    tabOpen,
    classes,
    tabs,
    activeTabId,
    setActiveTab,
    $$restProps,
    className,
    active,
    $activeTabId,
    slots,
    click_handler,
    $$scope
  ];
}
var TabPane = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance86, create_fragment86, safe_not_equal, {
      class: 9,
      active: 10,
      disabled: 0,
      tab: 1,
      tabId: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabPane",
      options,
      id: create_fragment86.name
    });
  }
  get class() {
    throw new Error("<TabPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TabPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<TabPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<TabPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<TabPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<TabPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tab() {
    throw new Error("<TabPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tab(value) {
    throw new Error("<TabPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabId() {
    throw new Error("<TabPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabId(value) {
    throw new Error("<TabPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabPane_default = TabPane;

// node_modules/@sveltestrap/sveltestrap/dist/Theme/helpers.js
var colorMode = writable(getInitialColorMode());
colorMode.subscribe((mode) => useColorMode(mode));
function getInitialColorMode() {
  var _a, _b, _c;
  const currentTheme = ((_a = globalThis.document) == null ? void 0 : _a.documentElement.getAttribute("data-bs-theme")) || "light";
  const prefersDarkMode = typeof ((_b = globalThis.window) == null ? void 0 : _b.matchMedia) === "function" ? (_c = globalThis.window) == null ? void 0 : _c.matchMedia("(prefers-color-scheme: dark)").matches : false;
  return currentTheme === "dark" || currentTheme === "auto" && prefersDarkMode ? "dark" : "light";
}
function useColorMode(element2, mode) {
  var _a;
  let target = element2;
  if (arguments.length === 1) {
    target = (_a = globalThis.document) == null ? void 0 : _a.documentElement;
    if (!target) {
      return;
    }
    mode = element2;
    colorMode.update(() => mode);
  }
  target.setAttribute("data-bs-theme", mode);
}
function toggleColorMode(element2) {
  var _a;
  const target = element2 || ((_a = globalThis.document) == null ? void 0 : _a.documentElement);
  if (!target) {
    return;
  }
  const currentMode = target.getAttribute("data-bs-theme");
  const newMode = currentMode === "dark" ? "light" : "dark";
  if (!element2) {
    colorMode.update(() => newMode);
  }
  target.setAttribute("data-bs-theme", newMode);
}

// node_modules/@sveltestrap/sveltestrap/dist/Theme/Theme.svelte
var file85 = "node_modules/@sveltestrap/sveltestrap/dist/Theme/Theme.svelte";
function add_css3(target) {
  append_styles(target, "svelte-f2gsno", "span.svelte-f2gsno{display:contents}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGhlbWUuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWVFLGtCQUFLLENBQ0gsT0FBTyxDQUFFLFFBQ1giLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiVGhlbWUuc3ZlbHRlIl19 */");
}
function create_fragment87(ctx) {
  let span;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      attr_dev(span, "class", "svelte-f2gsno");
      add_location(span, file85, 10, 0, 152);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      ctx[4](span);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[4](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment87.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance87($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Theme", slots, ["default"]);
  let { theme = "dark" } = $$props;
  let ref = null;
  const writable_props = ["theme"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Theme> was created with unknown prop '${key}'`);
  });
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(1, theme = $$props2.theme);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ useColorMode, theme, ref });
  $$self.$inject_state = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(1, theme = $$props2.theme);
    if ("ref" in $$props2)
      $$invalidate(0, ref = $$props2.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*ref, theme*/
    3) {
      $:
        ref && useColorMode(ref, theme);
    }
  };
  return [ref, theme, $$scope, slots, span_binding];
}
var Theme = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance87, create_fragment87, safe_not_equal, { theme: 1 }, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Theme",
      options,
      id: create_fragment87.name
    });
  }
  get theme() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Theme_default = Theme;

// node_modules/@sveltestrap/sveltestrap/dist/Theme/ThemeToggler.svelte
var get_default_slot_changes2 = (dirty) => ({
  currentColorMode: dirty & /*currentColorMode*/
  1
});
var get_default_slot_context2 = (ctx) => ({
  currentColorMode: (
    /*currentColorMode*/
    ctx[0]
  ),
  toggleColorMode
});
function create_fragment88(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    get_default_slot_context2
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, currentColorMode*/
        3)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment88.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance88($$self, $$props, $$invalidate) {
  let $colorMode;
  validate_store(colorMode, "colorMode");
  component_subscribe($$self, colorMode, ($$value) => $$invalidate(3, $colorMode = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ThemeToggler", slots, ["default"]);
  let currentColorMode = $colorMode;
  colorMode.subscribe((value) => {
    $$invalidate(0, currentColorMode = value);
  });
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ThemeToggler> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    colorMode,
    toggleColorMode,
    currentColorMode,
    $colorMode
  });
  $$self.$inject_state = ($$props2) => {
    if ("currentColorMode" in $$props2)
      $$invalidate(0, currentColorMode = $$props2.currentColorMode);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [currentColorMode, $$scope, slots];
}
var ThemeToggler = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance88, create_fragment88, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ThemeToggler",
      options,
      id: create_fragment88.name
    });
  }
};
var ThemeToggler_default = ThemeToggler;

// node_modules/@sveltestrap/sveltestrap/dist/ToastBody/ToastBody.svelte
var file86 = "node_modules/@sveltestrap/sveltestrap/dist/ToastBody/ToastBody.svelte";
function create_fragment89(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1],
    { class: (
      /*classes*/
      ctx[0]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file86, 9, 0, 170);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*classes*/
        1) && { class: (
          /*classes*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment89.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance89($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToastBody", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    4) {
      $:
        $$invalidate(0, classes = classnames(className, "toast-body"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var ToastBody = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance89, create_fragment89, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToastBody",
      options,
      id: create_fragment89.name
    });
  }
  get class() {
    throw new Error("<ToastBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ToastBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToastBody_default = ToastBody;

// node_modules/@sveltestrap/sveltestrap/dist/ToastHeader/ToastHeader.svelte
var file87 = "node_modules/@sveltestrap/sveltestrap/dist/ToastHeader/ToastHeader.svelte";
var get_close_slot_changes3 = (dirty) => ({});
var get_close_slot_context3 = (ctx) => ({});
var get_icon_slot_changes = (dirty) => ({});
var get_icon_slot_context = (ctx) => ({});
function create_else_block27(ctx) {
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[8].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_icon_slot_context
  );
  const block = {
    c: function create() {
      if (icon_slot)
        icon_slot.c();
    },
    m: function mount(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_icon_slot_changes
            ),
            get_icon_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block27.name,
    type: "else",
    source: "(29:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_119(ctx) {
  let svg;
  let rect;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      attr_dev(rect, "fill", "currentColor");
      attr_dev(rect, "width", "100%");
      attr_dev(rect, "height", "100%");
      add_location(rect, file87, 26, 6, 644);
      attr_dev(svg, "class", svg_class_value = `rounded text-${/*icon*/
      ctx[0]}`);
      attr_dev(svg, "width", "20");
      attr_dev(svg, "height", "20");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "preserveAspectRatio", "xMidYMid slice");
      attr_dev(svg, "focusable", "false");
      attr_dev(svg, "role", "img");
      add_location(svg, file87, 17, 4, 430);
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, rect);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*icon*/
      1 && svg_class_value !== (svg_class_value = `rounded text-${/*icon*/
      ctx2[0]}`)) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_119.name,
    type: "if",
    source: "(17:2) {#if icon}",
    ctx
  });
  return block;
}
function create_if_block34(ctx) {
  let current;
  const close_slot_template = (
    /*#slots*/
    ctx[8].close
  );
  const close_slot = create_slot(
    close_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_close_slot_context3
  );
  const close_slot_or_fallback = close_slot || fallback_block10(ctx);
  const block = {
    c: function create() {
      if (close_slot_or_fallback)
        close_slot_or_fallback.c();
    },
    m: function mount(target, anchor) {
      if (close_slot_or_fallback) {
        close_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (close_slot) {
        if (close_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            close_slot,
            close_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              close_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_close_slot_changes3
            ),
            get_close_slot_context3
          );
        }
      } else {
        if (close_slot_or_fallback && close_slot_or_fallback.p && (!current || dirty & /*closeAriaLabel, toggle*/
        6)) {
          close_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(close_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(close_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (close_slot_or_fallback)
        close_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block34.name,
    type: "if",
    source: "(35:2) {#if toggle}",
    ctx
  });
  return block;
}
function fallback_block10(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      close: true,
      "aria-label": (
        /*closeAriaLabel*/
        ctx[2]
      )
    },
    $$inline: true
  });
  button.$on("click", function() {
    if (is_function(
      /*toggle*/
      ctx[1]
    ))
      ctx[1].apply(this, arguments);
  });
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty & /*closeAriaLabel*/
      4)
        button_changes["aria-label"] = /*closeAriaLabel*/
        ctx[2];
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block10.name,
    type: "fallback",
    source: "(36:23)        ",
    ctx
  });
  return block;
}
function create_fragment90(ctx) {
  let div;
  let current_block_type_index;
  let if_block0;
  let t0;
  let strong;
  let t1;
  let current;
  const if_block_creators = [create_if_block_119, create_else_block27];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*icon*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let if_block1 = (
    /*toggle*/
    ctx[1] && create_if_block34(ctx)
  );
  let div_levels = [
    /*$$restProps*/
    ctx[5],
    { class: (
      /*classes*/
      ctx[4]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if_block0.c();
      t0 = space();
      strong = element("strong");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      attr_dev(
        strong,
        "class",
        /*tagClassName*/
        ctx[3]
      );
      add_location(strong, file87, 31, 2, 756);
      set_attributes(div, div_data);
      add_location(div, file87, 15, 0, 374);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append_dev(div, t0);
      append_dev(div, strong);
      if (default_slot) {
        default_slot.m(strong, null);
      }
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t0);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*tagClassName*/
      8) {
        attr_dev(
          strong,
          "class",
          /*tagClassName*/
          ctx2[3]
        );
      }
      if (
        /*toggle*/
        ctx2[1]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*toggle*/
          2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block34(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5],
        (!current || dirty & /*classes*/
        16) && { class: (
          /*classes*/
          ctx2[4]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if_blocks[current_block_type_index].d();
      if (default_slot)
        default_slot.d(detaching);
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment90.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance90($$self, $$props, $$invalidate) {
  let classes;
  let tagClassName;
  const omit_props_names = ["class", "icon", "toggle", "closeAriaLabel"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToastHeader", slots, ["icon", "default", "close"]);
  let { class: className = "" } = $$props;
  let { icon = null } = $$props;
  let { toggle = null } = $$props;
  let { closeAriaLabel = "Close" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(6, className = $$new_props.class);
    if ("icon" in $$new_props)
      $$invalidate(0, icon = $$new_props.icon);
    if ("toggle" in $$new_props)
      $$invalidate(1, toggle = $$new_props.toggle);
    if ("closeAriaLabel" in $$new_props)
      $$invalidate(2, closeAriaLabel = $$new_props.closeAriaLabel);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    Button: Button_default,
    className,
    icon,
    toggle,
    closeAriaLabel,
    tagClassName,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(6, className = $$new_props.className);
    if ("icon" in $$props)
      $$invalidate(0, icon = $$new_props.icon);
    if ("toggle" in $$props)
      $$invalidate(1, toggle = $$new_props.toggle);
    if ("closeAriaLabel" in $$props)
      $$invalidate(2, closeAriaLabel = $$new_props.closeAriaLabel);
    if ("tagClassName" in $$props)
      $$invalidate(3, tagClassName = $$new_props.tagClassName);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*className*/
    64) {
      $:
        $$invalidate(4, classes = classnames(className, "toast-header"));
    }
    if ($$self.$$.dirty & /*icon*/
    1) {
      $:
        $$invalidate(3, tagClassName = classnames("me-auto", { "ms-2": icon !== null }));
    }
  };
  return [
    icon,
    toggle,
    closeAriaLabel,
    tagClassName,
    classes,
    $$restProps,
    className,
    $$scope,
    slots
  ];
}
var ToastHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance90, create_fragment90, safe_not_equal, {
      class: 6,
      icon: 0,
      toggle: 1,
      closeAriaLabel: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToastHeader",
      options,
      id: create_fragment90.name
    });
  }
  get class() {
    throw new Error("<ToastHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ToastHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<ToastHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<ToastHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<ToastHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<ToastHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeAriaLabel() {
    throw new Error("<ToastHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeAriaLabel(value) {
    throw new Error("<ToastHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToastHeader_default = ToastHeader;

// node_modules/@sveltestrap/sveltestrap/dist/Toast/Toast.svelte
var file88 = "node_modules/@sveltestrap/sveltestrap/dist/Toast/Toast.svelte";
function create_if_block35(ctx) {
  let div;
  let t;
  let current_block_type_index;
  let if_block1;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*header*/
    ctx[4] && create_if_block_213(ctx)
  );
  const if_block_creators = [create_if_block_120, create_else_block28];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*body*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div_levels = [
    /*$$restProps*/
    ctx[9],
    { class: (
      /*classes*/
      ctx[7]
    ) },
    { "data-bs-theme": (
      /*theme*/
      ctx[5]
    ) },
    { role: "alert" }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if_block1.c();
      set_attributes(div, div_data);
      add_location(div, file88, 101, 2, 2215);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "introstart",
            /*introstart_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "introend",
            /*introend_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outrostart",
            /*outrostart_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outroend",
            /*outroend_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*header*/
        ctx[4]
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty & /*header*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_213(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block1.c();
        } else {
          if_block1.p(ctx, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, null);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*$$restProps*/
        512 && /*$$restProps*/
        ctx[9],
        (!current || dirty & /*classes*/
        128) && { class: (
          /*classes*/
          ctx[7]
        ) },
        (!current || dirty & /*theme*/
        32) && { "data-bs-theme": (
          /*theme*/
          ctx[5]
        ) },
        { role: "alert" }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(
              div,
              fade,
              {
                duration: (
                  /*fade*/
                  ctx[3] && /*duration*/
                  ctx[2]
                )
              },
              true
            );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(
            div,
            fade,
            {
              duration: (
                /*fade*/
                ctx[3] && /*duration*/
                ctx[2]
              )
            },
            false
          );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block35.name,
    type: "if",
    source: "(101:0) {#if isOpen}",
    ctx
  });
  return block;
}
function create_if_block_213(ctx) {
  let toastheader;
  let current;
  toastheader = new ToastHeader_default({
    props: {
      toggle: (
        /*toggle*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot_17] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(toastheader.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(toastheader, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const toastheader_changes = {};
      if (dirty & /*toggle*/
      64)
        toastheader_changes.toggle = /*toggle*/
        ctx2[6];
      if (dirty & /*$$scope, header*/
      262160) {
        toastheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      toastheader.$set(toastheader_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toastheader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toastheader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(toastheader, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_213.name,
    type: "if",
    source: "(113:4) {#if header}",
    ctx
  });
  return block;
}
function create_default_slot_17(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*header*/
        ctx[4]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*header*/
      16)
        set_data_dev(
          t,
          /*header*/
          ctx2[4]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_17.name,
    type: "slot",
    source: "(114:6) <ToastHeader {toggle}>",
    ctx
  });
  return block;
}
function create_else_block28(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block28.name,
    type: "else",
    source: "(122:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_120(ctx) {
  let toastbody;
  let current;
  toastbody = new ToastBody_default({
    props: {
      $$slots: { default: [create_default_slot12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(toastbody.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(toastbody, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const toastbody_changes = {};
      if (dirty & /*$$scope*/
      262144) {
        toastbody_changes.$$scope = { dirty, ctx: ctx2 };
      }
      toastbody.$set(toastbody_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toastbody.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toastbody.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(toastbody, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_120.name,
    type: "if",
    source: "(118:4) {#if body}",
    ctx
  });
  return block;
}
function create_default_slot12(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot12.name,
    type: "slot",
    source: "(119:6) <ToastBody>",
    ctx
  });
  return block;
}
function create_fragment91(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*isOpen*/
    ctx[0] && create_if_block35(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isOpen*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isOpen*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block35(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment91.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance91($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "class",
    "autohide",
    "body",
    "delay",
    "duration",
    "fade",
    "header",
    "isOpen",
    "theme",
    "toggle"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toast", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { class: className = "" } = $$props;
  let { autohide = false } = $$props;
  let { body = false } = $$props;
  let { delay = 5e3 } = $$props;
  let { duration = 200 } = $$props;
  let { fade: fade2 = true } = $$props;
  let { header = void 0 } = $$props;
  let { isOpen = true } = $$props;
  let { theme = null } = $$props;
  let { toggle = null } = $$props;
  let timeout;
  onDestroy(() => {
    return () => clearTimeout(timeout);
  });
  const introstart_handler = () => dispatch("opening");
  const introend_handler = () => dispatch("open");
  const outrostart_handler = () => dispatch("closing");
  const outroend_handler = () => dispatch("close");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(10, className = $$new_props.class);
    if ("autohide" in $$new_props)
      $$invalidate(11, autohide = $$new_props.autohide);
    if ("body" in $$new_props)
      $$invalidate(1, body = $$new_props.body);
    if ("delay" in $$new_props)
      $$invalidate(12, delay = $$new_props.delay);
    if ("duration" in $$new_props)
      $$invalidate(2, duration = $$new_props.duration);
    if ("fade" in $$new_props)
      $$invalidate(3, fade2 = $$new_props.fade);
    if ("header" in $$new_props)
      $$invalidate(4, header = $$new_props.header);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("theme" in $$new_props)
      $$invalidate(5, theme = $$new_props.theme);
    if ("toggle" in $$new_props)
      $$invalidate(6, toggle = $$new_props.toggle);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onDestroy,
    fadeTrans: fade,
    ToastBody: ToastBody_default,
    ToastHeader: ToastHeader_default,
    classnames,
    dispatch,
    className,
    autohide,
    body,
    delay,
    duration,
    fade: fade2,
    header,
    isOpen,
    theme,
    toggle,
    timeout,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(10, className = $$new_props.className);
    if ("autohide" in $$props)
      $$invalidate(11, autohide = $$new_props.autohide);
    if ("body" in $$props)
      $$invalidate(1, body = $$new_props.body);
    if ("delay" in $$props)
      $$invalidate(12, delay = $$new_props.delay);
    if ("duration" in $$props)
      $$invalidate(2, duration = $$new_props.duration);
    if ("fade" in $$props)
      $$invalidate(3, fade2 = $$new_props.fade);
    if ("header" in $$props)
      $$invalidate(4, header = $$new_props.header);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("theme" in $$props)
      $$invalidate(5, theme = $$new_props.theme);
    if ("toggle" in $$props)
      $$invalidate(6, toggle = $$new_props.toggle);
    if ("timeout" in $$props)
      timeout = $$new_props.timeout;
    if ("classes" in $$props)
      $$invalidate(7, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*isOpen, autohide, delay*/
    6145) {
      $:
        if (isOpen && autohide) {
          timeout = setTimeout(() => $$invalidate(0, isOpen = false), delay);
        }
    }
    if ($$self.$$.dirty & /*className, isOpen*/
    1025) {
      $:
        $$invalidate(7, classes = classnames(className, "toast", { show: isOpen }));
    }
  };
  return [
    isOpen,
    body,
    duration,
    fade2,
    header,
    theme,
    toggle,
    classes,
    dispatch,
    $$restProps,
    className,
    autohide,
    delay,
    slots,
    introstart_handler,
    introend_handler,
    outrostart_handler,
    outroend_handler,
    $$scope
  ];
}
var Toast = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance91, create_fragment91, safe_not_equal, {
      class: 10,
      autohide: 11,
      body: 1,
      delay: 12,
      duration: 2,
      fade: 3,
      header: 4,
      isOpen: 0,
      theme: 5,
      toggle: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toast",
      options,
      id: create_fragment91.name
    });
  }
  get class() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autohide() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autohide(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get body() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set body(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get delay() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set delay(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fade() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fade(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Toast_default = Toast;

// node_modules/@sveltestrap/sveltestrap/dist/Tooltip/Tooltip.svelte
var file89 = "node_modules/@sveltestrap/sveltestrap/dist/Tooltip/Tooltip.svelte";
function create_if_block36(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*outer*/
    ctx[6]
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        $$slots: { default: [create_default_slot13] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*outer*/
      64 && switch_value !== (switch_value = /*outer*/
      ctx2[6])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*$$scope, $$restProps, classes, id, theme, popperPlacement, tooltipEl, children*/
        524734) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block36.name,
    type: "if",
    source: "(195:0) {#if isOpen}",
    ctx
  });
  return block;
}
function create_else_block29(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block29.name,
    type: "else",
    source: "(210:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_121(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*children*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*children*/
      2)
        set_data_dev(
          t,
          /*children*/
          ctx2[1]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_121.name,
    type: "if",
    source: "(208:8) {#if children}",
    ctx
  });
  return block;
}
function create_default_slot13(ctx) {
  let div2;
  let div0;
  let t;
  let div1;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_121, create_else_block29];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*children*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div2_levels = [
    /*$$restProps*/
    ctx[8],
    { class: (
      /*classes*/
      ctx[7]
    ) },
    { id: (
      /*id*/
      ctx[2]
    ) },
    { role: "tooltip" },
    { "data-bs-theme": (
      /*theme*/
      ctx[3]
    ) },
    {
      "x-placement": (
        /*popperPlacement*/
        ctx[4]
      )
    }
  ];
  let div_data_2 = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div_data_2 = assign(div_data_2, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t = space();
      div1 = element("div");
      if_block.c();
      attr_dev(div0, "class", "tooltip-arrow");
      attr_dev(div0, "data-popper-arrow", "");
      add_location(div0, file89, 205, 6, 4497);
      attr_dev(div1, "class", "tooltip-inner");
      add_location(div1, file89, 206, 6, 4551);
      set_attributes(div2, div_data_2);
      add_location(div2, file89, 196, 4, 4311);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div0);
      append_dev(div2, t);
      append_dev(div2, div1);
      if_blocks[current_block_type_index].m(div1, null);
      ctx[18](div2);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div1, null);
      }
      set_attributes(div2, div_data_2 = get_spread_update(div2_levels, [
        dirty & /*$$restProps*/
        256 && /*$$restProps*/
        ctx2[8],
        (!current || dirty & /*classes*/
        128) && { class: (
          /*classes*/
          ctx2[7]
        ) },
        (!current || dirty & /*id*/
        4) && { id: (
          /*id*/
          ctx2[2]
        ) },
        { role: "tooltip" },
        (!current || dirty & /*theme*/
        8) && { "data-bs-theme": (
          /*theme*/
          ctx2[3]
        ) },
        (!current || dirty & /*popperPlacement*/
        16) && {
          "x-placement": (
            /*popperPlacement*/
            ctx2[4]
          )
        }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if_blocks[current_block_type_index].d();
      ctx[18](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot13.name,
    type: "slot",
    source: "(196:2) <svelte:component this={outer}>",
    ctx
  });
  return block;
}
function create_fragment92(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*isOpen*/
    ctx[0] && create_if_block36(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*isOpen*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isOpen*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block36(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment92.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance92($$self, $$props, $$invalidate) {
  let classes;
  let outer;
  const omit_props_names = [
    "class",
    "animation",
    "children",
    "container",
    "id",
    "isOpen",
    "placement",
    "target",
    "theme"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tooltip", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { animation = true } = $$props;
  let { children = "" } = $$props;
  let { container = void 0 } = $$props;
  let { id = `tooltip_${uuid()}` } = $$props;
  let { isOpen = false } = $$props;
  let { placement = "top" } = $$props;
  let { target = "" } = $$props;
  let { theme = null } = $$props;
  let bsPlacement;
  let popperInstance;
  let popperPlacement = placement;
  let targetEl;
  let tooltipEl;
  const checkPopperPlacement = {
    name: "checkPopperPlacement",
    enabled: true,
    phase: "main",
    // @ts-ignore
    fn({ state }) {
      $$invalidate(4, popperPlacement = state.placement);
    }
  };
  const open = () => $$invalidate(0, isOpen = true);
  const close = () => $$invalidate(0, isOpen = false);
  onMount(registerEventListeners);
  onDestroy(unregisterEventListeners);
  function registerEventListeners() {
    if (target == null || !target) {
      $$invalidate(16, targetEl = null);
      return;
    }
    try {
      if (target instanceof HTMLElement) {
        $$invalidate(16, targetEl = target);
      }
    } catch (e) {
    }
    if (targetEl == null) {
      try {
        $$invalidate(16, targetEl = document.querySelector(`#${target}`));
      } catch (e) {
      }
    }
    if (targetEl) {
      targetEl.addEventListener("mouseover", open);
      targetEl.addEventListener("mouseleave", close);
      targetEl.addEventListener("focus", open);
      targetEl.addEventListener("blur", close);
    }
  }
  function unregisterEventListeners() {
    if (targetEl) {
      targetEl.removeEventListener("mouseover", open);
      targetEl.removeEventListener("mouseleave", close);
      targetEl.removeEventListener("focus", open);
      targetEl.removeEventListener("blur", close);
      targetEl.removeAttribute("aria-describedby");
    }
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tooltipEl = $$value;
      $$invalidate(5, tooltipEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(9, className = $$new_props.class);
    if ("animation" in $$new_props)
      $$invalidate(10, animation = $$new_props.animation);
    if ("children" in $$new_props)
      $$invalidate(1, children = $$new_props.children);
    if ("container" in $$new_props)
      $$invalidate(11, container = $$new_props.container);
    if ("id" in $$new_props)
      $$invalidate(2, id = $$new_props.id);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("placement" in $$new_props)
      $$invalidate(12, placement = $$new_props.placement);
    if ("target" in $$new_props)
      $$invalidate(13, target = $$new_props.target);
    if ("theme" in $$new_props)
      $$invalidate(3, theme = $$new_props.theme);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    onMount,
    createPopper: createPopper3,
    classnames,
    uuid,
    InlineContainer: InlineContainer_default,
    Portal: Portal_default,
    className,
    animation,
    children,
    container,
    id,
    isOpen,
    placement,
    target,
    theme,
    bsPlacement,
    popperInstance,
    popperPlacement,
    targetEl,
    tooltipEl,
    checkPopperPlacement,
    open,
    close,
    registerEventListeners,
    unregisterEventListeners,
    outer,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(9, className = $$new_props.className);
    if ("animation" in $$props)
      $$invalidate(10, animation = $$new_props.animation);
    if ("children" in $$props)
      $$invalidate(1, children = $$new_props.children);
    if ("container" in $$props)
      $$invalidate(11, container = $$new_props.container);
    if ("id" in $$props)
      $$invalidate(2, id = $$new_props.id);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("placement" in $$props)
      $$invalidate(12, placement = $$new_props.placement);
    if ("target" in $$props)
      $$invalidate(13, target = $$new_props.target);
    if ("theme" in $$props)
      $$invalidate(3, theme = $$new_props.theme);
    if ("bsPlacement" in $$props)
      $$invalidate(14, bsPlacement = $$new_props.bsPlacement);
    if ("popperInstance" in $$props)
      $$invalidate(15, popperInstance = $$new_props.popperInstance);
    if ("popperPlacement" in $$props)
      $$invalidate(4, popperPlacement = $$new_props.popperPlacement);
    if ("targetEl" in $$props)
      $$invalidate(16, targetEl = $$new_props.targetEl);
    if ("tooltipEl" in $$props)
      $$invalidate(5, tooltipEl = $$new_props.tooltipEl);
    if ("outer" in $$props)
      $$invalidate(6, outer = $$new_props.outer);
    if ("classes" in $$props)
      $$invalidate(7, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*isOpen, tooltipEl, targetEl, placement, popperInstance*/
    102433) {
      $: {
        if (isOpen && tooltipEl) {
          $$invalidate(15, popperInstance = createPopper3(targetEl, tooltipEl, {
            placement,
            modifiers: [checkPopperPlacement]
          }));
        } else if (popperInstance) {
          popperInstance.destroy();
          $$invalidate(15, popperInstance = void 0);
        }
      }
    }
    if ($$self.$$.dirty & /*target*/
    8192) {
      $:
        if (target) {
          unregisterEventListeners();
          registerEventListeners();
        }
    }
    if ($$self.$$.dirty & /*targetEl, isOpen, id*/
    65541) {
      $:
        if (targetEl) {
          if (isOpen) {
            targetEl.setAttribute("aria-describedby", id);
          } else {
            targetEl.removeAttribute("aria-describedby");
          }
        }
    }
    if ($$self.$$.dirty & /*popperPlacement*/
    16) {
      $: {
        if (popperPlacement === "left") {
          $$invalidate(14, bsPlacement = "start");
        } else if (popperPlacement === "right") {
          $$invalidate(14, bsPlacement = "end");
        } else {
          $$invalidate(14, bsPlacement = popperPlacement);
        }
      }
    }
    if ($$self.$$.dirty & /*className, animation, bsPlacement, isOpen*/
    17921) {
      $:
        $$invalidate(7, classes = classnames(className, "tooltip", animation ? "fade" : false, `bs-tooltip-${bsPlacement}`, isOpen ? "show" : false));
    }
    if ($$self.$$.dirty & /*container*/
    2048) {
      $:
        $$invalidate(6, outer = container === "inline" ? InlineContainer_default : Portal_default);
    }
  };
  return [
    isOpen,
    children,
    id,
    theme,
    popperPlacement,
    tooltipEl,
    outer,
    classes,
    $$restProps,
    className,
    animation,
    container,
    placement,
    target,
    bsPlacement,
    popperInstance,
    targetEl,
    slots,
    div2_binding,
    $$scope
  ];
}
var Tooltip = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance92, create_fragment92, safe_not_equal, {
      class: 9,
      animation: 10,
      children: 1,
      container: 11,
      id: 2,
      isOpen: 0,
      placement: 12,
      target: 13,
      theme: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tooltip",
      options,
      id: create_fragment92.name
    });
  }
  get class() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animation() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animation(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get container() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placement() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placement(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tooltip_default = Tooltip;
export {
  Accordion_default as Accordion,
  AccordionHeader_default as AccordionHeader,
  AccordionItem_default as AccordionItem,
  Alert_default as Alert,
  Badge_default as Badge,
  Breadcrumb_default as Breadcrumb,
  BreadcrumbItem_default as BreadcrumbItem,
  Button_default as Button,
  ButtonDropdown_default as ButtonDropdown,
  ButtonGroup_default as ButtonGroup,
  ButtonToolbar_default as ButtonToolbar,
  Card_default as Card,
  CardBody_default as CardBody,
  CardColumns_default as CardColumns,
  CardDeck_default as CardDeck,
  CardFooter_default as CardFooter,
  CardGroup_default as CardGroup,
  CardHeader_default as CardHeader,
  CardImg_default as CardImg,
  CardImgOverlay_default as CardImgOverlay,
  CardLink_default as CardLink,
  CardSubtitle_default as CardSubtitle,
  CardText_default as CardText,
  CardTitle_default as CardTitle,
  Carousel_default as Carousel,
  CarouselCaption_default as CarouselCaption,
  CarouselControl_default as CarouselControl,
  CarouselIndicators_default as CarouselIndicators,
  CarouselItem_default as CarouselItem,
  Col_default as Col,
  Collapse_default as Collapse,
  Column_default as Column,
  Container_default as Container,
  Dropdown_default as Dropdown,
  DropdownItem_default as DropdownItem,
  DropdownMenu_default as DropdownMenu,
  DropdownToggle_default as DropdownToggle,
  Fade_default as Fade,
  Figure_default as Figure,
  Form_default as Form,
  FormCheck_default as FormCheck,
  FormFeedback_default as FormFeedback,
  FormGroup_default as FormGroup,
  FormText_default as FormText,
  Icon_default as Icon,
  Image_default as Image,
  InlineContainer_default as InlineContainer,
  Input_default as Input,
  InputGroup_default as InputGroup,
  InputGroupText_default as InputGroupText,
  Jumbotron_default as Jumbotron,
  Label_default as Label,
  ListGroup_default as ListGroup,
  ListGroupItem_default as ListGroupItem,
  Modal_default as Modal,
  ModalBackdrop_default as ModalBackdrop,
  ModalBody_default as ModalBody,
  ModalFooter_default as ModalFooter,
  ModalHeader_default as ModalHeader,
  Nav_default as Nav,
  NavItem_default as NavItem,
  NavLink_default as NavLink,
  Navbar_default as Navbar,
  NavbarBrand_default as NavbarBrand,
  NavbarToggler_default as NavbarToggler,
  Offcanvas_default as Offcanvas,
  OffcanvasBackdrop_default as OffcanvasBackdrop,
  OffcanvasBody_default as OffcanvasBody,
  OffcanvasHeader_default as OffcanvasHeader,
  Pagination_default as Pagination,
  PaginationItem_default as PaginationItem,
  PaginationLink_default as PaginationLink,
  Popover_default as Popover,
  Portal_default as Portal,
  Progress_default as Progress,
  Row_default as Row,
  Spinner_default as Spinner,
  Styles_default as Styles,
  TabContent_default as TabContent,
  TabPane_default as TabPane,
  Table_default as Table,
  Theme_default as Theme,
  ThemeToggler_default as ThemeToggler,
  Toast_default as Toast,
  ToastBody_default as ToastBody,
  ToastHeader_default as ToastHeader,
  Tooltip_default as Tooltip,
  colorMode,
  toggleColorMode,
  useColorMode
};
//# sourceMappingURL=@sveltestrap_sveltestrap.js.map
